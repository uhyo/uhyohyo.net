<% @page.title="十章第一回　XPathとは"
@page.prev=[9,8]
@page.next=[10,2] %>
<h2>十章第一回　XPathとは</h2>
<p>十章では、またDOMの話題に戻って来ます。</p>

<h3>XPathとは</h3>
<p>十章で解説するのは<dfn>XPath</dfn>です。</p>
<p>XPathとは、木構造中の<strong>ノード</strong>を指し示す<strong>表現</strong>のことです。ノードは1つでもいいし複数でも構いません。</p>
<p>具体的な例として、例えば「body要素中の最初のp要素」とか、「3番目のa要素」とかそういった指定が可能です。そういわれるとCSSのセレクタを思い浮かべるかもしれません。しかし、XPathはCSSセレクタよりも数段強力な表現力をもちます。</p>
<p>JavaScript DOMにおいては、このあるノードを表す表現を<strong>条件</strong>として使うことで、対応するノードを絞り込んで処理することができるのです。</p>
<p>これは、例えば「要素名」という条件に限ればgetElementsByTagNameでできていました。また、getElementByIdも条件によりノードを絞り込んでいるといえるでしょう。</p>
<p>似たようなことは、TreeWalker（<a href="7_3.html">七章第三回</a>）でもやりました。TreeWalkerでは、関数でノードを判定することで条件としていたのです。XPathを利用したノードの絞り込みは、その別方向からのアプローチといえるでしょう。</p>

<h3>XPathの書き方</h3>
<p>さて、それではXPathの書き方を解説していきます。XPathには、<strong>独自の文法</strong>があります。しかもなかなか高性能で小規模なひとつの言語のようです。</p>
<p>まず基本ですが、XPathには「現在のノード」という感じのものがあります。そのノードを基準に進んでいって、ノードを絞り込むという感じです。</p>
<p>具体例として、<code>/html/body/p</code>というのを例としてみましょう。まず、一番最初は、現在のノードは<strong>ルートノード</strong>（<a href="3_5.html">三章第五回</a>）、すなわちdocumentということになっています。木構造は</p>
<pre><code><mark>document</mark>
　｜
　└― html
　　　　｜
　　　　├―― head
　　　　｜
　　　　└―― body
　　　　　　　　｜
　　　　　　　　…
          </code></pre>
<p>というようになっています。</p>
<p>XPathは/によって区切られていて、今回の場合順に「html」「body」「p」となっています。</p>
<p>これは、<strong>子ノード</strong>の要素名を指定するもので、それに当てはまるものが新しい現在のノードとなります。</p>
<p>つまり、ルートノード→html要素のノード→body要素のノード→p要素のノード　という順に推移してきたことになります。最終的にp要素のノードになったので、このXPath文が表すのは、そのp要素のノードということになります。</p>
<p>ちなみに、body要素の中に複数のp要素がある場合どれが当てはまるかというと、<strong>全部</strong>です。このように、該当のノードが複数となることもあります。</p>
<p>例えば、<code>/html/body/p/strong</code>のようにすると、さっきのp要素の中からさらにstrongを探すことになりますが、そのときp要素が複数あった場合、それぞれのp要素の中からstrongが全て探されます。このようなノードの集まりを<dfn>ノードセット</dfn>といいます。</p>

<h3>軸</h3>
<p>さて、これで、XPathとは /の間に要素名を書くと子を見ていって要素を特定する、というものだというように思えるかもしれませんが、実はもっと高機能です。</p>
<p>実は、今回/の間に要素名を書きましたが、実は、これは省略形です。正しくは、この中に書くのは</p>
        <pre><code><mark>軸</mark> :: <mark>ノードテスト</mark></code></pre>
<p>という形だったのです。これを<dfn>ロケーションステップ</dfn>といいます。実は、今までの書き方は<b>軸</b>が省略されて、<b>ノードテスト</b>の部分だけとなっていたのです。</p>
<p>この軸というのは、ノードを探す<b>範囲</b>を示すものです。今までは、「body要素の子の中のp要素」とか「p要素の子の中のem要素」のように、その要素の子の中から探していました。実は、これは「子」という範囲を表す軸が省略されていたからなのです。</p></p>
      <pre><p>その軸とは、<dfn>child軸</dfn>です。だから、先の例を省略せずに書くと
          <code>/<mark>child</mark>::html/<mark>child</mark>::body/<mark>child</mark>::p</code></pre>
<p>のようになります。このように、軸を省略した場合、child軸ということになります。</p>
<p>注意すべき点は、このchild軸は、<strong>直接の子</strong>しか範囲にとらないということです。例えば、</p>
<pre><code>body
｜
├―― p
｜
├――div
｜ 　　｜
｜ 　　└―― p
｜
└―― p
          </code></pre>
<p>という木構造で</p>
        <pre><code>/html/body/<mark>p</mark></code></pre>
<p>というXPath文の場合、bodyの直接の子であるpは当てはまるけども、div要素の子となっているpは当てはまらないのです。</p>
<p>さて、それでは他の軸も紹介していきます。まず紹介するのが、<dfn>descendant軸</dfn>です。これはすなわち<strong>子孫ノード</strong>で、直接の子ではなく、自分の下全てから探します。つまり、先の例だと、div要素の子のp要素も含めて3つ全てのp要素が当てはまることになります。これは、</p>
        <pre><code>/html/body/<mark>descendant</mark>::p</code></pre>
<p>というように書きますね。</p>
<p>さらに、<dfn>ancestor軸</dfn>というものがあります。これは、今度は上方向です。つまり、自分の親、そのまた親、・・・というようにルートノード（document）まで探す軸です。また、<dfn>parent軸</dfn>というのもあります。これは、直接の親だけです。すなわち、この軸の範囲にあたるのは常に1個（ルートノードの場合は親がないので0個）となります。</p>
<p>さらに、横方向の軸もあります。ひとつは<dfn>preceding-sibling軸</dfn>です。これは、兄弟ノードのうち自分より前のノードです。逆に、<dfn>following-sibling軸</dfn>という軸は、自分より後のノードを探します。</p>
<p>他には、<dfn>self軸</dfn>（自分自身のみ）という軸もあります。他に使いやすいのが、<dfn>descendant-or-self軸</dfn>（子孫と自分自身）や<dfn>ancestor-or-self</dfn>（自分より上と自分自身）があります。ここで紹介した以外にもいくつかあります。</p>

<h3>ノードテストの記法</h3>
<p>さて、こんどはノードテストに着目します。今まで、ノードテストには要素名を書いてきました。実は、ここには他にも書けるものがあります。</p>
<p>まずは<strong><code>*</code></strong>です。これは、<strong>どんな名前でもよい</strong>というものです。例えば</p>
        <pre><code>/html/body/<mark>*</mark></code></pre>
<p>とすると、body要素の子の<strong>要素ノード</strong>全てが当てはまります。言い換えると、このXPath文の結果は、body要素の子要素を全て含む<strong>ノードセット</strong>だということです。</p>
<p>今ここで要素ノードといったのは、要素ノード以外のものを取得するためのノードテストもあるからです。</p>
<p>ひとつが、<dfn>text()</dfn>です。これは、テキストノードを全て取得します。</p>
        <pre><code>/html/body/child::<mark>text()</mark></code></pre>
<p>とすると、body要素の子であるテキストノードを全て含んだ<strong>ノードセット</strong>が得られます。body要素に直接Webページの文章となるテキストは書けませんから、きっと改行などのテキストノードばかりになることでしょう。</p>
<p>今度は</p>
        <pre><code>/html/body/descendant::<mark>text()</mark></code></pre>
<p>と書けば、body要素内の全ての子ノードのノードセットとなり、Webページのテキストが全て集まるわけです。</p>
<p>この()がついている書き方は、何か関数のようですね。実際関数のようなもので、後々紹介しますが、引数がある関数とかも出てきます。</p>
<p>他には<dfn>comment()</dfn>（コメントノード）や、<dfn>node()</dfn>（全ての種類のノード）などがあります。</p>

<h3>ロケーションステップの省略</h3>
<p>次に、ロケーションステップ全体に関する省略記法を紹介します。ロケーションステップとは、/と/で挟まれた間全体で、<code>軸::ノードテスト</code>の記法を持つものでした。実は、ここ全体を省略してある文字で表したりできます。ひとつは、<code>.</code>です。これは、<code>self::node()</code> の省略形で、self軸のノード全てという意味ですが、self軸は<strong>自分自身</strong>で、当然ひとつのノードにつきひとつしかありません。つまり、これは結局自分自身を表しているということになり、ノードセットは変わりません。だから、<code>/html/body/<mark>.</mark>/<mark>.</mark>/p</code>のように、間に挟んだりしても関係ありません。</p>
<p>次は</p>
        <pre><code>..</code></pre>
<p>です。これは<code>parent::node()</code>の省略形です。parent軸は<strong>直接の親</strong>なので、self軸同様、ノードセット中のノード1つに対して最大ひとつしかありません。例えば、<code>/html/body/<mark>..</mark></code>とすると、bodyの親はhtml要素なので、これはhtml要素を表すということになります。</p>
<p>最後にもうひとつ紹介します。それは、</p>
        <pre><code>//</code></pre>
<p>という形です。これは、/と/の間に何も書かれていない、つまりロケーションステップが空ということです。このとき、これは</p>
        <pre><code>/<mark>descendant-or-self::node()</mark>/</code></pre>
<p>の省略形になります。descendant-or-self軸は、自分自身とその子孫を範囲としていて、その範囲のノード全てです。例えば、<code>/html/body//</code>とすると、body要素を含めてそれ以下の要素全部のノードセットが結果ということになります。例えばp要素を全て取得したければ、<code>/html/body//<mark>self::</mark>p</code>となることでしょう。pがself軸なのは、//によって列挙されたもののうち、それ自身からp要素を探すからです。もっとも、<code>/descendant-or-self:p</code>としても同じなので、普通こんな書き方はしないことでしょう。</p>

<p>次回以降、XPathのさらに高機能な部分やJavaScript DOMでの利用法などを解説していきます。</p>
