<% @page.title="十三章第三回　HTML5 Web Messaging"
@page.prev=[13,2]
@page.next=[13,4] %>
<h2>十三章第三回　HTML5 Web Messaging</h2>
<p>第十三章の「通信」で次に紹介するのは<dfn>HTML5 Web Messaging</dfn>です。これは今までと毛色が違い、HTTP通信はしません。</p>
<p>それではどのような通信かというと、これは<strong>ブラウジングコンテキスト間</strong>の通信です。</p>
<p>ブラウジングコンテキストとは何かというと、これは<strong>ブラウザのタブの1つ1つ</strong>のことです。つまりブラウジングコンテキストで通信するということは、複数のタブの間でデータをやりとりするということです。</p>
<p>しかし、他のブラウジングコンテキストとデータをやりとりするということは、他にどんなタブが開かれているのかを知る必要があるわけですが、ユーザーがどんなページを今閲覧しているかというのは重要な個人情報ですので、そんなものはJavaScriptからは取得できません。それではどうすればいいのでしょう。</p>

<h3>JavaScriptから他のブラウジングコンテキストを操作する</h3>
<p>それでは、JavaScriptから他のブラウジングコンテキストを操作するにはどうすればいいのでしょう。ひとつは、<strong>JavaScriptから新しいウィンドウを開く</strong>ことです。最近のブラウザではウィンドウもタブの一種ですので、ここでブラウジングコンテキストが誕生します。</p>
<p>JavaScriptからウィンドウを開くには、<dfn>window.open</dfn>メソッドを使います。</p>
<p>window.openメソッドの第一引数は<strong>URL</strong>です。第二引数はウィンドウの<strong>名前</strong>です。名前とはどこで使うかというと、同じ名前のウィンドウは1つしか作られません。これはあとで解説します。また、第三引数にオプションを指定することもできますが、ここでは詳しくは解説しません。</p>
<p>それではwindow.openのサンプルです。</p>
        <pre><code><mark>window.open</mark>("http://www.google.co.jp/","google");</code></pre>
<p><button onclick='window.open("http://www.google.co.jp/","google")'>このボタン</button>を押すと以上のプログラムが動作します。</p>
<p>ボタンを押すと、window.openによって新しいタブが開かれます。このウィンドウには内部的に第二引数の"google"という名前がつけられます。</p>
<p>ここでそのタブが開いた状態で再びボタンを押すと、新しいタブは開きません。これは、"google"という名前のウィンドウがすでにあるため、それが再利用されたからです。もしその"google"のタブを消してからボタンを押したならば、また新しいタブが開くでしょう。</p>
<p>ちなみに、最近のブラウザには「ポップアップブロック」機能がついています。これは、JavaScriptでwindow.openで勝手に広告のウィンドウを出したりするのが邪魔くさいのでそういったものを動作させないようにする機能です。ですから、「ページと同時に新しいウィンドウを開く」というプログラムを作ったりしてもポップアップブロックに引っかかってウィンドウが開いてくれない可能性が高いです。</p>
<p>今回のサンプルはブロックされないブラウザが多いとおもいますが、これは「ボタンをクリックする」というユーザー側の意図した動作がトリガーになったせいでしょう。</p>
<p>さて、そして、このwindow.openの戻り値は<strong>Window</strong>オブジェクトです。このWindowオブジェクトが、その開かれたウィンドウのブラウジングコンテキストを表すオブジェクトです。</p>
<p>ちなみに、今開いているページのブラウジングコンテキストは<strong>window</strong>という変数に入っています。</p>
<p>ちなみに、windowはdocumentというプロパティを持ち、これは今まで慣れ親しんできたdocumentです。つまり、</p>
        <pre><code><mark>window</mark>.document === document	<mark class="ins">//true</mark></code></pre>
<p>ということです。</p>
<p>つまり、window.openの戻り値であるwindowの、documentプロパティを操作すれば、開いたウィンドウの中身を操作できるかもしれませんね。</p>
<p>ところが、今回Googleを開いたように、異なるオリジンの場合はセキュリティの関係から操作できません。それでは同じオリジンなら操作できるのでしょうか。試してみましょう。下に2つのボタンを用意しました。それぞれ以下のような動作です。</p>
<pre><code><mark class="ins">//ボタン1（ウィンドウを開く）</mark>
win=window.open("/");

<mark class="ins">//ボタン2（ウィンドウの中身を書き換える）</mark>
win.<mark>document</mark>.body.textContent="書き換えました";</code></pre>
<p><button onclick='win=window.open("/")'>ボタン1</button><button onclick='win.document.body.textContent="書き換えました"'>ボタン2</button></p>
<p>ボタン1を押したあとボタン2を押してみましょう。ひらいたウィンドウの中身が書き換えられたことが確認できたと思います。</p>
<p>これが2つのウィンドウの連携の基本ですが、このように外から操作するというのはあまりスマートではありません。ではどのような方法がスマートなのかというと、外から与えるのは「指示」だけで、実際の動作は内部で行われるようなのがいいでしょう。</p>
<p>この方法の利点は、複数の異なるページから、同じページをウィンドウとして開いて同じ動作をさせるとき、外からいじるのでは同じソースを操作元の両方のページで読みこませる必要があるのに対して、指示を与える方法ならば実際に動作するソースは操作される側のページ1つだけで済むということです。</p>
<p>それで、その指示を与える方法というのが、今回紹介するWeb Messagingなのです。</p>

<h3>メッセージを送る</h3>
<p>さて、あるブラウジングコンテキストに対してメッセージを送るには、Windowオブジェクトのメソッドである<dfn>postMessage</dfn>を使います。これを呼び出すとそのウィンドウに対してメッセージを送ります。</p>
<p>引数は、第一引数が<strong>送るメッセージ</strong>です。送ることができるメッセージは、<strong>リテラル</strong>（文字列とか数値とか真偽値とか）や、普通の（Objectのインスタンスの）オブジェクトや配列、さらにはDataオブジェクトの他に、最近よく出てくるFile,Blob,FileList,ArrayBufferを送ることができます。</p>
<p>さらに、第二引数は<strong>送り先のオリジン</strong>です。これは、意図しないサイトに向けて情報を漏らしてしまわないように、送り先のオリジンを指定できるということです。</p>
<p>例えばhttp://www.google.com/以下のページに送りたい場合は、</p>
        <pre><code>postMessage("メッセージ",<mark>"http://www.google.com"</mark>);</code></pre>
<p>のようにします。そうすると他のドメインのサイトには届きません。</p>
<p>この第二引数は<strong>省略できません</strong>。ですが、例えば自分のサイトの別のページに送ったりすることも多いとおもいますが、そういう場合は省略して"/"を使えます。つまり、"/"を使った場合、送り先は送り元と同じオリジンであると解釈されます。つまり、</p>
        <pre><code>postMessage("メッセージ",<mark>"/"</mark>);</code></pre>
<p>という感じです。</p>
<p>ほかに、送り先がどのオリジンでもいいという場合は"*"にしますが、なるべく避けたほうがよいでしょう。</p>
<p>ここで注目すべきことは、<strong>メッセージを他のオリジンに送ることもできる</strong>ということです。基本的にJavaScriptからは他のオリジンは操作できませんから、これは珍しい事例であるといえます。</p>

<h3>メッセージを受け取る</h3>
<p>さて、メッセージを送られたら、送られた側では当然受け取る仕組みが必要になります。ここで使われるのが<dfn>messageイベント</dfn>です。すなわち、あるWindowに対してメッセージが送られてきた場合messageイベントが発生するのです。ここで、messageイベントが発生するのは<strong>Windowオブジェクト</strong>においてです。すなわち、こうです。</p>
<pre><code><mark>window</mark>.addEventListener("<mark>message</mark>",function(e){
});</code></pre>
<p>メッセージの中身を参照するのに使うのは当然<strong>イベントオブジェクト</strong>を使います。ここで、このmessageイベントのイベントオブジェクトを<strong>MessageEvent</strong>といいます。</p>
<p>ここで、<a href="13_2.html">前回</a>の内容を覚えていますか。EventSourceにおいてサーバーからのメッセージを受け取るのにつかったのもmessageイベントであり、そのイベントオブジェクトはMessageEventでした。実はこれらは<strong>本質的に同じもの</strong>であり、MessageEventの定義も同じです。</p>
<p>すなわち、送られてきたメッセージは<strong>dataプロパティ</strong>に入っています。</p>
<pre><code>window.addEventListener("message",function(e){
  console.log("送られてきたメッセージは",e.<mark>data</mark>);
});</code></pre>
<p>前回は、他にMessageEventの<strong>origin</strong>プロパティも紹介しています。これはWeb Messagingの場合には、送り元のページのオリジンが入っています。ちなみに前回あったlastEventIdはServer-Sent Events用なので、今回は意味がありません。</p>
<p>もう一つ<dfn>sourceプロパティ</dfn>があり、これはメッセージの送信元のWindowオブジェクトが入っています。つまりこれを使えば、メッセージを送ってきたページに対してメッセージを送り返したりできます。例えば返事を送り返す場合はこうですね。</p>
<pre><code>window.addEventListener("message",function(e){
  e.<mark>source</mark>.postMessage("返信",e.<mark>origin</mark>);
});</code></pre>
<p>ではここで、ここまでのをまとめた<a href="13_3_sample2.html">サンプル</a>を用意しました。ソースには簡単な解説を用意してあるあるので参考にして下さい。</p>

<h3>メッセージの中身</h3>
<p>さて、今まで送ったメッセージは全て文字列でした。しかし、postMessageにおいては他のタイプのメッセージを送ることができるのはすでに上で述べた通りです。</p>
<p>具体的には以下のようななものが送れます。</p>
<pre><code>12345	//数値
"hoge"	//文字列
true	//真偽値
["foo","bar","baz"]	//配列
{foo:3, bar:"hoge"}	//普通のオブジェクト
new Date()	//Dateオブジェクト
          </code></pre>
<p>他に、File,Blob,FileList,ArrayBufferなどのデータも送れます。</p>
<p>Web Messagingをうまく利用して2つのウィンドウを提携したりする機会がもしかしたらあるかもしれません。</p>
<p>次回はWeb Messagingの応用を紹介します。</p>
