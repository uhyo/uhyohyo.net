<% @page.title="四章第三回　正規表現2"
@page.prev=[4,2]
@page.next=[5,1] %>
<h2>四章第三回　正規表現2</h2>
<h3>正規表現の利用</h3>
<p>さて、正規表現は、ただその文字列がパターンにマッチするかどうかではなく、実はさまざまなことに利用できます。</p>

<h4>match</h4>
<p><dfn>match</dfn>というものがあります。これは、前回のtestと同じように、正規表現と文字列をマッチング（マッチさせること）するものです。</p>
<p>testの返り値はマッチしたかどうかの真偽値でしたが、matchの戻り値は違います。</p>
<p>matchの戻り値は<strong>配列</strong>です。この配列の0番目の要素には、<strong>マッチした文字列</strong>が入っています。</p>
<p>マッチした文字列とはどういうことかというと、例えば、<code>a.{5}c</code>という正規表現が、</p>
<pre><code>aabcbcacbuccb
 <mark>~~~~~~~</mark>
          </code></pre>
<p>という部分にマッチしたとき、この配列の0番目には<code>"abcbcac"</code>が入っています。</p>
<p>ちなみに、この正規表現は、「aとcの間に何かが5文字入っている」という正規表現ですね。</p>

<p>さて、では具体的にどう書くかというと、</p>
        <pre><code><var>文字列</var>.match(<var>正規表現オブジェクト</var>)</code></pre>
<p>というように書きます。前回のtestとは逆なので、注意しましょう。testでは引数に渡すのが文字列だったのに対し、今回引数に渡すのは正規表現オブジェクトになっています。</p>

<p>では、それなら普通に文字列を返せばいいのに、なぜ配列になっているのでしょうか。実は、1番目以降の要素も使われる場合があるのです。</p>
<p>どういうときに使われるかというと、前回解説した<strong>グループ化</strong>と関わりがあります。グループ化とは、一部分を括弧で囲んでひとまとめにすることでした。</p>
<p>実は、このようにグループ化したとき、マッチした部分のうち、さらにそのグループ化した部分だけを個別に取得することができます。例えば、上の<code>a.{5}c</code>を、<code>a<mark>(</mark>.{5}<mark>)</mark>c</code>とした場合、括弧で囲んだ<code>.{5}</code>の部分だけを、マッチした全体とは別に取得できます。</p>
<p>つまり、この正規表現が</p>
<pre><code>aabcbcacbuccb
 <mark>~~~~~~~</mark>
          </code></pre>
<p>という部分にマッチしたとき、matchの返り値である配列の0番目の要素はそれ全体である"abcbcac"です。ここで、配列の1番目に入っているのは、括弧で囲んだaとcの間の5文字だから、</p>
<pre><code>aabcbcacbuccb
  <mark>~~~~~</mark>
          </code></pre>
<p>の部分だけということになります。</p>
<p>JavaScriptで書くと、</p>
<pre><code>var str = "aabcbcacbuccb";
var result = str.<mark>match</mark>(/a(.{5})c/);
/*
result[0] は "abcbcac"
result[1] は "bcbca"
*/
          </code></pre>
<p>ということになります。</p>
<p>ちなみに、</p>
        <pre><code>a<mark>(</mark>.{5}<mark>)</mark>c<mark>(</mark>.{3}<mark>)</mark></code></pre>
<p>のように括弧が2つ以上ある場合も、1つめの括弧の中は1番目の要素に、2つめは2番目・・・のようにいくつでも取得することができます。</p>

<p>さて、これはかなり応用がききます。たとえば、<code>&lt;img src="aaa.gif"&gt;</code>のように、開始タグの文字列があったとして、ここからタグ名（今回の場合"img"）だけを抜き出したいとします。このとき、どのようにしたらいいと思いますか？</p>
<p>matchを利用して、正規表現を使えばいいのです。いろいろ書き方はありますが、例えばこうです。</p>
        <pre><code>&lt;<mark>(</mark>\S+<mark>)</mark>\s+.+&gt;</code></pre>
<p>「<code>&lt;</code>があって、その次に\S(＝空白文字以外)がいくつかあって、その次に空白がいくつかあって、さらに次には任意の文字がいくつかあって、最後に<code>&gt;</code>がある」という意味の正規表現ですね。</p>
<p>上のタグの場合だと、<code>&lt;</code>の部分が最初の&lt;で、次の<code>img</code>が<code>(\S+)</code>に当てはまり、次のスペースが<code>\s+</code>になります。</p>
<p><code>src="aaa.gif"</code>の部分は<code>.+</code>が、最後の<code>&gt;</code>には&gt;が当てはまることになります。括弧でグループ化されているのはimgの部分だから、うまくいってますね。</p>

<p>しかし、実はこれはまだ問題があります。</p>
        <pre><code>&lt;p&gt;</code></pre>
<p>のように属性などが1つもない場合はどうでしょうか。これには空白などどこにもないから、上の正規表現ではマッチしてくれません。ちなみに、その正規表現がそもそもマッチしないときは、testだとfalseを返したのに対し、matchでは配列のかわりに<strong>null</strong>を返します。そのため、resultがnullかどうか調べずにいきなり<code>result[0]</code>などを得ようとするとエラーになることがあります。</p>
<p>さて、どうすればいいかというと、後ろの空白以降の部分は<strong>あってもなくてもいい</strong>わけです。言い換えると、<strong>0個または1個ある</strong>ということです。こういうのは、前回紹介しましたね。そう、?です。これは「直前の文字が0個または1個」という意味でした。</p>
<p>しかし、今回は、文字ではなくまとまった文字列です。こういう時どうするかも前回あわせて解説しました。そう、<strong>グループ化</strong>です。</p>
<p>つまり、</p>
        <pre><code>&lt;(\S+)<mark class="ins">(</mark>\s+.+<mark class="ins">)</mark>&gt;</code></pre>
<p>このように空白文字以降の部分をグループ化して、それの後ろに</p>
        <pre><code>&lt;(\S+)(\s+.+)<mark class="ins">?</mark>&gt;</code></pre>
<p>このように<code>?</code>をつければよいわけです。</p>

<p>これで一応正規表現のほうはOKです。しかし、ここでできあがった正規表現を改めて見てみましょう。グループ化されたものが2つできています。1つめのグループ化はあとでその部分だけ参照するためで、2つめのグループ化は?を使うためというように目的は違います。</p>
<p>しかし、同じグループ化だから、2つめのグループも、あとで参照できるように配列に入ります。どうせあとで見るつもりもないのに、これは少し無駄だといえます。</p>
<p>そこで、その無駄を解消する方法があります。それは、</p>
        <pre><code>&lt;(\S+)(<mark class="ins">?:</mark>\s+.+)?&gt;</code></pre>
<p>このようにすることです。<strong><code>?:</code></strong>という2文字が付け足されました。</p>
<p>実は、( 〜 )で囲むかわりに、(<code>?:</code> 〜 )で囲むと、「グループ化はするけども、後で見ないから結果の配列には入れない」という意味になります。</p>
<p>2つめのグループは別に後で見る必要はないので、このようにすると無駄がなくていいです。</p>

<h4>replace</h4>
<p>さて、matchの他にも、よく使われるものがあります。その1つが<dfn>replace</dfn>です。これは、<strong>正規表現で検索して、マッチした部分を別の文字列に置き換える</strong>というメソッドです。</p>
<p>こんな感じで使います。</p>
        <pre><code><var>文字列</var>.replace(<var>正規表現オブジェクト</var>,<var>置き換え後文字列</var>)</code></pre>
<p>返り値が、置き換えた後の文字列です。</p>
<p>サンプルは、</p>
<pre><code>var str = "aaa1234bcd567efg8999h";		//もともとの文字列
var result = str.<mark>replace</mark>(/\d+/, "数字");	//置き換え後の文字列
console.log(result);
          </code></pre>
<p>という感じです。
  replaceの引数は、1つめが<code>/\d+/</code>で、2つめが<code>"数字"</code>ですね。</p>
<p>この正規表現オブジェクトは、<code>\d</code>が「数字1文字」を表すから、それが1つ以上ということなので、1234、555、0、29・・・といった、数字が何文字か連なったものにマッチします。よくありがちなパターンです。</p>
<p>マッチしたところが2つめの引数に置き換わるということは、今回</p>
<pre><code>aaa<mark>1234</mark>bcd567efg8999h
   <mark>~~~~</mark>
          </code></pre>
<p>の部分がマッチしたとき、その部分が</p>
<pre><code>aaa<mark>数字</mark>bcd567efg8999h
   <mark>~~~~</mark>
          </code></pre>
<p>のように置き換わるということです。結果、できあがる文字列は<code>"aaa数字bcd567efg8999h"</code>ということになります。</p>
<p>ちなみに、「567」や「8999」の部分も<code>\d+</code>の条件には当てはまるのですが、マッチするときは、原則文字列の前のほうから見ていきます。今回、一番まえにあるのが「1234」だったから、そこがマッチしたのです。</p>

<h3>正規表現のオプション</h3>
<p>オプションとは、つまり細かい設定ということです。正規表現オブジェクトひとつひとつに、こういった細かい設定を持たせることができます。</p>

<h4>iオプション</h4>
<p>iオプションというものがあります。このオプションがあると、マッチするときに<strong>半角英字の大文字と小文字を区別しなくなります</strong>。つまり、例えば<code>/abc/</code>という正規表現が、<code>AbC</code>というような文字列にもマッチするようになります。</p>
<p>では、iオプションはどうやってつけるかというと、正規表現オブジェクトを作るときに、</p>
        <pre><code>/正規表現/<mark>i</mark></code></pre>
<p>とします。正規表現の終わりを示すスラッシュの後に、iという文字がつきました。これで、iオプションがつきます。</p>
<p>これを、</p>
        <pre><code>"ABCDE".match(/abc/<mark>i</mark>)</code></pre>
<p>のように使えます。</p>
<p>ちなみに、ここで初めて出てきましたが、いちいち変数に文字列を代入しなくても、このように直接matchやreplaceを使えます。</p>

<h4>gオプション</h4>
<p>もう1つ、gオプションというものがあります。これはiオプションよりも使われると思います。つけ方はiオプションと同じで、iのかわりにgをつけるだけです。</p>
<p>このgオプションがついていると、その正規表現オブジェクトを使ってマッチングしたとき、<strong>複数回マッチします</strong>。</p>
<p>複数回マッチするというのは、上のサンプルの場合、<code>/\d+/</code>がマッチするのはgオプションが無い場合は</p>
<pre><code>aaa1234bcd567efg8999h
   <mark>~~~~</mark>
          </code></pre>
<p>の部分だけでしたが、gオプションがつくと、</p>
<pre><code>aaa1234bcd567efg8999h
   <mark>~~~~   ~~~   ~~~~</mark>
          </code></pre>
<p>のように当てはまるところ全てにマッチします。</p>
<p>それに伴って、各メソッドの動作も変わります。</p>
<p>replaceの場合簡単で、マッチした部分それぞれが置き換わります。つまり、</p>
        <pre><code>"aaa1234bcd567efg8999h".replace(/\d+/<mark>g</mark>, "数字")</code></pre>
<p>とした場合、</p>
<pre><code>aaa1234bcd567efg8999h
   <mark>~~~~   ~~~   ~~~~</mark>
          </code></pre>
<p>のように複数マッチして、</p>
        <pre><code>aaa<mark>数字</mark>bcd<mark>数字</mark>efg<mark>数字</mark>h</code></pre>
<p>という文字列が返ってきます。これはよく使うことでしょう。</p>

<p>matchは、返ってくる配列の中身が変わります。gオプションがついていない場合は、上で解説したように0番目の要素にはマッチした文字列全体が、1番目以降にはグループ化した箇所の文字列が入っているのでした。</p>
<p>これが、gオプションがつくと、マッチした文字列が、0番目から順番に入っているようになります。つまり、</p>
        <pre><code>"aaa1234bcd567efg8999h".match(/\d+/<mark>g</mark>)</code></pre>
<p>で返ってくる配列には、この文字列で</p>
<pre><code>aaa1234bcd567efg8999h
   <mark>~~~~   ~~~   ~~~~</mark>
          </code></pre>
<p>のようにマッチするから、0番目には"1234"、1番目には"567"、2番目には"8999"が入っていることになります。</p>
<p>この場合、グループ化した部分などは、配列から得られなくなります。</p>

<p>ちなみに、この2つを併用して</p>
        <pre><code>/正規表現/<mark>ig</mark></code></pre>
<p>という書き方も可能です。</p>
<p>また、前回出てきたtestは、ただマッチするかどうかを調べるだけなので、gオプションがついても動作は変わりません。</p>


<h3>replaceとグループ化</h3>
<p>上で、replaceでマッチした部分を別の文字列に置き換えるということを解説しました。実は、このとき置き換え後の文字列に、グループ化された部分の文字列を使うことができます。</p>
<p>例えば、上ではreplaceで<code>\d+</code>にマッチする部分を"数字"に置き換えましたが、これを、ただ置き換えるのではなく、"数"と"字"で囲みたいとします。例えば、"1234"という文字列にマッチしたなら、これを"数1234字"というふうに置き換えたいとしましょう。</p>
<p>このとき、次のようにします。</p>
        <pre><code>"aaa1234bcd567efg8999h".replace(/<mark>(</mark>\d+<mark>)</mark>/g, "数<mark>$1</mark>字");</code></pre>
<p>置き換え後の文字列に、"$1"という謎の文字があります。実は、これは置き換えるときに、グループ化された部分の文字列に置き換わります。$1は最初のグループ化、$2ならその次、$3、$4…と続きます。</p>

<p>今回gオプションをつけたので、当てはまるところ全てにマッチします。つまり、</p>
<pre><code>aaa1234bcd567efg8999h
   <mark>~~~~   ~~~   ~~~~</mark>
          </code></pre>
<p>が</p>
        <pre><code>aaa<mark>数1234字</mark>bcd<mark>数567字</mark>efg<mark>数8999字</mark>h</code></pre>
<p>というように置き換わります。</p>

<h3>最長マッチと最短マッチ</h3>
<p>最後に最長マッチと最短マッチというものについて解説します。</p>
<p>例えば、上で解説した機能を使って、" 〜 "で囲まれている部分を「 〜 」で囲むように置き換える処理を作ってみたいと思います。</p>
<p>" 〜 "で囲まれている部分を表す正規表現は、次のようになりますね。</p>
        <pre><code>".*"</code></pre>
<p>最初と最後に"があって、その間は<code>.*</code>だから、任意の文字が何個かあるか、もしくはないということです。</p>
<p>囲まれている部分は置き換え時に使うので、</p>
        <pre><code>"<mark class="ins">(</mark>.*<mark class="ins">)</mark>"</code></pre>
<p>のようにグループ化します。replaceで実際に置き換えると、</p>
        <pre><code><var>文字列</var>.replace(/"(.*)"/g, "「$1」")</code></pre>
<p>という形になります。複数" 〜 "で囲まれた部分があった場合全て置き換えたいということで、今回はgオプションをつけてみました。</p>
<p>さて、これでいいように思えますが、実は問題もあります。実際に、" 〜 "で囲まれた文字列が2つある</p>
        <pre><code>"aaaaa".  "bbbbb".</code></pre>
<p>という文字列を置き換えることを考えてみます。まず<code>"(.*)"</code>がマッチする部分ですが、当然</p>
<pre><code>"aaaaa".  "bbbbb".
<mark>~~~~~~~</mark>   <mark>~~~~~~~</mark>
          </code></pre>
<p>のように2つマッチしてほしいわけです。ところが、<strong>実際は違います</strong>。</p>
<pre><code>"aaaaa".  "bbbbb".
<mark>~~~~~~~~~~~~~~~~~</mark>
          </code></pre>
<p>このようにマッチします。確かに、これ全体をひとかたまりにしてみると、"で始まって、"で終わっています。この場合、<code>.*</code>にあてはまるのは、最初と最後の"を除いた</p>
        <pre><code>aaaaa".  "bbbbb</code></pre>
<p>の部分です。</p>
<p>このようになるのは、マッチするとき、<strong>なるべく長くなるようにマッチする</strong>という性質によるものです。この性質を、<strong>最長マッチ</strong>などといいます。</p>
<p>これを改善する方法は、2つあります。まず、今回説明したい方から解説します。</p>

<p>それは、この最長マッチという性質を変えるという方法です。理想的なのは、<strong>なるべく短くなるようにマッチする</strong>というような性質です。この性質は、<strong>最短マッチ</strong>などとよばれます。</p>
<p>実は、最長マッチをこの最短マッチに変える方法はちゃんとあります。それは、+、*などの、繰り返しを表す記号の直後に、<strong>?</strong>をつけます。注意してほしいのが、この?は、「直前の文字が0回または1回」という意味のそれとは別物であるということです。あくまで、+や*などの繰り返しの記号のあとに?をつけるのです。</p>
<p>つまり、</p>
        <pre><code>"(.*<mark>?</mark>)"</code></pre>
<p>ということになります。今回余計に多くの文字をマッチさせたのがこの繰り返しの部分だから、ここを最短マッチにします。</p>
<pre><code>"aaaaa".  "bbbbb".
<mark>~</mark>
          </code></pre>
<p>最初の"があって、その後<code>.*</code>の部分は</p>
<pre><code>"aaaaa".  "bbbbb".
 <mark>~~~~~~~~~~~~~~~</mark>
          </code></pre>
<p>というようにマッチするよりも</p>
<pre><code>"aaaaa".  "bbbbb".
 <mark>~~~~~</mark>
          </code></pre>
<p>までしかマッチしないほうが短いから、最短マッチなのでこのようにマッチすることになります。すると最後の"はその直後の"にマッチし、結果</p>
<pre><code>"aaaaa".  "bbbbb".
<mark>~~~~~~~</mark>
          </code></pre>
<p>の部分が全体としてマッチするわけです。</p>
<p>また、今回gオプションがついているので、今回まだ<code>"bbbbb"</code>の部分がマッチしないで残っているから、この部分も同じようにマッチしてくれます。</p>
<p>この最短マッチもけっこうよく使うものです。</p>

<p>さて、2つめの方法ですが、こっちはけっこう単純です。</p>
<p><code>.*</code>の部分が、任意の文字だからといって、"が出てきてもそれも含んでどんどん先までマッチしてしまったことが原因だから、この<code>.</code>が0回以上繰り返すというものを、<strong>"以外の文字</strong>が0回以上繰り返すというようにすればいいのです。</p>
<p>すると、この" 〜 "の間の文字に"が含まれることはなくなるので、正しくマッチします。</p>
        <pre><code>"(<mark>[^"]</mark>*)"</code></pre>
<p>のようになりますね。</p>
