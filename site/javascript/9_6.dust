<p>今回紹介する<dfn>ゲッタ</dfn>と<dfn>セッタ</dfn>は、オブジェクトのプロパティを参照したり変更しようとするときに、関数を呼ぶというものです。このとき呼ばれる関数が、ゲッタやセッタです。参照されたときに呼ばれるのがゲッタで、値を変更するときに呼ばれるのがセッタです。</p>
<p>したがって、ゲッタやセッタは<strong>関数</strong>です。それでは、ゲッタやセッタをどう作るのか解説します。</p>

<h4>作り方</h4>
<p>作り方の1つは、<strong>オブジェクトリテラル</strong>（すなわちオブジェクトを作るとき）に特殊な記法によってゲッタやセッタを作る方法です。以前、
<code> { プロパティ:値, プロパティ:値 }</code>
という形でオブジェクトを作ることを解説しました。ここに、<code>プロパティ:値</code>ではない特殊な形を入れます。</p>
<p>次のサンプルを見てみましょう。</p>
<pre><code>
var a = {
  <strong>get</strong> <mark>aaa</mark>(){ return 3; },
  <strong>set</strong> <mark>aaa</mark>(){}
};
console.log(a.<mark>aaa</mark>);
a.<mark>aaa</mark>=5;
console.log(a.<mark>aaa</mark>);
</code></pre>
<p>2回とも3と表示されるはずです。</p>
<p>オブジェクトaをつくるとき、<code>プロパティ:値</code>のかわりに、getとsetの形で書かれています。この形は、
<code><mark>function</mark> 関数名(){ 〜 }</code>
のfunctionがget,setに変わった形と見ることができるかもしれません。ただし、書く場所は前述のようにオブジェクトリテラルの中です。</p>
<p>まず<code>a.aaa</code>が参照されています。ここでオブジェクトaはaaaというゲッタを持っているので、ゲッタ（get aaaの関数）が呼ばれるのです。</p>
<p>そして、ゲッタの戻り値がそのまま<code>a.aaa</code>の値として扱われます。今回ゲッタは無条件で3を返すので、a.aaaは3ということになり、3が表示されました。</p>
<p>次では、aaaに5を代入しようとしています。このとき呼ばれるのがセッタ（set aaa）です。</p>
<p>今回セッタの中身は空っぽです。つまり、何も処理をしないということです。ちなみに、今回は使ってませんが、代入されようとしている値は<strong>第一引数</strong>に入っているので、それを利用できます。</p>
<p>さて、セッタが何もしなかったので、<code>a.aaa=5;</code>の行では何も起こらなかったということになります。</p>
<p>次にまた<code>a.aaa</code>を表示していますが、ゲッタは相変わらず3を返すので3が表示されます。</p>
<p>結局、今回ゲッタとセッタによってできたプロパティaaaは常に3が入っているような振る舞いをすることになります。</p>

<h3>ゲッタ・セッタの利用</h3>
<p>さて、さっきのサンプルはあまり実用的ではありませんでした。これらを、クロージャのときのようにアクセスの制限のために使うのにはどうすればよいのでしょう。</p>
<p>例えば、ゲッタとセッタでaというプロパティを作りたいとします。そうすると、実際のaの値を別のところに保存しておけばいいのです。</p>
<pre><code>
var obj = {
  <mark>_a</mark> : 0,
  get <mark>a</mark>(){return this.<mark>_a</mark>; },
  set <mark>a</mark>(n){this._a = n; }
};

obj.a=3;
console.log(obj.a);
</code></pre>
<p>この例では、プロパティaが参照されるときには_aの値がそのまま返され、代入するときには_aにそのまま代入されます。つまり、_aがそのままaとしての役割を果たしており、ゲッタとセッタが仲介しています。このようにして内容を保存することができます。では、これに手を加えてみましょう。</p>
<pre><code>
var obj = {
  <mark>_a</mark> : 0,
  get <mark>a</mark>(){return this.<mark>_a</mark>; },
  set <mark>a</mark>(n){this._a = n<mark class="ins">*2</mark>; }
};

obj.a=3;
console.log(obj.a);
</code></pre>
<p>こんどは、_aに代入するときに2倍してみました。すると、3を代入したのに6が入っているという変なプロパティになりました。</p>
<p>もう少し実用的な例としては、真偽値以外代入できないというのを作ってみましょう。真偽値とは、trueまたはfalseのことですね。</p>
<p>つまり、値がtrueまたはfalseかどうか判定して、その場合のみ代入すればいいのです。</p>
<pre><code>
var obj = {
  <mark>_a</mark> : false,
  get <mark>a</mark>(){return this.<mark>_a</mark>; },
  set <mark>a</mark>(n){
    if(n==false || n==true){
      this.<mark>_a</mark> = n;
    }
  }
};

obj.a=true;
console.log(obj.a);
obj.a="あいうえお";
console.log(obj.a);
</code></pre>
<p>この場合、最初に<code>obj.a=true;</code>ではtrueが_aに代入され、console.logではtrueが表示されます。</p>
<p>次に"あいうえお"を代入しようとしますが、これはtrueまたはfalseではないので_aに代入されません。したがって、_aは変わらずtrueのままとなります。</p>
<p><small>（注： 真偽値かどうかの判定には<a href="11_5.html#anchor-typeof">typeof演算子</a>を使うか<a href="9_7.html#anchor-strict-equal">===演算子</a>を使うかしたほうがよいでしょう。詳しくは今度紹介しますが、実は<code>0 == false</code>なのでこの例では<code>obj.a</code>に0を入れることができます。）</small></p>

<p>これまでの例で見たように、ゲッタとセッタは応用次第でいろいろ使い道があります。前回のクロージャのパターンではいちいち関数を使わないといけませんでしたが、これなら普通のプロパティと同じ感覚で扱えます。ただ、プロパティを扱うたびに関数が処理されるので、普通のプロパティより処理が重いと思われます。</p>

<h3>既存のオブジェクトに設定する方法</h3>
<p>さて、ゲッタとセッタにはもうひとつ設定方法があります。いままでの方法は、新しくオブジェクトを作っていましたが、すでにあるオブジェクトにこれらを追加したいときはどうするのでしょう。実は、そのためのメソッドが<em>ありました</em>。</p>
<pre><code>
var obj = { _a : false };
obj.<dfn>__defineGetter__</dfn>("<mark>a</mark>", function(){ return this.<mark>_a</mark>; });
obj.<dfn>__defineSetter__</dfn>("<mark>a</mark>", function(n){
  if(n==true || n==false){
    this.<mark>_a</mark> = n;
  }
});

obj.a=true;
console.log(obj.a);
obj.a="あいうえお";
console.log(obj.a);
</code></pre>
<p>__defineGetter__と__defineSetter__が、それぞれゲッタとセッタを設定するメソッドです。第一引数がプロパティ名で、第二引数が関数となっています。このサンプルは、さっきのをこれらを使って書き換えたもので、同じ動作をします。</p>
<p>ところで、「ありました」と過去形なのは、今ではこれは使われないからです。代わりに、のちのち紹介する<a href="11_4.html">defineProperty</a>が今では使われます。ここで紹介した__defineGetter__と__defineSetter__は昔はこれが使われていたという程度に覚えておきましょう。</p>
<p>というか、そもそもメソッド名が怪しいですね。アンダースコアで囲まれています。これは、このメソッドがそもそも非標準だったことが理由です。</p>

<h3>ゲッタ・セッタの応用</h3>
<p>ゲッタ・セッタは応用がききます。実は、九章で解説してきたprototypeと組み合わせることができます。すなわち、あるオブジェクトのprototypeにセッタ・ゲッタを設定すると、そのインスタンス全てで使うことができるのです。</p>

<p>ところで、次の問題が分かりますか。</p>
<pre><code>
//問題：最終的にobj._aの値は何になるか
var obj = {
  _a : 0,
  get a(){
    this._a++;
    return this._a;
  },
  set a(n){
    this._a=n;
  }
};

obj.a=3;
obj.a+=2;
obj.a;

console.log(obj._a);  // ?
</code></pre>
<p>今回のポイントは、objはゲッタで_aの値が変動するふざけたオブジェクトであるということです。</p>
<p>まず、<code>obj.a=3;</code>の行で、_aは3になります。次の行が問題です。</p>
<pre><code>obj.a+=2;</code></pre>
<p>これは、obj.aに2を足すということです。これを詳しく見ると、「obj.aを参照して、2を足した値を代入する」ということです。この過程で、一度obj.aが参照されます。ここでゲッタが呼ばれるのです。</p>
<p>ゲッタでは、_aが1たされて4になります。それを返すので、参照した結果は4です。2を足すので6になり、それがセッタで_aに代入されます。</p>
<p>最後に<code>obj.a;</code>ですが、書いてあると、とりあえず参照されます。そこでゲッタが呼ばれ、_aは1増えて7となります。</p>
<p>したがって、答えは7です。</p>
<p>ところで、書いてあると参照されると述べましたが、最初の<code>obj.a=3;</code>やその次では参照されないのでしょうか。実は、この場合はまず真ん中にある<strong>代入演算子</strong>がされるので、この時点では処理されません。</p>
<p>代入演算子の働きは左に右を代入することですが、これはやや特殊であり、特に左（ここではobj.a）を参照はしません。</p>
<p>そして、代入演算子は右の値を<em>返し</em>ます。したがって、この文は</p>
<pre><code><mark class="ins">3</mark>;</code></pre>
<p>となります。ここで終了します。次の行も同じ感じです。</p>
<p>一方、<code>obj.a;</code>は、文を処理し始めると、いきなりobj.aが出てきます。ここで、処理の対象はobj.aそのものとなるので、参照されるのです。</p>
<p>だから、例えば</p>
<pre><code>b = obj.a;</code></pre>
<p>というように右側にある場合は、まず代入演算子が処理されますが、左に右を代入する過程で、右の値が処理の対象となり、即ち参照されます。ここでゲッタが呼ばれます。</p>
<p>この後代入演算子が値を返し、</p>
<pre><code><mark class="ins">obj.a</mark>;</code></pre>
<p>の形になりもう一度呼ばれると思えるかもしれませんが、そういうことはありません。<code>b = obj.a;</code>を処理するときにまずobj.aを参照して<code>b = <mark class="ins">(値)</mark>;</code>のように具体的な値になってしまうからです。</p>

<h3>クロージャの利用</h3>
<p>ところで、さっきから実際の値を保存しておくプロパティとして<code>_a</code>を使ってきました。しかしこれでは、<code>_a</code>を直接参照されてしまうと意図しない動作をすることになります。これを回避するために、前回解説したクロージャを使うことができます。</p>
<pre><code>
var obj=(function(){
  var _a=false;
  return {
    get a(){return _a;},
    set a(n){
      if(n==true || n==false){
        _a=n;
      }
    }
  };
})();
</code></pre>
<p>無名関数によって新しいスコープを作り、その中で作ったオブジェクトをreturnで外に出して変数objに代入しています。</p>
<p>今回、プロパティaの実体として使われているのは無名関数内のローカル変数<code>_a</code>です。返り値として新しく作られたオブジェクトのゲッタやセッタも、クロージャとして無名関数の中の環境を利用可能です。これならは、ゲッタとセッタを介す以外に<code>_a</code>にアクセスする方法がないので安全になりました。</p>

