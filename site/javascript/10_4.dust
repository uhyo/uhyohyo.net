<p>今回は述語(<i lang="en">Predicates</i>)について解説します。</p>

<h3>述語とは</h3>
<p>今まで、ロケーションステップは<code>child::p</code>のように述語とノードテストによって記述してきました。軸で方向を絞り込み、ノードテストでノードの種類（や要素名）を絞り込んできたのです。</p>
<p>といっても、ノードテストによる絞り込みでは不十分で、もっと細かい条件を指定したい場合もあることでしょう。そういったときに使うのが<dfn>述語</dfn>です。</p>
<p>述語の書き方は、<code>/html/body/child::p<mark>[1]</mark></code>のように<code>[ ]</code>で囲んだ式をくっつけます。</p>

<h3>述語が数値の場合</h3>
<p>この場合、式といってもただの数値です。</p>
<p>述語が数値の場合、絞りこまれて候補に上がったノードのうち、その番号番目のもの1つに絞られます。この順番は文書順です。</p>
<p>つまり、今回の場合は「1番目」ということになります。配列などと違い、<strong>1番目が一番最初</strong>なので注意しましょう。</p>
<p>つまり、この式は、body要素の子のp要素のうち一番最初のp要素の1つだけからなるノードセットを表すというわけです。</p>

<p>また、次のような書き方もあります。</p>
<pre><code>/html/body/p[<mark>last()</mark>]</code></pre>
<p>ここで関数が出てきました。この関数<dfn>last</dfn>は、ノードセットの<strong>一番最後の番号</strong>を返すというものです。つまり、これはbodyの子のうち一番最後のp要素を表しているということです。</p>
<p>他にも、<code>/html/body/p[last() <mark>-</mark> 1]</code>のように、演算子<code>-</code>を使って、「一番後ろの1つ前」を表したりもできます。</p>

<h3>述語が真偽値の場合</h3>
<p>述語は<strong>真偽値</strong>の場合もあります。この場合、絞りこまれて候補に上がったノードそれぞれに対して述語が評価され、<strong>述語がtrueになるもの</strong>だけに絞りこまれます。</p>
<p>例えば、<code>/html/body/p[position() &lt;= 2]</code>とすると、body要素の子のp要素のうち、<code>position() &lt;= 2</code>を満たすノードのみが返ります。ここで、<dfn>position</dfn>関数は、そのノードの番号を返します。つまり、このXPath文はbody要素の子のp要素のうち<code>position()</code>が2以下、すなわち1番目と2番目のノードのみを返します。</p>

<p>よくよく考えてみると、さっきの数値の場合も、<code>/html/body/p[1]</code>は<code>/html/body/p[<mark>position()=</mark>1]</code>の省略形になっていることが分かります。</p>
<p>ここで、XPathでは、<code>==</code>ではなく<code>=</code>で等しいかどうか比較できることに注意しましょう。<code>!=</code>はXPathでも同じです。</p>

<h3>属性による絞り込み</h3>
<p>前回と今回説明したことを組み合わせると、属性による絞り込みをすることができます。例として、lang属性が<code>"ja"</code>であるp要素のみを集めるには、次のようにします。</p>
<pre><code>/html/body/descendant::p[<mark>attribute::lang</mark>="ja"]</code></pre>
<p>これはつまり、<code>attribute::lang="ja"</code>に当てはまるp要素のみに絞り込むということです。明らかに、<code>attribute::lang</code>の部分は1つのロケーションステップから成る式です。「現在のノード」のlang属性を示すノードのノードセットを返します。</p>
<p>では、この場合の「現在のノード」とは何でしょうか。実は、述語の中の式を評価する場合、絞り込みの対象となっている各ノードが「現在のノード」となります。</p>
<p>つまり、<code>/html/body/descendant::p[<mark>attribute::lang</mark>="ja"]</code>の動作はこうです。まず<code>/html/body/descendant::p</code>までの部分でp要素が列挙されます。そのそれぞれのp要素に対して<code>attribute::lang</code>を求め、それが<code>"ja"</code>であるp要素のみ残します。結果として、p要素のうちlang属性が<code>"ja"</code>であるもののみ残ることになります。</p>
<p>なお、ここで<code>=</code>がノードセットと文字列の比較を行っており、暗黙のうちにノードセットが文字列に変換されています。</p>
<p>ただし、ノードセットと文字列の比較は特殊です。というのも、ノードセットに入っているノードは複数かもしれません。このような状況でノードセットと文字列を比較した場合、ノードセット中の各ノードが文字列に変換され、<em>ひとつでも等しいものがあればtrue</em>となります。</p>
<p>今回の場合1つずつのp要素についてlang属性を処理しているので、ノードセットはノードが1つだけです。だから、結局lang属性が"ja"かどうか判定しているということです。</p>
<p>これを用いると、例えば<code>attribute::node() = "ja"</code>のような条件を書いた場合、「存在する属性のうちどれか1つでも<code>"ja"</code>ならtrue」のような使いどころのよくわからない条件になります。</p>

<p>余談ですが、属性ノードを文字列に変換すると属性の値になる一方、要素ノードなど木構造中に存在するノードを文字列に変換するときには、その子孫のテキストノードを全て連結した値になります。例えば、<code>&lt;p&gt;abc&lt;span&gt;def&lt;/span&gt;ghi&lt;/p&gt;</code>というp要素を文字列に変換した場合、<code>"abcdefghi"</code>となります。</p>

<h4>属性による絞り込みの応用</h4>
<p>ノードセットと文字列の比較を応用すると、「その要素に限らず祖先のノードのどれかのlang属性が<code>"ja"</code>であればOK」というような判定もできます。</p>
<pre><code>/html/body/descendant::p[ancestor-or-self::*/@lang = "ja"]</code></pre>
<p>述語の中でancestor-or-self軸が使われています。この軸は、自身とその親以上全てでした。ノードテストは<code>*</code>（全ての要素ノード）なので、p要素とその親全てのノードセットということになります。そして、次の<code>@lang</code>はlang属性を取得します。つまり、ノードセットのノードそれぞれに対してlang属性が取得され、それらのノードセットができあがるということです。</p>
<p>そして、できあがった属性のノードセットと"ja"を比較しているので、lang属性の中に一つでも<code>"ja"</code>があればtrueになります。</p>

<p>ところで、今まで見てきた通り、ノードセットと文字列を=で比較すると、1つでも等しいものがあればtrueになります。これを、「全て等しければtrue、他はfalse」とするにはどうすればよいでしょう。</p>
<p>それは、次のようにします。</p>
<pre><code><mark>not</mark>(ノードセット != "文字列")</code></pre>
<p>notは、JavaScriptでいうところの<code>!</code>のような関数で、trueならfalse、falseならtrueを返します。一方、<code>!=</code>は、<code>=</code>と同じで「一つでも違えばtrue」です。つまり、全て同じならfalseになるので、これをnotで反転してtrueにすればよいのです。</p>

<p>最後に、述語は次のように複数指定して、条件を複数もたせることができます。</p>
<pre><code>/html/body/p[@lang="ja"][last()]</code></pre>
<p>まず、ノードテストでbodyの子のpに絞りこまれ、次の述語でlang属性が"ja"のものに絞りこまれ、その次の述語で、<strong>絞りこまれたp要素のうち</strong>最後のp要素になります。</p>

<p>以上でXPathの解説は終わりですが、ここでは解説していない関数などもあります。興味がある方は詳しく調べてみてもよいでしょう。</p>

