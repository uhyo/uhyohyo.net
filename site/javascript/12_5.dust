<p>次に、Web近代史(?)中で重要な役割を果たす<dfn>File API</dfn>について紹介します。</p>
<p>これはその名の通り<strong>JavaScriptからファイルを扱うためのもの</strong>です。今回は特に、<strong>ローカルのファイル</strong>、すなわちページを開いた利用者のパソコン（など）の中のファイルを扱う方法について紹介します。</p>
<p>ただし、自由にファイルを見られてはセキュリティも何もあったものではないので、<em>ユーザーが認めたファイルのみ</em>見ることができるという安全仕様です。</p>
<p>具体的には、JavaScriptでどのファイルを読み込めるのかを<strong>ユーザーに選択してもらう</strong>必要があります。実は、HTMLにはこういうのがありましたね。</p>
<pre><code>
&lt;input type="<mark>file</mark>"&gt;
</code></pre>
<p>これはinput要素で、アップロードするファイルを選択できるコントロールです。実は、このコントロールによって選択されたファイルはJavaScriptから読み込むことができます。</p>

<h3>ファイルの取得</h3>
<p><a href="12_2.html">十二章第二回</a>で紹介したとおりHTML5になってフォーム周りは大きく機能が強化されましたが、実はこのファイル選択においてもそうだったのです。</p>
<p>input要素から選択済みファイルを取得するには、このinput要素の<dfn>files</dfn>プロパティを調べます。このfilesプロパティに入っているのが、<dfn>FileListオブジェクト</dfn>です。</p>
<p>名前の通り<strong>リスト</strong>ですから、もしかしたら複数ファイルが選択されている可能性があるかもしれないのですね。</p>
<p>そして、このFileListオブジェクトは、もはやNodeList（getElementsByTagNameなどで出現）などなどでお馴染みの<dfn>lengthプロパティ</dfn>と<dfn>itemメソッド</dfn>を持っています。ピンと来ると思いますが、lengthがファイルの総数で、itemメソッドは数値を指定するとn番目のファイルを返してくれるというわけです。</p>
<p>ちなみに、
<code>filelist.<mark>item</mark>(0)</code>
の代わりに、
<code>filelist<mark>[0]</mark></code>
という省略が可能なのも同じです。</p>

<p id="anchor-file">さて、このようにして得たファイルの一つ一つを表すオブジェクトを<dfn>Fileオブジェクト</dfn>といいます。</p>
<p>このFileオブジェクトというのは<dfn>Blobオブジェクト</dfn>の一種で（つまり、FileはBlobを<a href="9_3.html">継承</a>しています）、ではBlobとは何かというとバイナリデータを表すオブジェクト、要するにファイルの中身そのものを表すオブジェクトです。</p>
<p>そして、ではFileオブジェクトはBlobオブジェクトと何が違うかというと、Blobオブジェクトの機能（これはあとで紹介します）に加えて<dfn>nameプロパティ</dfn>と<dfn>lastModifiedDateプロパティ</dfn>を持っています。これは読んで字のごとく、前者は<strong>ファイル名</strong>で後者は<strong>最終更新日</strong>です。</p>
<p>ファイル名は当然文字列で、あとの最終更新日というのは<strong>Dateオブジェクト</strong>で返ってきます。</p>
<p>それでは一旦、ここまでをサンプルで振り返ります。<a href="12_5_sample.html">サンプル</a></p>
<p>ソースを見てみると、さっそくファイル選択のinput要素があって、</p>
<pre><code>
onchange="change(event)"
</code></pre>
<p>とあります。onchangeということは変更されたときということですから、今回の場合はファイルが選択されたときですね。</p>
<p>そして問題のchange関数では、<code>ev.target.files</code>を取得しています。この例では<code>ev.target</code>が問題のinput要素ですね。</p>
<p>そして今回は最初のファイルに決め打ちして、<code>console.log</code>その名前を表示しているのです。</p>
<p id="anchor-mime-type">ちなみに、他にBlobのプロパティとして、<dfn>size</dfn>（そのファイルのバイト数）と<dfn>type</dfn>（データの<b>MIMEタイプ</b>）があります。MIMEタイプはデータを扱うときに随所に現れる概念で、どんなデータかを表すものです。例えばHTMLファイルならば<code>"text/html"</code>というMIMEタイプになります。これはHTMLを表す文字列という意味です。PNGフォーマットの画像ファイルならば<code>"image/png"</code>となります。</p>

<h3>ファイルの中身を取得する</h3>
<p>上のサンプルではファイルの名前を取得しましたが、やはり我々が一番関心があるのはファイルの中身でしょう。そこで、次にファイル（あるいはBlob）の中身を取得する方法を紹介します。</p>
<p>そこで登場するのが<dfn>FileReader</dfn>オブジェクトです。このオブジェクトがBlobの読み込みを担当します。</p>
<p>これの特徴は<strong>非同期読み込み</strong>であるということです。JavaScriptで非同期といった場合、意味するところは<strong>コールバックで結果を得る</strong>ということです。<small>（注：ご存知の読者のために補足しておくと、async/awaitはまだしばらく出てきません。）</small></p>
<p>例えば、読み込むためにはいくつは方法がありますが、まずは<dfn>readAsText</dfn>メソッドを紹介します。これはファイルの中身を<b>文字列</b>として取得することができます。テキストファイルを読み込むときに便利ですね。</p>
<p>ちなみに非同期の反対として<strong>同期</strong>というのもあります。同期ということは、その関数が全部処理をおこなってしまって、プログラム側は関数の処理が終わるまで待つということです。このようにプログラムが待たされることを<strong>ブロックする</strong>といいます。ブロックする関数の典型的な例はalert（ユーザーがOKなどを押すまでプログラムは次に進まない）です。</p>
<p>ところが、今の時代同期的な処理は人気がありません。待ってる間はJavaScriptによる処理が一切行えないからです。非同期というのは、さっきも出てきた<strong>コールバック</strong>によって結果を出るのですが、要するにこれは「終わったら呼んでね」ということです。今回の場合、readAsTextを「終わったら呼んでね！」と言って呼び出して、自分はその後も悠々と他の処理を続けているわけです。それで、結果が出たら呼ばれます。</p>
<p>呼ばれるというのは、要するに<strong>関数</strong>です。「終わったらこの関数を呼んでね」ということです。</p>
<p>ところで、今までこのコールバックに似ているものを皆さんは何度も見ているとも言えます。それは<em>イベント</em>です。イベントは、発生したときにあらかじめ登録されていた関数（イベントハンドラ）が呼ばれるというものでした。コールバックとイベントの主な違いは、コールバックは基本的には1回だけ呼ばれるのに対し、イベントは何回でも発生する可能性が<small>（少なくとも今まで見てきたようなイベントに関しては）</small>あるという点です。逆に言えば、1回だけ発生するイベントがコールバックであるという見方もできます。</p>
<p>さて、そんなことを考えつつ、いよいよFileReaderを見て行きましょう。</p>

<p>これを使うには、まずFileReaderのインスタンスを作ります。</p>
<pre><code>
var reader=new <mark>FileReader</mark>();
</code></pre>
<p>次に、<strong>コールバック関数</strong>を設定してあげます。コールバックしてくれるタイミングというのもいくつかあるのですが（後述）、その中でも今回は<strong>読み込み完了</strong>のタイミングで関数を呼び出してもらうようにします。そのためには、<dfn>onload</dfn>というプロパティに関数を代入します。</p>
<pre><code>
var reader=new FileReader();
reader.<mark>onload</mark> = function(e){
console.log("読み込みが終わりました");
};
</code></pre>
<p>そして、これで準備ができたのでいよいよreadAsTextを呼び出します。readAsTextは、第一引数にBlob（今回はFileなのでさっき読み込んだFile）を渡します。</p>
<pre><code>
var reader=new FileReader();
reader.<mark>onload</mark> = function(e){
  console.log("読み込みが終わりました");
};
<mark class="ins">reader.<mark>readAsText</mark>(file);</mark>
</code></pre>
<p>ちなみに、readAsTextを呼び出す前にonloadプロパティに関数を代入しましたが、この順番は逆でも構いません。人によっては、「readAsTextが一瞬で読み込み終わったらonloadプロパティを設定する前に呼ばれてしまうかもしれない」と思うかもしれませんが、その心配をする必要はありません。詳しくは解説しませんが、これは非同期的にコールバックが呼び出される場合、必ず今まさに実行中の一連のプログラムが最後まで実行されてから呼びだされるからです。</p>

<p>さて、今回のプロパティ<code>onload</code>ですが、これはどう見てもイベント<code>load</code>のイベントハンドラに見えます。上で「コールバックは1回だけ呼ばれるイベントである」というようなことを述べましたが、今回はまさにそうなっています。DOMの関連で非同期的な処理が行われる場合、このようにイベントの形でコールバックが設定できるようになっていることがよくあります。実は、おなじみのaddEventListenerメソッドを使ってイベントを登録する方法もあります。</p>
<p>ということは、コールバック関数の第1引数eは<strong>イベントオブジェクト</strong>です。この場合の<code>e.target</code>はFileReaderオブジェクト（上の例だと<code>reader</code>）が入っています。<code>e.target</code>は複数のFileReaderで同じコールバック関数を使いまわしたいときなどに利用できるかもしれません。</p>

<p>さて、読み込みが終わった時点で、読み込み結果はどこに入っているのかというと、FileReaderオブジェクトの<dfn>resultプロパティ</dfn>に入っています。つまり、今回の場合<code>reader.result</code>です（もちろん、<code>e.target.result</code>でも同じです）。</p>
<p>ということで、ここまでのを試す<a href="12_5_sample2.html">サンプル2</a>を見ましょう。</p>
<p>テキストファイルを選択するとコンソールに中身が表示されるのを確認できたと思います。</p>
<p>ところで、テキストというと<strong>文字コード</strong>の問題がつきまといます。そのファイルをどんな文字コードで読み込むかは<strong>第2引数</strong>で文字列で指定します。第2引数がない場合は<strong>UTF-8</strong>になります。他に<code>"UTF-16"</code>とか、<code>"Shift_JIS"</code>などなどが使えます。</p>

<h3 id="anchor-arraybuffer">バイナリファイルの読み込み</h3>
<p>読み込みたいファイルがテキストでない場合はreadAsTextではなく別のメソッドを使うのがよいでしょう。</p>
<p>そこで次に紹介するのが、<dfn>readAsArrayBuffer</dfn>です。これは、そのBlobを<dfn>ArrayBuffer</dfn>として読み込むということです。もちろん読み込んだ結果はreadAsTextと同じように、resultプロパティに入っています。</p>
<p>このArrayBufferというのは要するに「バイナリデータが入っているオブジェクト」ということなのですが、それだけだとBlobとあまり変わりません。ArrayBufferの特徴は、実際にメモリ上に連続する領域が確保されているということです。ファイルをBlobとして得られた段階では実はBlobオブジェクトが作られただけで、まだそのファイルをメモリ上に読み込んでいないかもしれません。それを実際にメモリ上に（文字列やArrayBufferの形で）読み込むのがFileReaderなのだということですね。</p>
<p>このArrayBufferというのは先々また出てくるわりと汎用的なオブジェクトなのでここで慣れ親しんでおきましょう。実は、ArrayBufferはバイナリデータなのですが、実はその中身を読むには<em>さらに別のオブジェクトが必要</em>なのです。面倒ですね。</p>
</p>
<p>それが<dfn>型つき配列</dfn>（<i lang="en">TypedArray</i>）であり、このオブジェクトによってArrayBufferの中身をどのように（1バイトずつとか、4バイトずつとか）読むかが定まります。配列ということは、バイナリデータは配列（というより、データが並んだもの）として扱われるということです。</p>

<p>型つき配列にはいくつか種類があるのですが、まずはよく使いそうな<dfn>Uint8Array</dfn>から紹介しましょう。Uint8とは、「8ビットで符号なし整数」ということです。C言語でいうunsigned charとかRustでいうu8にあたるものですね。</p>
<p>8ビットということはすなわち1バイトですから、Uint8Arrayを用いる場合はデータを1バイトずつに区切って並べた配列として扱われることになります。バイナリデータはバイト単位で区切って表示されることが多いように思いますから、これが最も自然なのではないでしょうか。</p>
<p>型付配列の他の種類も紹介しておきます。Uがない<dfn>Int8Array</dfn>は符号あり8ビット整数、すなわち1バイトが-128〜127の範囲の整数として表された配列になります。ほかに、Uあり・なしそれぞれに16と32があります。例えばUint32Arrayはデータ4バイト（32ビット）ごとに配列の1要素となり、それらは32ビット符号なし整数です。他に浮動小数点数を扱えるFloat32ArrayとFloat64Arrayというのがあります。なお、このような型付き配列は総称して<dfn>TypedArray</dfn>と言います。昔はArrayBufferViewという名前でしたがTypedArrayがECMA標準に組み入れられたあたりで過去のものとなりました。</p>

<p>それではUint8Arrayを例にして使い方を見ていきます。他のも使い方は同じです。</p>
<pre><code>
var arr=new <mark>Uint8Array</mark>(buffer);
</code></pre>
<p>型付き配列はこのようにnew演算子で作ることができます。第1引数にデータを持つArrayBufferを渡します。</p>
<p>さきにひとつ注意を述べておきます。それは、一つのArrayBufferに対して複数のTypedArrayを作った場合、一方を操作するともう一方にも反映されるということです。これは、Uint8Arrayをはじめとする型付き配列はArrayBufferが確保しているメモリを操作するインターフェースであり、インターフェースを複数作ったところで結局操作されるのは同じArrayBufferだからです。</p>
<p>つまり我々はUint8Arrayを通じてもとのArrayBufferを操作しているのです。</p>

<p>それでは型付き配列の機能を見ていきましょう。まずは<dfn>lengthプロパティ</dfn>で配列の長さを取得できます。Uint8Arrayならば、1要素1バイトなのでArrayBufferのデータのバイト数（実はこれはArrayBufferのプロパティ<dfn>byteLength</dfn>で取得できます）と一致しますが、16とか32になるとまた異なってくるでしょう。</p>
<p>また、配列という名に恥じず、<code>arr[0]</code>で0番目の要素を取得したり書き換えたりできます。</p>
<p>かなり端折った説明でしたが、ここまで分かれば読み込んだファイルのバイト列を取得することができるはずです。</p>
<p>ということで<a href="12_5_sample3.html">サンプル3</a>を見ましょう。このサンプルは読み込んだファイルの最初の10バイトを表示しています。</p>
<p>結構長々と解説しましたが、実際のソースコードは結構単純です。とにかくこれで、バイナリファイルの読み込みも可能になりました。</p>
<p>型付き配列についてはもう少し紹介することがありますが、それは後回しにしてFireReaderの説明に戻ります。</p>

<h3>readAsDataURL</h3>
<p>実は、読み込み用メソッドはテキストとバイナリの2つだけかと思いきやまだ種類があります。それは<dfn>readAsDataURL</dfn>です。</p>
<p>この<strong>DataURL</strong>というのは、http://などから始まるのではなく、<strong>data:から始まる特殊なURL</strong>のことです。一般に、URLというのはインターネット上にあるデータを指し示すもので、アクセスすることでデータを取得できるものです。DataURLというのは、データがURL内に全部書いてあり、インターネットアクセスをする代わりにURL内のデータを読むことで結果を得られるものです。</p>
<p>DataURLの例は次のようなものです。</p>
<pre><code>data:text/html,%3c%21doctype%20html%3e%3chtml%3e%3cbody%3e%3ch1%3etest%3c/h1%3e%3c/body%3e%3c/html%3e</code></pre>
<p>これをブラウザのアドレスバーに入力してみましょう。「test」と書いたページが開かれるはずです。そのページのソースを表示すると次のように出るはずです。</p>
<pre class="language-html"><code>
&lt;!doctype html&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt;test&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;
</code></pre>
<p>つまり、「data:text/html,%3c...（略）」というURLを開いたということは、 この「&lt;!doctype...（略）」という内容のページを読み込んだのと同じ事だということです。</p>
<p>このように、ブラウザが読み込んだとき、あたかもどこかからその内容を取ってきたかのように振る舞うのがdataURLです。</p>
<p>さて、readAsDataURLでは、ファイルの内容をこのdataURLに変換させて読み込むことができるというのです。</p>
<p>これの意味するところはつまり、そのURLをブラウザが読むと該当ファイルの内容が読みこまれるということです。</p>
<p>ということで、これをやってみたのが<a href="12_5_sample4.html">サンプル4</a>です。</p>
<p>画像を読み込ませてやるとその内容が表示されたと思います。できたimg要素のsrc属性を調べると、長いDataURLになっていることがわかります。</p>
<p>このように、dataURLというのはユーザーが選択したものをブラウザに読み込ませたいときに使える場合があります。</p>
<p>なお、DataURLはbase64でシリアライズしたバイナリデータに所定のヘッダーを付けただけなので、手動で作ろうと思えば作ることはできます。実際、これはFileReaderに特有の概念ではなく、色々な場面で使われています。例えばimg要素を用いて小さい画像を表示したいとき、src属性に（通常の）URLを記述する代わりに画像をDataURL化したものを記述することができます。これによりインターネットアクセスを行わずとも画像を表示することができます。</p>

<h3>URL.createObjectURL</h3>
<p>さて、しかし今回のように実際にはユーザーが選択したファイルを表示したい場合にreadAsDataURLを使うことは少ないでしょう。データが全部URL文字列に含まれるということは、データが大きいほどURLも長くなるということです。これは扱いにくいので、もっと便利な方法が用意されています。それが<dfn>URL.createObjectURL</dfn>です。これはURLというオブジェクトが存在して、それが持つcreateObjectURLメソッドであることは今更言うまでもありませんね。</p>
<p>このメソッドにBlobを引数として渡すと、オブジェクトURLと言われる特殊なURLが生成されます。これはDataURLとはまた異なる種類のURLです。このURLはブラウザが発行したURLであり、そのページが閉じられるまで有効です。このURLは、その内容（Blob）をブラウザが覚えておき、それを指し示すものです。DataURLとは異なり、データの本体はURLに書いてあるわけではなくブラウザの内部に保管されています。ということは、当然他の人に渡してもデータが渡せるわけではありません（URLだけ渡してもデータ本体を渡していませんね）。</p>
<p>readAsDataURLで得られたdataURLの代わりに、このcreateObjectURLで得られたオブジェクトURLをimg要素などに渡すことができます。そのように上のサンプル4を改造したのが<a href="12_5_sample5.html">サンプル5</a>です。</p>
<p>この例ではURL.createObjectURLによって作られたURLをコンソールによって表示されます。結果はブラウザや場合によって異なるでしょうが、Google Chrome 61での結果は次のような感じです。</p>
<pre><code>
blob:http://uhyohyo.net/684ace23-5998-446a-9100-ae79bba25015
</code></pre>
<p>blob:で始まっており、何やらIDのようなものが含まれていますが、実際の画像データは含まれていません。このIDがどのBlobに対応するのかブラウザが覚えていることで、URLを読むと対応するデータを読み込むことができるのです。実際、（サンプル5を開いたままで）表示したURLをブラウザで開いてみましょう。該当の画像が表示されるはずです。</p>
<p>データをURLの形で表したいときは、DataURLを使うよりもURL.createObjectURLを使ったほうがよい場合が多いです。DataURLは先に説明した通り、データが全て文字列として表現されます。ということは必然的にデータがメモリに全部展開される必要があります。これは、例えばvideo要素で数十GBもある動画データを再生したい場合は現実的ではありません。</p>
<p>このような場合にURL.createObjectURLを使うと、数十GBある動画データを表すURLができますが、だからといってそれが全部メモリに読みこまれるわけではありません。それをvideo要素で再生しようとすると、ブラウザは必要に応じて動画をハードディスク（やSSD）から読み込むような動作をするはずです。</p>

<p>ちなみに、createObjectURLで得られたURLは、使い終わったら<dfn>URL.revokeObjectURL</dfn>メソッドを呼び出して（第1引数にオブジェクトURL）やると親切です。これは、そのURLはもう使い終わったとブラウザに宣言することで、ブラウザの記録から消去してやるメソッドです。これによりメモリの節約などの効果が期待できるかもしれません。</p>

<h3>FileReaderのその他の機能</h3>
<p>今回はFileReaderのイベントとして読み込み完了を示すloadイベントを紹介しましたが、実はほかにもイベントがあるので一気に紹介します。</p>
<dl>
  <dt>loadstart</dt>
  <dd>ファイルの読み込みを開始したとき。</dd>
  <dt>progress</dt>
  <dd>ファイルの読み込みが進行したとき。（何度も発生する可能性があります）</dd>
  <dt>abort</dt>
  <dd>ファイルの読み込みが中断したとき（後述）。</dd>
  <dt>error</dt>
  <dd>ファイルの読み込みに失敗したとき。</dd>
  <dt>load</dt>
  <dd>ファイルの読み込みが正常に最後まで完了したとき。</dd>
  <dt>loadend</dt>
  <dd>ファイルの読み込みが終了したとき（失敗した場合も含む）。</dd>
</dl>
<p>loadイベントのほかによく使いそうなのはerrorですね。また、読み込むのに時間かかるようなファイルの場合はprogressイベントを使う機会があるかもしれません。</p>
<p>abortイベントに関してですが、読み込みの中断はFileReaderの<dfn>abortメソッド</dfn>（引数なし）を呼ぶことで発生します。</p>

<h3>型付き配列について</h3>
<p>上で紹介した型付き配列（TypedArray）についてもう少し解説しておきます。</p>
<p>先に述べたようにデータの実体はArrayBufferであり、型付き配列はそれを読み書きするためのインターフェースでした。型付き配列は<dfn>buffer</dfn>プロパティを持ち、対応するArrayBufferが入っています。なお、このプロパティは読み取り専用であり、このプロパティに別のArrayBufferを入れることで読み書き先を変更するようなことはできません。</p>
<p>実は、背後にあるArrayBufferを意識せずに型付き配列が利用される機会が増えています。型付き配列を作る場合、コンストラクタの引数にArrayBufferを渡すかわりに次のように数値を渡すことができます。この場合、その数の要素数を持った型付き配列が作られます。</p>
<pre><code>
var arr = new <mark>Uint8Array</mark>(10);
console.log(arr);
</code></pre>
<p>こうすると、要素が0で初期化された要素数10のUint8Arrayがコンソールに表示されます。このとき、実は10バイト分のArrayBufferが新たに作られています。</p>
<p>また、TypedArrayは配列と同様のメソッドを多く持っています。例えばmapを使ってみましょう。</p>
<pre><code>
var arr = new <mark>Uint8Array</mark>(10);
var arr2 = arr.<mark>map</mark>(function(x, i){ return x+i;});
console.log(arr, arr2);
</code></pre>
<p>arr2は<code>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</code>というUint8Arrayになりました。配列のmapが新しい配列を返すのと同様、これも新しいUint8Arrayを返します。</p>
<p>ところで、Uint8Arrayということは、中身は0から255までのはずです。それを超える値を代入しようとしたらどうなるでしょうか。</p>
<pre><code>
var arr = new <mark>Uint8Array</mark>(10);
arr[0] = 256;
arr[1] = 300;
arr[2] = -5;
console.log(arr); // [0, 44, 251, 0, 0, 0, 0, 0, 0, 0]
</code></pre>
<p>こうすると0番目は0、1番目は44、2番目は251となるはずです。つまり、数値の下位8ビット以外は捨てられるということです（-5のビット表現は<code>111...11011</code>であり、下位8ビットは<code>11111011</code>（10進法で251）となる点に注意してください）。</p>
<p>実はUint8Arrayにはこの場合に違う挙動をするバリエーションが用意されています。それが<dfn>Uint8ClampedArray</dfn>です。これは値の範囲はUint8Arrayと同じく8ビット符号なし整数ですが、その範囲を超える値が代入された場合に、0未満なら0に、256以上なら255にされるという点で異なります。</p>
<pre><code>
var arr = new <mark>Uint8ClampedArray</mark>(10);
arr[0] = 256;
arr[1] = 300;
arr[2] = -5;
console.log(arr); // [255, 255, 0, 0, 0, 0, 0, 0, 0, 0]
</code></pre>

<p>最後になりますが、知識のある読者の方は「2バイト以上の場合エンディアンはどうなるのか」と思ったかもしれません。実はエンディアンは<em>決まっていません</em>。そのプラットフォームにおけるネイティブな方式になります。</p>
<p>このことが理由で、Uint32Arrayなどの2バイト以上のTypedArrayは使いどころが制限されます。エンディアンを制御しつつArrayBufferの読み書きを行うには、<b>DataView</b>オブジェクトを使う必要があります。これについてはここでは解説しませんので、必要な方は調べてみてください。</p>
