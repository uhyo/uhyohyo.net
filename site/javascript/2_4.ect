<% @page.title="二章第四回　木構造の操作：ノードの除去"
@page.prev=[2,3]
@page.next=[2,5] %>
<h2>二章第四回　木構造の操作：ノードの除去</h2>
<p>今回は、木構造からノードをまるまる除去してしまう方法を解説します。</p>

<h3>removeChild</h3>
<p>それには、<dfn>removeChild</dfn>というメソッドを使います。これは、<strong>ノード</strong>が持つメソッドです。</p>
<p>まず使用例を見てみましょう。サンプルには、前回と同様のものを使います。</p>
<pre><code>&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;test&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p id="aaaaa"&gt;t&lt;strong&gt;es&lt;/strong&gt;t&lt;/p&gt;

    &lt;script type="text/javascript"&gt;
      var p = document.getElementById('aaaaa');
      var children = p.childNodes;
      var textnode = children.item(0);	//テキストノード
      p.<strong>removeChild</strong>(textnode);
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
        </code></pre>
<p>実行すると、画面には「<strong>es</strong>t」と表示されています。最初の「t」が消えてしまいました。</p>
<p>これは、実はこういうことです。</p>
<pre><code> p
｜
├――#text　　　　　　… "t"
｜
├――strong
｜　　　｜
｜　　　└――#text　　… "es"
｜
└――#text　　　　　　… "t"

            ↓↓↓

 p
｜
├――strong
｜　　　｜
｜　　　└――#text　　… "es"
｜
└――#text　　　　　　… "t"
        </code></pre>
<p>最初のテキストノードが消えてしまいました。</p>
<p>removeChildは、「子ノードのうち、引数のノードが表すノードを除去する」というメソッドです。</p>
<p>上のサンプルで、引数はtextnodeで、textnodeはpの子ノードの0番目のノードでした。つまり、引数のノードが表すノードとは、pの0番目の子ノードということになりますね。従って、それが除去されたというわけです。</p>
<p>ちなみに、除去されたノードは、まったく消えて無くなったわけではありません。木構造の中にこそありませんが、どこかに存在しています。これはどういうことかというと、除去したノードは、また別の場所で使ったりできるということです。これは、また別の機会に解説します。</p>

<p>さて、innerHTMLでやったような書き換えを実現するには、strong要素がまだ余計です。さっき0番目の要素を削除したから、</p>
<pre><code>var p = document.getElementById('aaaaa');
var children = p.childNodes;
var textnode = children.item(0);	//テキストノード
p.removeChild(textnode);
<mark class="ins">p.removeChild(children.item(1));</mark>
          </code></pre>
<p>のようにして次は1番目の要素を消せばいいと考えられます。今回は、いちいち別の変数に代入せずに直接引数にしています。</p>
<p>しかし、実際には「est」のうち「t」が消えて「es」が残っています。これは、今回追加したremoveChildが実行されるとき、木構造は</p>
<pre><code>
 p
｜
├――strong
｜　　　｜
｜　　　└――#text　　… "es"
｜
└――#text　　　　　　… "t"
          </code></pre>
<p>という状態でした。これの一番目だから、実は</p>
<pre><code>
 p
｜
├――strong　　　　　　　　←0番目
｜　　　｜
｜　　　└――#text
｜
└――<mark>#text</mark>　　　　　　　　 ←1番目
        </code></pre>
<p>のようになって「t」を表すテキストノードが1番目になっていたのです。</p>
<p>最初1番目だったstrong要素のノードは、0番目に変わってしまっています。これは、もともと0番目のノードが除去されて子ノードのリストから無くなったことで詰められたからです。実際に木構造を見ると分かりやすいと思います。</p>

<p>つまり、strong要素を除去するには、また0番目のノードをremoveChildしないといけなかったのです。</p>
<pre><code>var p = document.getElementById('aaaaa');
var children = p.childNodes;
var textnode = children.item(0);	//テキストノード
p.removeChild(textnode);

<mark class="ins">p.removeChild(children.item(<mark>0</mark>));</mark>
        </code></pre>
<p>こうすることで、</p>
<pre><code>
 p
｜
├<mark>――strong</mark>　　　　　　　　　　←これ
｜　　　<mark>｜</mark>
｜　　　<mark>└――#text</mark>　　… "es"
｜
└――#text　　　　　　… "t"
          </code></pre>
<p>を除去できるというわけです。ちなみに、さらに子を持つ要素を除去すると（今回の場合strongがさらに#textを子に持っていますね）、その子ごとまとめてなくなります。つまり、</p>
<pre><code>
 p
｜
└――#text　　　　　　… "t"
          </code></pre>
<p>このようになります。</p>
<p>だから、上のサンプルを実行すると「t」だけ残りました。このとき、この#textはまた<strong>0番目</strong>です。そこで、</p>
<pre><code>var p = document.getElementById('aaaaa');
var children = p.childNodes;
var textnode = children.item(0);	//テキストノード
p.removeChild(textnode);

p.removeChild(children.item(1));

<mark class="ins">children.item(0).<strong>nodeValue</strong> = "書き換えました";</mark>
          </code></pre>
<p>のようにしてこれを書き換えれば、</p>
<pre><code>
 p
｜
└――<mark>#text</mark>　　　　　　… "<mark class="ins">書き換えました</mark>"
          </code></pre>
<p>となって、見事p要素の中身は「書き換えました」だけになるわけです。</p>

<h4>子ノードの全除去</h4>
<p>今回の場合、p要素の中身を#textひとつだけ残しましたが、要素の子ノードを全部なくしたいということもよくあります。</p>
<p>そういう場合も今回のように1つずつ除去していくしかないのですが、それに適した方法があります。</p>
<p>まず、子ノードが何個あるか分からないから繰り返しの文を使うということは分かります。今回は<a href="kiso5.html">while文</a>を使います。</p>
<pre><code>&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;test&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p id="aaaaa"&gt;t&lt;strong&gt;es&lt;/strong&gt;t&lt;/p&gt;

    &lt;script type="text/javascript"&gt;
      var p = document.getElementById('aaaaa');
      var children = p.childNodes;

      <mark class="ins">while( p.<dfn>hasChildNodes</dfn>() ){
        p.removeChild( children.item(0) );
      }</mark>
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
        </code></pre>
<p>画面には何も表示されません。</p>
<p>まず、一つ新しいメソッドが出ています。<dfn>hasChildNodes</dfn>です。これは<strong>ノード</strong>が持つメソッドです。引数はありません。</p>
<p>このメソッドは簡単で、<strong>そのノードが子ノードを持っていればtrueを返し、持っていなければfalseを返します</strong>。</p>
<p>つまり、このwhileは、p要素が子ノードを持っている限り繰り返し続けるというわけです。</p>
<p>さて、繰り返される処理は1文だけです。childrenはp要素の子ノードのNodeListなので、removeChildでp要素の0番目（最初）の要素を除去しているというわけです。</p>
<p>NodeListからノードを除去すると詰められるので、pが子ノードを持っている限り「0番目の子ノード」は存在します。木構造で実際の動きを見てみると、</p>
<pre><code> p
｜
├――<mark>#text</mark>　　　　　　←0番目
｜
├――strong
｜　　　｜
｜　　　└――#text　　←1番目
｜
└――#text　　　　　　←2番目

↓↓↓

 p
｜
├――<mark>strong</mark>　　　　　 ←0番目
｜　　　｜
｜　　　└――#text
｜
└――#text　　　　　　←1番目

↓↓↓

 p
｜
└――<mark>#text</mark>　　　　　　←0番目

↓↓↓

 p
        </code></pre>
<p>というように順番に除去されて子ノードが無くなります。最後の子ノードをremoveChildで除去した後、hasChildNodesはfalseを返すため、そこでwhileが終了します。</p>
<p>この状態では、pの中に何もない、つまり<code>&lt;p&gt;&lt;/p&gt;</code>のような状態になるのでよくないですが、このまっさらな状態から新たなノードを追加していくということがよくあります。これについては、次回解説します。</p>

<h4>firstChild</h4>
<p>実は、ノードは<dfn>firstChild</dfn>というプロパティを持っています。意味は「最初の子」、つまり「<strong>0番目の子ノード</strong>」です。だから、当然代入されているのはノードです。書き換えはできません。これを使えば、childNodesを通さずに直接0番目の子を取得できます。つまり、上のサンプルはこう書き換えられます。</p>
<pre><code>while( p.hasChildNodes() ){
    p.removeChild( children.item(0) );
}

↓↓↓

while( p.hasChildNodes() ){
    p.removeChild(<mark class="ins">p.firstChild</mark>);
}
          </code></pre>
<p>ちなみに、こうなると変数childrenは1度も使われなくなるため、代入自体をしなくてもよくなります。また、<code>p.hasChildNodes()</code>は、<code>p.childNodes.length==0</code>としても同じ事ができます。考えてみればわかりますね。</p>

<p>また、派生して、「<dfn>lastChild</dfn>」というプロパティもあります。これは「一番最後の子」です。</p>
