<p>ES2015では、代入が進化しました。</p>
<p>従来、代入といえば、</p>
<pre><code>
a = 3;
var b = "foo";
</code></pre>
<p>のように変数に代入するか、あるいは</p>
<pre><code>
var obj={};
obj.c=true;
obj["d"]=null;
</code></pre>
<p>のようにプロパティに代入するかの2通りでしたね。</p>
<p>ES2015でも基本は変わりませんが、代入時にオブジェクトや配列を展開するということが可能になりました。</p>

<h3>destructuring assignment</h3>
<p>具体的には、次の例を見てください。</p>
<pre><code>
var [a, b] = ["foo", "bar"];
</code></pre>
<p>左辺が変数ではなく何か配列っぽい感じになっています。どういう動作になるかは何となく直感的に分かると思います。この例では<code>a</code>に<code>"foo"</code>が入り、<code>b</code>に<code>"bar"</code>が入ります。</p>
<p>つまり、代入の左辺に配列のように変数を並べたものを置いてやり、右辺に配列が来た場合、配列の形に合わせて各変数にまとめて代入されるのです。</p>
<p>なお、</p>
<pre><code>var [a, b, c] = ["foo","bar"];</code></pre>
<p>のように要素の数が合わない場合、余った変数にはundefinedが入ります。この場合はcがundefinedです。逆に右辺の配列のほうが長い場合、余ったところは代入されずに捨てられます。</p>
<p>また、ここでは右辺に配列リテラルを直接書きましたが、もちろん任意の配列を与えることができます。関数の返り値なども当然指定できますから、配列を用いて関数が擬似的に複数の値を返すとか、そういうことも可能ですね。</p>
<p>また、配列っぽい感じのほかに、オブジェクトっぽい感じの代入も可能です。</p>
<pre><code>
var {c, d} = {
  c:"foo",
  d:"bar"
};
</code></pre>
<p>オブジェクトっぽい感じで変数名を書いて、右辺に同じ名前のプロパティを持つオブジェクトを渡せば、各変数に入ります。この場合変数cに<code>"foo"</code>が、変数dに<code>"bar"</code>が入ります。</p>
<p>オブジェクトのプロパティ名とは違う名前の変数に入れたいという場合、次のように書きます。</p>
<pre><code>var {c<mark>:foo</mark>, d} = {
  c:"foo",
  d:"bar"
};</code></pre>
<p>この場合、cではなくfooという変数にオブジェクトのcプロパティの値が入ります（すなわち、変数fooに<code>"foo"</code>が入り、変数dに<code>"bar"</code>が入ります）。</p>
<p>この場合も、与えられたオブジェクトに該当のプロパティがない場合はundefinedが入ります。つまり、次の例では変数eはundefinedになります。</p>
<pre><code>
var {c, d, <mark>e</mark>} = {
  c:"foo",
  d:"bar"
};
</code></pre>
<p>ここまではvar文で説明しましたが、別にvar文でなくても代入可能です。例えば次の文も動作します。</p>
<pre><code>
[e,f]=[1,2];
</code></pre>
<p>ただし注意しなければいけないのは、次は文法エラーになります。</p>
<pre><code>
{g,h}={g:3, h:4};
</code></pre>
<p>その理由は、最初に
<code>&#x7b;</code>
が現れた時点でブロック文と解釈され、<code>=</code>のところでエラーが生じるからです。ブロック文と誤認されないように例えば次のように書けば動作します。</p>
<pre><code><mark>(</mark>{g,h}={g:3, h:4}<mark>)</mark>;</code></pre>
<p>なお、<code>=</code>は演算子という話を以前にしました。このような代入文の場合でも、演算子の返り値は右辺の値になります。</p>
<p>このように代入演算子の左辺に配列っぽいものやオブジェクトっぽいものを持ってくる方法を<dfn lang="en">destructuring assignment</dfn>（分解代入？）といいます。</p>
<p>さらに、配列やオブジェクトをネストさせることが可能です。次の例のように、同じ形のオブジェクトを渡せばそのとおりに値が入ります。</p>
<pre><code>
var [a, b, [c, d]] = [0, 1, [2, 3]];
</code></pre>
<p>また、左辺が配列っぽい形のときは、右辺は実はiterableである必要があります。iterableでなければエラーが発生します。逆に言えば、iterableならば配列でなくてもOKです。例えば文字列がiterableであることを利用すると、次のようなことが可能です。</p>
<pre><code>
[a,b,c,d,e] = "foobar";
</code></pre>
<p>他にも、変数名を書かないことでその部分を飛ばすことができます。</p>
<pre><code>[a,,b]= [1,2,3];</code></pre>
<p>この例ではaには1が、bには3が入ります。</p>
<p>余談ですが、このように<code>,</code>を連続させて配列リテラルを構成することは、代入文に限らずもともと可能です。例えば、</p>
<pre><code>console.log([1,,,2]);</code></pre>
<p>としてみれば分かりますが、これは<code>[1,undefined,undefined,2]</code>という配列と同等です。</p>

<p>最後に、配列の「残りの部分」をまとめて得る方法というのがあります。これは次のように書きます。</p>
<pre><code>[a,b,<mark>...</mark>c] = [1,2,3,4,5];</code></pre>
<p>こうすると、aには1が、bには2が、cには<code>[3,4,5]</code>という配列が入ります。このように配列っぽいやつの最後に<code>...</code>をつけた変数名を書くと、そこに配列が入ります。何も残っていない場合は空の配列ですね。なお、右辺が配列ではないiterableの場合でも、ここで得られるのは配列です。</p>

<h3>destructuring assignmentの応用</h3>
<p>以上で説明したことは、単なる代入文以外の場面でも使う機会があります。例えばfor-in文やfor-of文です。</p>
<pre><code>
var arr=["foo","bar","baz"];
for(var <mark>[i,val]</mark> of arr.entries()){
  console.log(i+": "+val);
}
</code></pre>
<p>この結果は次のようになります。</p>
<pre class="language-none"><code>
0: foo
1: bar
2: baz
</code></pre>
<p>前回紹介したArray#entriesと組み合わせることで、for-of文で添字付きで配列を回すのが簡単になります。</p>

<p>さらに、これは関数の引数にも使うことができます。次のように宣言した関数を考えます。この関数は、第1引数が変数名ではなくオブジェクトの分解代入の形になっています。</p>
<pre><code>
function foo(<mark>{a, b, c}</mark>){
  console.log(a, b, c);
}
</code></pre>
<p>この関数fooは次のように使うことができます。</p>
<pre><code>foo({
  a: 3,
  b: "bar",
  c: false
});</code></pre>
<p>結果として<code>3 "bar" false</code>のようにコンソールに表示されることでしょう。引数として渡されたオブジェクトが分解され3つのローカル変数a, b, cへの代入が行われたのです。</p>
<p>このように、関数宣言の引数に配列っぽいものやオブジェクトっぽいものを入れてやると、その部分に渡された引数が展開されて入ります。</p>

<p>ちなみに、destructuring assignmentとは直接関係ありませんが、先ほど紹介した<code>...</code>の記法を引数にも使うことができます。引数の最後をこの記法にすると、残りの引数が配列として得られます。</p>
<pre><code>
function bar(a,b,<mark>...c</mark>){
  console.log(a,b,c);
}
bar(1,2,3,4,5);
</code></pre>
<p>このコードの場合は、<code>1 2 [3,4,5]</code>と表示されるでしょう。3つ目以降の引数が配列としてまとめられて引数cに入ったことになります。これにより、任意個の引数をとる関数などが書きやすくなります。これを使えば以前紹介した<a href="9_3.html#anchor-arguments">arguments</a>を使う必要もなくなりますね。</p>
<p>さらに、ES2015では関数の引数に<b>初期値</b>を設定できるようになりました。これは、引数が与えられなかった場合、undefinedが入る代わりに初期値として指定しておいた値を入れるものです。引数名のあとに<code>=</code>を続けて書くことで初期値を指定します。</p>
<pre><code>
function baz(a<mark> = 5</mark>,b<mark> = 3</mark>){
  console.log(a,b);
}
baz(0);
</code></pre>
<p>この例では、関数bazに2つ目の引数bが与えられなかったので、初期値の3が入ります。よって結果は<code>0 3</code>となります。なお、引数としてundefinedを渡した場合は引数が渡されなかった扱いになり初期値が適用されます。nullの場合はされません。</p>
<p>もちろん、一部の引数にだけ初期値を設定することも可能です。いかなる場合も、関数に与えられた引数は前の引数から順に代入されます。</p>

<p>ここでやっと話が戻るのですが、この初期値はdestructuring assignment的な引数と組み合わせることができます。すなわちこうです。</p>
<pre><code>
function quux({a,b<mark>=3</mark>,c} <mark>={}</mark>){
  console.log(a,b,c);
}
quux({a:5});
</code></pre>
<p>結果は<code>5 3 undefined</code>です。ここでは初期値が二段構えになっていることに注意してください。まず<code>{a,b=3,c}</code>に対する初期値が<code>{}</code>です。これにより、quuxが引数なしで呼び出された際に、引数<code>{}</code>で呼び出されたのと同様になります。さらに、その引数を展開して変数a,b,cを代入しています。このときbには初期値が設定されているため、渡されたオブジェクトにプロパティbが無かった場合は初期値が変数bに代入されます。</p>
<p>さらに話を戻すと、実はこの初期値の指定は関数の引数に限らず行うことができます。すなわち、</code>
<pre><code>
var {a,b=3,c} = obj;
</code></pre>のようなことができます。</p>

<h3>let宣言とconst宣言</h3>
<p>さて、ここで新しい文法を紹介します。それは<dfn>let宣言</dfn>(<i lang="ja">Let declaration</i>)です。これはvar文とほぼ同様の文法を持ちます。varをletに変えるとlet宣言になります。</p>
<p>let宣言はvar文と同様にローカル変数を宣言するのですが、そのスコープ（範囲）が違います。</p>
<p>var文は、そのスコープは関数内ということになっています。つまり、関数内ならどこにvar文を書いても関数内全体で通用します（そして、関数の外には影響を与えません）。例えば、</p>
<pre><code>
function foo(a){
  if(a){
    <mark>var</mark> x=5;
  }
  console.log(x);
}
</code></pre>
<p>この関数は、aがtrueなら5を、aがfalseならundefinedを出力します。</p>
<p>このvar文はif文の中にありますが関係ありません。関数内に書いたvar文はどこに書いてあろうとも関数全体をスコープとして変数が初期化されます。ただし値が実際に代入されるのはvar文が実行された時点なので、この時点では変数xが作られただけで、その値はundefinedです。aが真のときはif文に入り、xに5が代入されます。</p>
<p>つまり、上の関数は次のように書いたのと同じということです。</p>
<pre><code>
function foo(a){
  <mark>var x;</mark>
  if(a){
    x=5;
  }
  console.log(x);
}
</code></pre>
<p>なので、fooは引数aが真のときは5を表示し、偽のときundefinedを表示するでしょう。</p>

<p>一方、let宣言の場合は、スコープが<strong>ブロック内</strong>に狭められています。ブロックとは、<code>{ }</code>で囲まれたコードです。厳密には関数宣言の<code>{ }</code>はブロックではありませんが、let宣言の場合はこれも同様に扱います。よって、letで作った変数はvarで作った変数と同様、関数の外に漏れることはありません。なお、例えばif文の<code>{ }</code>もブロックです。そこで、前の関数のvarをletに変えた場合を考えます。</p>
<pre><code>
function foo(a){
  if(a){
    <mark>let</mark> x=5;
  }
  console.log(x);
}
</code></pre>
<p>この場合、fooを実行するとconsole.logのところでエラーが発生します。なぜなら、このlet宣言により作られた変数xはif文のところのブロックのスコープに存在する、すなわちこのブロックの中でのみ有効だからです。ブロックの外に変数xは存在しないのでconsole.logのところではxは宣言されていないことになり、エラーが発生します。また、次の例を考えましょう。</p>
<pre><code>
function foo(a){
  <mark>let x=3;</mark>
  if(a){
    <mark>let</mark> x=5;
  }
  console.log(x);
}
</code></pre>
<p>この場合、aが真だろうと偽だろうと、表示されるのは3です。れえは、if文のところのブロックの中のlet宣言で作られたxが、そのブロックをスコープとして持ち、外にあるxとは別物となるからです。</p>
<p>なお、letだからといって内側のブロックで変数が使えなくなることはありません。あるブロックをスコープとする変数はその中全てで有効です（上の例のように同じ名前で別物の変数が作られた場合は除きますが）。そのため、次のコードは期待通りに動作します。if文の中で使われている変数xは関数のスコープでletで宣言されたxを指します。</p>
<pre><code>
function foo(a){
  <mark>let x=3;</mark>
  if(a){
    x=5;
  }
  console.log(x);
}
</code></pre>

<p>let宣言により、変数のスコープをより細かく管理することができます。基本的に、変数のスコープがブロックに制限されていても困ることはありません。広いスコープが欲しければ、それ相応の位置で宣言すればいいのです。あなたは今let宣言を知ってしまったので、今後varを使う必要はもはや無いでしょう。</p>
<p>varを書くことができる場所は全てletを書くことができます。例えば、for文でvarを書くことがありましたが、それもletにできます。</p>
<pre><code>
for(<mark>let</mark> i=1;i&lt;=10;i++){
  console.log(i);
}
</code></pre>
<p>こうすると、期待通り1から10まで表示されます。</p>
<p>ただし、for文におけるletは特別で、スコープはそのfor文の中になります。すなわち、<code>let i=1;</code>と<code>i&lt;=10</code>と<code>i++</code>というforを構成する各式及び<code>{ console.log(i); }</code>という本体部分にわたってこの<code>i</code>が使用可能です。その外にはもれないので、for文が終わるとiはなくなります。これはvarの場合と対照的です。varのときは次のようにできました。</p>
<pre><code>
for(var i=1;i&lt;=10;i++){
}
console.log(i); //11が表示される
</code></pre>
<p>しかし、letはできません。for文が終了した時点で変数iが有効なスコープの外に出てしまうからです。</p>

<p>ついでに、これはいままで紹介していなかった気がするのでここで解説していますが、if文などがなくてもブロックを作ることができます。</p>
<pre><code>
let x=3;
<mark>{</mark>
  let x=5;
<mark>}</mark>
console.log(x);
</code></pre>
<p>これが<b>ブロック</b>と呼ばれるもので、文と同様に扱われます。ブロックの働きはもちろん、中の文を全て実行することです。</p>
<p>本来if文やfor文などは処理部分を1文しか書くことができません。その1文にブロックを当てはめることで複数の文を処理させているのです。if文には</p>
<pre><code>
if(a==null)a={};
</code></pre>
<p>のようにブロックを使わない書き方もありますが、これはそういう理由によるものです。</p>

<h4>const宣言</h4>
<p>さて、let宣言の仲間として<dfn>const宣言</dfn>というのもあります。これは、letをconstに変えただけで、letと同様にブロックスコープの変数を作ります。</p>
<p>constとは定数のことですね。constの特徴は、<em>const宣言により作られた変数は再代入できない</em>ということです。一度変数を作ったあとは、再び代入しようとしても何も起きません<small>（strictモードのときはエラーになります）</small>。</p>
<p>const宣言にはある変数が定数であると分かりやすくする効果があります。</p>
<pre><code>
function foo(){
  <mark>const</mark> a=3;
  a=5;
  console.log(a);
}
foo();
</code></pre>
<p>これの実行結果は3となります。</p>
<p>なお、注意すべきなのは、オブジェクトをconstで宣言してもオブジェクトの中身は変わる可能性があるということです。</p>
<pre><code>
function bar(){
  const obj={a:3,b:5};
  obj.a=6;
  console.log(obj);
}
bar();
</code></pre>
<p>こうすると、<code>{a:6,b:5}</code>という結果になるでしょう。constはあくまで変数への代入（<code>obj = なんとか</code>）を制限するのみで、変数に対するその他の操作は一切制限されないのです。</p>
<p>また、constで変数を作るときは必ず初期化する必要があります。つまり、<code>const x;</code>のようにその場で代入しない宣言はできません。これは当然ですね。一度作ったら再代入できないのだから、最初に代入しないと何の意味もない変数になります。</p>
<p>constなんで何に使うんだと思うかもしれませんが、実践的なプログラムを書くときは意外とconstが使われる機会が多いです。一度変数に値を代入したあと、再度代入する機会は実は多くありません。必要がないのに再代入可能なのはバグの元なので、再代入する気がない変数はconstで宣言しましょう。そうすると、ものにもよりますが、プログラムの変数宣言の9割くらいはconstになります。</p>

<h4>変数の再宣言</h4>
<p>letとconstには、varとは違う特徴がもう1つあります。それは、<strong>変数の再宣言ができない</strong>ということです。</p>
<p>実は、varでは同じ変数を何回も宣言することができました。</p>
<pre><code>
var a = 3;
console.log(a);
var a = 5;
console.log(a);
var a = 10;
console.log(a);
</code></pre>
<p>このようにvarで何回も変数を宣言した場合、2回目以降のvarは無視されます。つまり、上のプログラムはこれと同じ意味です。</p>
<pre><code>
var a = 3;
console.log(a);
a = 5;
console.log(a);
a = 10;
console.log(a);
</code></pre>
<p>一方、letやconstでは、同じスコープで同じ変数を宣言するのは<em>エラー</em>になり、できません。同じ変数を何度も宣言するなんてことはふつうはやりませんしバグの元なので、このほうがいいですね。</p>
<p>なお、もちろん違うスコープなら同じ名前の変数を宣言できます。次の例はOKです。</p>
<pre><code>
let a = 3;
if (a > 0){
  let a = 5;
  console.log(a);
}else{
  const a = 10;
  console.log(a);
}
</code></pre>

<p>この講座でも以降はletやconstが登場してきます。</p>
