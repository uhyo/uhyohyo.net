page_title: 質問と回答1
<p>寄せられた質問に対して回答します。</p>

<h3 id="2012-11-17">String#matchの複数マッチについて</h3>
<p>回答日: <time>2012-11-17</time></p>
<div class="q">
  <p><a href="4_3.html#anchor-match">String#match</a>でgオプションをつけると、返り値でグループ化の情報が落ちる。複数マッチさせた上グループ化の情報も得たい。</p>
</div>
<nav class="re">
<p>関連ページ: <a href="4_2.html">四章第二回</a>・<a href="4_3.html">四章第三回</a></p>
</nav>

<p><a href="4_3.html#anchor-match">String#match</a>は<a href="4_3.html">四章第三回</a>で解説しました。このときは、matchの戻り値について、<q>matchでgオプションを使う場合、キャプチャは行われなくなります。</q>と解説しました。</p>
<p>これは仕様ですのでどうしようもありませんから、複数マッチの場合はひとずつつループを回して対処します。</p>

<h4>普通にループで回す方法</h4>
<p>一つの方法は、1回のmatchで1つずつマッチさせて、その部分を文字列から取り除いて再びマッチさせる方法です。マッチさせる文字列が破壊されますので、コピーしてから行いましょう。</p>
<pre><code>
<em>//携帯電話の番号(090-xxxx-xxxx)にマッチさせた上、前半と後半に分けるサンプル</em>
var str="090-1234-5678 , 090-8888-8888 / 090-9876-5432 090-0000-0000";

var result;	//matchの結果を入れる変数

while(result = str.<mark>match</mark>(/^<mark>.*?</mark>090-(\d{4})-(\d{4})/)){
  //もうマッチしない場合はresultにnullが入るのでループが終わる
  console.log(result);	//何かに使用する（ここでは表示するだけ）

  str = str.<mark>slice</mark>(result[0].length);	//strからマッチした部分を取り除く
}
</code></pre>
<p>出力結果は次のような感じです。</p>
<pre><code>
["090-1234-5678", "1234", "5678"]
[" , 090-8888-8888", "8888", "8888"]
[" / 090-9876-5432", "9876", "5432"]
[" 090-0000-0000", "0000", "0000"]
</code></pre>
<p>ポイントは、matchの引数の最初についている<code>^.*?</code>です。^というのは文字列の一番最初からマッチせよという意味で、.は任意の文字で、*は0回以上の繰り返し、そして*についた?は<strong>最短マッチ</strong>です。最短マッチというのは、なるべく短くマッチするということですから、.が何にでもマッチするとはいえ、マッチすべき部分がその中に含まれてしまう（見逃してしまう）ことはありません。</p>
<p>そして結果の配列の1番目と2番目に欲しい情報が入っていることがわかります。</p>
<p>配列の0番目を見ると、マッチさせたい090-の部分の前にごちゃごちゃと何かが入っているのが分かります。これが<code>.*?</code>にマッチした部分です。ちなみに、最短マッチの?がないと以下のような結果になってしまいます。</p>
<pre><code>
["090-1234-5678 , 090-8888-8888 / 090-9876-5432 090-0000-0000", "0000", "0000"]
</code></pre>
<p>.*?の部分に全部含まれてしまい（?がないと最長マッチになってなるべく長く含めようとするため）、一番最後のしか得られません。</p>

<p>プログラムの最後の</p>
<pre><code>
str = str.<mark>slice</mark>(result[0].length);
</code></pre>
<p>ですが、これはstrから今回マッチした部分を全て除くという意味です。</p>
<p><a href="4_1.html#anchor-slice-substring">slice</a>は、文字列の（第1引数）番目から（第2引数）番目まで抜き出すという意味ですが、第二引数を省略した場合は最後まででしたね。</p>
<p>ここで、<code>result[0]</code>というのはさっき見た通り、今回マッチした部分の全体です。この正規表現がマッチするときは必ず文字列の先頭からマッチします（正規表現の先頭に<code>^</code>があるので）。これらの点がポイントです。</p>

<h4>matchの結果のindexを利用する方法</h4>
<p>上の方法は、<code>.*?</code>がなんだか邪魔です。そこでこれを用いない方法も紹介します。</p>
<pre><code>
<em>//携帯電話の番号(090-xxxx-xxxx)にマッチさせた上、前半と後半に分けるサンプル</em>
var str="090-1234-5678 , 090-8888-8888 / 090-9876-5432 090-0000-0000";

var result;	//matchの結果を入れる変数

while(result = str.match(/090-(\d{4})-(\d{4})/)){
  //もうマッチしない場合はresultにnullが入るのでループが終わる
  console.log(result);	//何かに使用する（ここでは表示するだけ）

  str = str.slice(<mark>result.index</mark>+result[0].length);	//strから、マッチした部分を取り除く
}
</code></pre>
<p>結果は以下のとおりです。</p>
<pre><code>
["090-1234-5678", "1234", "5678"]
["090-8888-8888", "8888", "8888"]
["090-9876-5432", "9876", "5432"]
["090-0000-0000", "0000", "0000"]
</code></pre>
<p>このソースがさっきと違う点は、正規表現から余計な部分が消えたという点と、sliceの引数に<code>result.index</code>を足しているという点です。</p>
<p>結果を見ても、<code>result[0]</code>も余計なものがくっついていなくて使いやすくなっています。</p>
<p>ところで、resultというのはstr.matchの戻り値ですから配列のはずですが、実はString#matchの戻り値の配列には<dfn>index</dfn>という特別なプロパティが追加されています。</p>
<p>このindexというのは、文字列の最初から数えて何文字目にマッチしたかということです。例えば、</p>
<pre><code>
"12345abcde67890"
      <em>^^^</em>
</code></pre>
<p>という文字列で<code>"abc"</code>にマッチさせた場合はこうなります。</p>
<pre><code>
var result="12345abcde67890".match(/abc/);
console.log(result.index);	<em>//5</em>
</code></pre>
<p>abcの最初の文字aがあるのは5番目ですから（最初が0番目であることに注意）、indexプロパティには5が入っています。</p>
<p>既にマッチした部分を文字列から捨てる場合、ここで示されたindexより前の部分はマッチしなかったのですからもう要りません。それに、今回マッチした<code>result[0]</code>の部分の長さを足して、その部分を捨ててしまおうというのが、</p>
<pre><code>
result.index+result[0].length
</code></pre>
<p>の意味です。</p>
<p>ちなみに、String#matchの返り値の配列にはもうひとつ<dfn>input</dfn>というプロパティがあり、これは検索対象の文字列全体です。</p>

<h4>Regexp#execとlastIndexを使う方法 <em class="rec">おすすめ</em></h4>
<p><dfn>lastIndex</dfn>とは、<strong>正規表現オブジェクト</strong>がもつプロパティです。これを用いると次のように書けます。</p>
<pre><code>
<em>//携帯電話の番号(090-xxxx-xxxx)にマッチさせた上、前半と後半に分けるサンプル</em>
var str="090-1234-5678 , 090-8888-8888 / 090-9876-5432 090-0000-0000";

var regexp= /090-(\d{4})-(\d{4})/<mark>g</mark>;
var result;	//matchの結果を入れる変数

while(result = regexp.<strong>exec</strong>(<mark>str</mark>)){
  //もうマッチしない場合はresultにnullが入るのでループが終わる
  console.log(result);	//何かに使用する（ここでは表示するだけ）
}
</code></pre>
<p>この方法は、str.sliceを用いてstrを書き換える必要がなくなり、とてもすっきりしています。</p>
<p>ポイントは、<dfn>exec</dfn>というメソッドです。これはtestと同じく正規表現オブジェクトがもつメソッドで、String#matchと同じです。</p>
<p>ただし、見ての通り、String#matchとは、文字列と正規表現オブジェクトの関係が逆になっています。</p>
<p>また、正規表現にgオプションがついている場合は2つの挙動は変わります。String#matchのほうは前に紹介した通り、複数のマッチ結果を全て配列にして返します。</p>
<p>Regexp#execのほうは、gがついても挙動はそれほど変わりません。gがある場合は、正規表現オブジェクト（今回は<code>regexp</code>）の<dfn>lastIndex</dfn>プロパティが変化します。lastIndexというのは、<strong>次回のマッチを開始する位置</strong>で、最初は0です。</p>
<p>そしてこのlastIndexが、ちょうど今回マッチした部分の次の位置にセットされるのです。</p>
<p>つまり、簡単にいうと、gフラグを持つ同じ正規表現オブジェクトで（lastIndexを保持するため）、RegExp#execを使ってマッチさせると、マッチさせるたびに次のところがマッチして、全部終わったらちゃんとnullを返してくれます。これは、毎回lastIndexが変化するからで、Regexp#matchをgオプションつきの正規表現オブジェクトで呼び出したときに特有の動作です。</p>

