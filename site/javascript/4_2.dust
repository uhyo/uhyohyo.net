<p>今回紹介するのは<dfn>正規表現</dfn>です。やや難しいですが面白い機能ですからぜひマスターしましょう。</p>

<h3>正規表現とは</h3>
<p>正規表現の基本的な機能は文字列を<strong>検索</strong>することです。前回indexOfというもので文字列を検索できることを解説しましたが、あれのように「ある文字列が含まれているかどうか」だけを調べるのは最も単純な部類の検索です。</p>
<p>正規表現を使うと、もっと複雑な検索条件を指定することができます。</p>

<h3>正規表現の書き方</h3>
<p>正規表現を検索のために使う場合、正規表現を書くというのは検索条件を書くことに相当します。複雑な検索条件が書けると述べましたが、さすがに日本語や英語で書いてもコンピューターに伝わらないので、専用の書き方があります。それが正規表現です。例えば、</p>
<pre><code>abc</code></pre>
<p>これは、正規表現のもっとも簡単な形です。ただ「abc」とあるだけですが、この正規表現は「<code>"abc"</code>である」という条件を表しています。これくらいの検索ならindexOfでもできますね。</p>

<p>次に、</p>
<pre><code>a<mark>.</mark>c</code></pre>
<p>という形です。この正規表現中に登場する「<code>.</code>」は<strong>特別な意味を持つ文字</strong>です。</p>
<p>これは<strong>どんな文字でも当てはまる</strong>という意味を持ちます。「<code>.</code>」の部分に当てはまる文字は、何でもよいのです（例外的に、改行文字だけはこれに当てはまりません）。</p>
<p>つまり、「aac」も「abc」も、「aあc」「a(c」なども条件に合うことになります。</p>
<p>ちなみに、条件に合うことを<dfn>マッチする</dfn>といいます。</p>

<p>次の例を見ましょう。</p>
<pre><code>ab<mark>+</mark>c</code></pre>
<p>新しい記号<strong><code>+</code></strong>が登場しました。これも特別な記号です。</p>
<p>この記号の意味は、<strong>直前の文字が1つ以上繰り返している</strong>です。直前の文字は、今回の場合bですね。1つ以上ということは、<strong>数を限定しない</strong>のです。つまり、<strong>1つ以上なら何個でもいい</strong>ということです（1つしかなくても「1回繰り返している」ことにします）。ここがポイントです。</p>
<p>つまり、この条件は、「abc」にマッチするほか、「abbc」「abbbc」「abbbbc」「abbbbbc」……にもマッチします。</p>

<p>また、似たようなものに<code>*</code>記号があります。この記号は1つ以上ではなく<strong>0個以上</strong>を表します。つまり、直前の文字が0個でもいい（無くてもいい）のです。例えば、</p>
<pre><code>ab<mark>*</mark>c</code></pre>
<p>この正規表現は、<code>ab+c</code>の場合に加えてbが1個もない形である「ac」にもマッチします。</p>

<p>次の例のように、今紹介した2つを組み合わせた形もありえます。</p>
<pre><code>a<mark>.+</mark>c</code></pre>
<p>この場合、+の直前の文字は<code>.</code>です。この<code>.</code>は、どんな文字でも当てはまるものでした。<code>+</code>によって<code>.</code>が何個でも良くなったということは、この正規表現は、<strong>aとcの間に何がどれだけ入っていてもいい</strong>ということになります。</p>
<p>ただし+は「1つ以上」なので、まったく何も入っていない「ac」という形はマッチしません。しかし、それ以外なら、「abc」も「a1234c」も「aあいうえおc」「akjijgifc」でも、aとcの間に何かが入っている形であればなんでもマッチします。もちろん、<code>a.<mark>*</mark>c</code>ならば「ac」にもマッチします。</p>

<p>さて、まだまだ書き方はあります。</p>
<pre><code>a<mark>[abcde]</mark>c</code></pre>
<p>という書き方があります。[ 〜 ]まででひとかたまりに扱います。</p>
<p>この意味は、<strong>その中に含まれている文字のうちのどれか</strong>ということになります。中に含まれている文字とは、「abcde」の部分です。</p>
<p>つまり、「aまたはbまたはcまたはdまたはe」ということになるから、この正規表現は、「aac」「abc」「acc」「adc」「aec」のいずれかにマッチします。</p>
<p>また、aからeは連続したアルファベットだから、次のように省略することができます。<small>（連続というのは、正確には文字コードが連続しているということです。）</small></p>
<pre><code>a[<mark>a-e</mark>]c</code></pre>
<p>aとeの間のハイフンのおかげで、「a-e」が「aからe」という意味になります。これを利用すると、例えば<code>[a-z]</code>は「aからz」だから小文字のアルファベット全てにマッチします。</p>
<p>また、ハイフンで繋いだ組は次のように複数書くことができます。</p>
<pre><code>[a-zA-Z]</code></pre>
<p>この場合、「aからzとAからZ」という意味になり、アルファベット全てになります。</p>

<p>また、<code>[<mark>^</mark>abcde]</code>や<code>[<mark>^</mark>a-zA-Z]</code>のように、中の先頭に<code>^</code>をつけると意味が変わり、「その中の文字<strong>以外</strong>の文字のどれか」ということになります。意味が逆になりますね。</p>

<h3>JavaScriptで正規表現</h3>
<p>さて、正規表現にはまだまだバリエーションがありますが、ここで一度休憩して、実際にJavaScriptで正規表現を扱ってみたいと思います。</p>

<h4>正規表現オブジェクト</h4>
<p>JavaScriptでは、正規表現（検索条件）はオブジェクトの形で表現します。それが正規表現オブジェクト(RegExpオブジェクト)です。</p>
<p>正規表現を作るには次のように書きます。</p>
<pre><code>new RegExp(<mark>"ab+c"</mark>)</code></pre>
<p>見てわかるように、正規表現を文字列で指定します。</p>
<p>しかし、この方法よりも<dfn>正規表現リテラル</dfn>を用いるほうが一般的です。それは、</p>
<pre><code>/<mark>ab+c</mark>/</code></pre>
<p>のような書き方です。<code>ab+c</code>の部分に好きな正規表現を入れてください。1つ目の方法との違いとしては、正規表現リテラルを用いる場合は文字列ではないので<code>""</code>で囲む必要がないという点があります。</p>

<h4>文字列にマッチさせる</h4>
<p>さて、ある文字列に正規表現がマッチするかどうか調べるためには、次のようにします。すなわち、正規表現オブジェクトの持つtestメソッドを用います。</p>
<pre><code><var>正規表現オブジェクト</var>.<dfn>test</dfn>(<var>文字列</var>)</code></pre>
<p>このtestメソッドの戻り値は<strong>真偽値</strong>で、マッチすればtrue、しなければfalseを返します。</p>
<p>また、文字列を正規表現にマッチさせるという場合、文字列全体ではなくどこか一部分でも条件を満たしていればマッチします。</p>

<p>ひとつ例を見てみましょう。</p>
<pre><code>if( /bcd/.test("abcde") ){
    console.log("マッチしました");
}else{
    console.log("マッチしませんでした");
}</code></pre>
<p>これでは、文字列<code>"abcde"</code>が、正規表現<code>/bcd/</code>にマッチするかどうか判定しています。これはマッチしているので、trueが返り、if文の中が実行されます。<code>a<mark>bcd</mark>e</code>の部分がマッチしたわけです。</p>
<p>なお、<code>/bcd/</code>はオブジェクトなので、当然次のように変数に入れて利用することもできます。</p>
<pre><code>
var cond = /bcd/;
var str = "abcde";
console.log(cond.test(str));
</code></pre>

<h3>正規表現の書き方2</h3>
<p>では、正規表現の書き方の続きを解説します。まずは次の正規表現を見てください。</p>
<pre><code>ab<mark>{4}</mark>c</code></pre>
<p>ここで、<code>{4}</code>が新しい書き方です。これは「<strong>直前の文字を4回繰り返す</strong>」というもので、なぜ4回かといえば、当然、{ }の中が4だからです。一般化すると、<code>{n}</code>という指定は、「<strong>直前の文字をn回繰り返す</strong>」というようになります。nには0以上の整数を入れることができます。</p>
<p>今回の場合、直前の文字はbだから、これは「abbbbc」という文字列にマッチすることになります<code>+</code>や<code>*</code>も繰り返し1を表す記号ですが、あちらは繰り返す回数に制限がないのが大きな特徴でした。こちらは、回数を指定することができます。</p>

<p>また、もう少し幅を持たせて、次のような表現が可能です。</p>
<pre><code>ab<mark>{2,5}</mark>c</code></pre>
<p>今度は、{ 〜 }の中の数値が<code>,</code>で区切られて2つになりました。</p>
<p><code>{m,n}</code>のように2つの数値を区切って書いたとき、<strong>直前の文字をm回以上n回以下繰り返した文字列</strong>にマッチします。</p>
<p>上の書き方は4回以外はマッチしませんでしたが、今回はもう少し幅があって、2回以上5回以下となっています。つまり、「abbc」「abbbc」「abbbbc」「abbbbbc」にマッチします。</p>

<p>もう1つあって、それは次のような書き方です。</p>
<pre><code>ab<mark>{2,}</mark>c</code></pre>
<p>前と同じように2つの数値を区切って書く書き方かと思いきや、2つめの数値が省略されています。この書き方は、繰り返しの最低回数は指定するが、最高回数は制限しないという場合の方法です。</p>
<p>つまり、今回の場合「2回以上」ということになり、「abbc」「abbbc」「abbbbc」・・・にマッチします。お気づきかとは思いますが、<code>{1,}</code>と書けば<code>+</code>と同じになり、<code>{0,}</code>と書けば<code>*</code>と同じになります。</p>

<p>これでこのシリーズは終了です。さらに、</p>
<pre><code>ab<mark>?</mark>c</code></pre>
<p>という書き方ができます。この「?」は、<strong>直前の文字が0回または1回</strong>という意味です。つまり、「ac」か「abc」にマッチします。</p>

<h4>グループ化</h4>
<p>重要な機能としてグループ化というものがあります。これは、<strong>複数の文字をひとまとめに扱うことができるもの</strong>です。グループ化は、</p>
<pre><code>a<mark>(</mark>bc<mark>)</mark></code></pre>
<p>のように、ひとまとめにしたい部分を<code>( 〜 )</code>で囲みます。また、<code>(?: 〜 )</code>で囲むこともできます。この2つの違いは次回紹介しますが、基本的には後者の<code>(?: 〜 )</code>を使います。</p>
<p>これだけでは何も変わりませんが、これを例えば次のように利用できます。</p>
<pre><code>a(?:bc)<mark>+</mark></code></pre>
<p>+は直前の文字を1回以上繰り返すというものでした。ここで、<code>+</code>の直前にあるのは文字ではなく、<code>(?:bc)</code>というグループです。これは<code>bc</code>をひとまとめにしたグループなので、「bc」を繰り返すということになります。</p>
<p>したがって、「abc」「abcbc」「abcbcbc」「abcbcbcbc」……　にマッチするということになります。</p>
<p><code>+</code>以外にも、<code>*</code>や<code>{〜}</code>や<code>?</code>などでも同じです。今まで「文字を繰り返す」と説明したものは、グループを繰り返すのにも使えます。</p>

<p>さて、次のような書き方もあります。</p>
<pre><code>aaa<mark>|</mark>abc</code></pre>
<p><code>aaa</code>と<code>abc</code>が<code>|</code>で区切られています。これは単純に「<code>aaa</code>か<code>abc</code>の<strong>どちらか</strong>」という意味です。この正規表現でマッチさせる場合、aaaかabcのどちらかが含まれていればマッチします。</p>
<p><code>aaa|abc|zzzzz</code>のように、3つ以上候補をたてることも可能です。</p>
<p>さて、これを他の書き方に組み込むとどうなるでしょう。例えば、<code>1234</code>の後に<code>aaa|abc|zzzzz</code>（aaaかabcかzzzzzのどれか）が続く場合、</p>
<pre><code>1234aaa|abc|zzzzz</code></pre>
<p>のように書くと、「<code>1234aaa</code>か<code>abc</code>か<code>zzzzz</code>」という意味になってしまいます。</p>
<p>これは先述のグループ化を使うことで正しく書くことができます。すなわち、次のようにします。</p>
<pre><code>1234<mark>(?:</mark>aaa|abc|zzzzz<mark>)</mark></code></pre>
<p>これは、「1234aaa」「1234abc」「1234zzzzz」のいずれかにマッチします。</p>

<h4>1文字である種類の文字のどれかを表す特殊な文字</h4>
<pre><code><mark>\s</mark></code></pre>
<p>という書き方があります。ここで、<code>\s</code>は2文字でセットです。一般に、「<code>\</code>」は、その次の文字と合わさって特殊な意味を持ちます。</p>
<p>それでは、この<code>\s</code>はどういう意味を持つかというと、<strong>空白文字</strong>にマッチします。空白文字は、文字通り空白のことで、半角スペース、タブ、改行など、空白を表す文字が当てはまります。例として、次の正規表現は<code>"foo bar"</code>や<code>"foo  \t  bar"</code>などにマッチします。</p>
<pre><code>foo<mark>\s</mark>+bar</code></pre>

<p>他にも、<code><mark>\d</mark></code>というのもあります。今度はsではなくdです。これは、<strong>数字1文字</strong>です。数字とは0から9のことなので、<code>\d</code>は<code>[0-9]</code>と同じ意味になります。これも結構使う機会が多いです。</p>

<p>ここで、今まで特殊な意味の文字がいろいろ出てきました。<code>. + * ? { } ( ) [ ] | \</code>などです。それでは、これらの文字を、特殊な意味ではなく、これらの文字そのものが含まれるという意味で使いたい場合には、どうすればいいのでしょうか。</p>
<p>実はその場合は<code><mark>\</mark>. <mark>\</mark>+ <mark>\</mark>*</code>などのように、前に<code>\</code>をつけます。これは覚えておきましょう。例えば、<code>3<mark>\+</mark>2</code>という正規表現の場合、<code>"3<mark>+</mark>2"</code>という文字列にマッチします。</p>

<p>気をつけていただきたいのは、このような<code>\</code>を用いる記法は前回紹介したエスケープシーケンスとは異なる概念であるということです。今回のは正規表現の記法であるのに対し、前回のは文字列リテラル中での記法です。ただし、<code>\u1234</code>のようなコードポイントを指定するエスケープシーケンスは、正規表現でも使うことができます。</p>

<h4>位置を指定する文字</h4>
<p>今まで、書いたものはみんなそれぞれ文字にマッチしてきました。別な種類の特殊文字としては、文字にマッチするのではなく<strong>位置</strong>を指定するための特殊な文字もあります。</p>
<p>例として、次の正規表現を見てください。</p>
<pre><code><mark>^</mark>abc</code></pre>
<p>先頭に<code>^</code>がついてます。実は、この文字はその位置が<strong>文字列の先頭</strong>であることを示します。<small>（正規表現に複数行フラグがついている場合、<strong>行頭</strong>を表します。複数行フラグについては後々紹介します。）</small>
<p>つまり、この正規表現は<code>abc</code>という文字列にマッチしますが、<code>abc</code>の直前が文字列の先頭なので、この正規表現は<strong>文字列の先頭にあるabc</strong>に<em>のみ</em>マッチします。</p>
<p>だから、同じabcでも、</p>
<pre><code>1234<mark>abc</mark>
    ^^^
</code></pre>
<p>や</p>
<pre><code>a<mark>abc</mark>defg
 ^^^
</code></pre>
<p>にはマッチせず、</p>
<pre><code><mark>abc</mark>defgh
^^^
</code></pre>
<p>にはマッチするということになります。実際に、<code>/^abc/.test("1234abc")</code>や<code>/^abc/.test("abcdefgh")</code>などを実行して試してみましょう。<code>/abc/.test("1234abc")</code>の場合との違いに注意してください。</p>

<p>また、同じように<strong>文字列の末尾</strong>を表す特殊文字もあります。それは<code>$</code>です。</p>
<p>例えば、<code>abc<mark>$</mark></code>の場合、</p>
<pre><code>aaa<mark>abc</mark>defg
   ^^^
</code></pre>
<p>や</p>
<pre><code><mark>abc</mark>defg
^^^
</code></pre>
<p>にはマッチせず、</p>
<pre><code>aa<mark>abc</mark>
  ^^^
</code></pre>
<p>にはマッチするということです。</p>

<p>これらを組み合わせて、</p>
<pre><code><mark>^</mark>abc<mark>$</mark></code></pre>
<p>とするとどうでしょう。abcが最初であり最後であるということだから、</p>
<pre><code><mark>abc</mark>def
^^^
</code></pre>
<pre><code>aaaa<mark>abc</mark>
    ^^^
</code></pre>
<p>にはマッチせず、</p>
<pre><code><mark>abc</mark>
^^^
</code></pre>
<p>という、文字列が完全にそれと一致する場合のみマッチします。</p>

<p>最後に、 <code>\S</code>と<code>\D</code>を紹介します。先ほど紹介した<code>\s</code>や<code>\d</code>の大文字バージョンですが、大文字になると意味が逆転します。すなわち、<code>\S</code>は「<code>\s</code><strong>以外</strong>」、<code>\D</code>は「<code>\d</code><strong>以外</strong>」にマッチします。たまに使います。</p>
<p>具体的には、<code>\S</code>は「空白文字以外の任意の文字」、<code>\D</code>は「数字以外の任意の文字」にマッチすることになります。</p>
<p><code>\S</code>が使われる場面はいろいろありますが、面白いのは次のような使い方です。<code>[\s\S]</code></p>
<p>これは、「複数の文字のうちいずれか」を表す<code>[ 〜 ]</code>の中に<code>\s</code>と<code>\S</code>が入った形です。このように、<code>\s</code>などを<code>[ 〜 ]</code>に入れることが可能です。この場合、ちゃんと「<code>\s</code>または<code>\S</code>」という意味になります。</p>
<p><code>\s</code>は空白で<code>\S</code>は空白以外だから、2つ合わせると「全ての文字」という意味になります。全ての文字という意味の記号として<code>.</code>を紹介しましたが、<code>[\s\S]</code>は<code>.</code>よりも範囲が広いです。なぜなら、<code>.</code>は改行文字にマッチしませんが、<code>[\s\S]</code>は改行文字にもマッチするからです。（<code>\s</code>が改行文字にマッチするため。）これは逆の意味を持つ2つの記号なら何でもよく、<code>[\d\D]</code>などでも同じことができます。また、<code>.</code>が改行にマッチしないのを補えばいいので<code>(?:.|\s)</code>でもできます。ただ、よく使われるのは<code>[\s\S]</code>のような気がします。</p>

<p>以上で正規表現の書き方は終わりです。ここではよく使いそうなものは解説しましたが、他にも記法があります。自分で調べてみましょう。</p>
<p>次回はJavaScriptから正規表現を活用する方法を紹介します。</p>

