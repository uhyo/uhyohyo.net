<p>第十三章のテーマは「通信」でしたね。次に紹介するのは<dfn>Web Messaging</dfn>です。前回と前々回ではHTTP通信にかかわる機能を紹介しましたが、今回のこれはHTTP通信はしません。</p>
<p>それではどのような通信かというと、これは<strong>ブラウジングコンテキスト間</strong>の通信です。</p>
<p><b>ブラウジングコンテキスト</b>とは何かというと、これは<strong>ブラウザのタブの1つ1つ</strong>のことです。つまりブラウジングコンテキストで通信するということは、複数のタブの間でデータをやりとりするということです。</p>
<p>しかし、他のブラウジングコンテキストとデータをやりとりするということは、他にどんなタブが開かれているのかを知る必要があるわけですが、ユーザーがどんなページを今閲覧しているかというのは重要な個人情報ですので、そんなものはJavaScriptからは取得できません。それではどうすればいいのでしょうか。</p>

<h3>JavaScriptから他のブラウジングコンテキストを操作する</h3>
<p>JavaScriptから他のブラウジングコンテキストを知る方法のひとつは、<em>JavaScriptから新しいウィンドウを開く</em>ことです。最近のブラウザではウィンドウもタブの一種ですので、ここでブラウジングコンテキストが誕生します。自分で作ったブラウジングコンテキストなら知っているだろうという寸法です。</p>
<p>JavaScriptからウィンドウを開くには、<dfn>window.open</dfn>メソッドを使います。</p>
<p>window.openメソッドの第一引数は<strong>URL</strong>です。第二引数はウィンドウの<strong>名前</strong>です。ウィンドウに名前を設定すると、同じ名前のウィンドウは1つしか作れなくなります（詳しくは後述）。また、第三引数にオプションを指定することもできますが、ここでは詳しくは解説しません。</p>
<p>それではwindow.openのサンプルです。</p>
<pre><code>
<mark>window.open</mark>("https://www.google.co.jp/","google");
</code></pre>
<p><button onclick='window.open("https://www.google.co.jp/","google")'>このボタン</button>を押すと上のプログラムが動作します。</p>
<p>ボタンを押すと、window.openによって新しいタブが開かれます。新しいウィンドウと上では言いましたが、最近のブラウザは本当に新しいウィンドウを作るのではなくタブを作るだけにとどめることがあるようです。このタブには内部的に第二引数の<code>"google"</code>という名前がつけられます。</p>
<p>ここでそのタブが開いた状態で再びボタンを押すと、新しいタブは開きません。これは、"google"という名前のウィンドウがすでにあるため、それが再利用されたからです。もしその<code>"google"</code>のタブを消してからボタンを押したならば、また新しいタブが開くでしょう。</p>
<p>ちなみに、最近のブラウザには「ポップアップブロック」機能がついています。これは、JavaScriptでwindow.openで勝手に広告のウィンドウを出したりするのが邪魔くさいのでそういったものを動作させないようにする機能です。ですから、「ページと同時に新しいウィンドウを開く」というプログラムを作ったりしてもポップアップブロックに引っかかってウィンドウが開いてくれない可能性が高いです。</p>
<p>今回のサンプルはブロックされないブラウザが多いとおもいますが、これは「ボタンをクリックする」というユーザーの動作がトリガーになったせいでしょう。</p>
<p>さて、そして、このwindow.openの戻り値は<strong>Window</strong>オブジェクトです。このWindowオブジェクトが、その開かれたウィンドウのブラウジングコンテキストを表すオブジェクトです。</p>
<p>お察しの通り、今開いているページのブラウジングコンテキストに対応するのがおなじみの<strong>window</strong>です。つまり、<code>window.open</code>によって開いたタブについては、そのページに対応するWindowオブジェクトを得ることができるのです。</p>
<p>また、今まで慣れ親しんできた<b>document</b>もwindowのプロパティです。以前述べたようにwindowのプロパティはグローバル変数として利用可能なので我々はwindow.documentをdocumentとして扱ってきたのです。</p>
<pre><code><mark>window</mark>.document === document	<mark class="ins">//true</mark></code></pre>
<p>つまり、今回得られたWindowオブジェクトのdocumentプロパティを通じて開いたタブの中身を操作できるかもしれません。</p>
<p>ところが、第13章からおなじみの<em>同一オリジンポリシー</em>はここでも有効です。異なるオリジンのページの情報は取得できず、当然操作することもできません。</p>
<p>それでは同じオリジンなら操作できるのでしょうか。試してみましょう。下に2つのボタンを用意しました。それぞれ以下のような動作です。</p>
<pre><code>
//ボタン1（ウィンドウを開く）
win=window.open("/");

//ボタン2（ウィンドウの中身を書き換える）
win.<mark>document</mark>.body.textContent="書き換えました";
</code></pre>
<p><button onclick='win=window.open("/")'>ボタン1</button><button onclick='win.document.body.textContent="書き換えました"'>ボタン2</button></p>
<p>ボタン1を押したあとボタン2を押してみましょう。開いたウィンドウの中身が書き換えられたことが確認できたと思います。</p>
<p>これが2つのウィンドウの連携の基本ですが、このように外からページを操作するというのはあまりスマートではありません。ではどのような方法がスマートなのかというと、外から与えるのは「指示」だけで、実際の動作は内部で行われるようなのがいいでしょう。</p>

<p>この方法の利点は、複数の異なるページから、同じページをウィンドウとして開いて同じ動作をさせるとき、外からいじるのでは同じソースを操作元の両方のページで読みこませる必要があるのに対して、指示を与える方法ならば実際に動作するソースは操作される側のページ1つだけで済むということです。</p>
<p>それで、その指示を与える方法というのが、今回紹介するWeb Messagingなのです。</p>

<h3>メッセージを送る</h3>
<p>さて、あるブラウジングコンテキストに対してメッセージを送るには、Windowオブジェクトのメソッドである<dfn>postMessage</dfn>を使います。これを呼び出すとそのウィンドウに対してメッセージを送ります。</p>
<p>引数は、第1引数が送るメッセージです。送ることができるメッセージは、プリミティブ（文字列とか数値とか真偽値とか）や、普通のオブジェクト、配列、Dateオブジェクトなどです。また、最近よく出てくるFile, Blob, FileList, ArrayBufferも送ることができます。</p>
<p>さらに、第2引数は<b>送る先のオリジン</b>です。これは、意図しないサイトに向けて情報を漏らしてしまわないように、メッセージ送る先のオリジンを指定できるということです。送る先のブラウジングコンテキストのオリジンが指定したものと異なる場合はメッセージの送信は失敗します。</p>
<p>例えばhttps://www.google.com/以下のページに送りたい場合は、</p>
<pre><code>
postMessage("メッセージ",<mark>"https://www.google.com"</mark>);
</code></pre>
<p>のようにします。この第2引数は<strong>省略できません</strong>。オリジンの他に指定できる特殊な値としては、現在のオリジンと同じオリジンを表す<code>"/"</code>と、送る先がどのオリジンでもいいことを表す<code>"*"</code>があります。</p>
<p>ここで注目すべきことは、<strong>メッセージを他のオリジンに送ることもできる</strong>ということです。メッセージを送りつけるだけなら、同一オリジンポリシーに縛られずに送ることができるわけです。</p>

<h3>メッセージを受け取る</h3>
<p>さて、メッセージを送られたら、送られた側では当然受け取る仕組みが必要になります。それはやはりイベントです。メッセージを受け取った場合、windowで<dfn>messageイベント</dfn>が発生します。したがって、次のようにメッセージを検知できます。</p>
<pre><code>
<mark>window</mark>.addEventListener("<mark>message</mark>",function(e){
});
</code></pre>
<p>メッセージの中身を参照するのに使うのは当然<strong>イベントオブジェクト</strong>を使います。ここで、このmessageイベントのイベントオブジェクトを<strong>MessageEvent</strong>といいます。</p>
<p><a href="13_2.html">前回</a>の内容を覚えているでしょうか。EventSourceにおいてサーバーからのメッセージを受け取る時のイベントオブジェクトもMessageEventでした。同じですね。なので、メッセージの取得方法も前回と似ています。すなわち、送られてきたメッセージは<strong>dataプロパティ</strong>に入っています。</p>
<pre><code>
window.addEventListener("message",function(e){
  console.log("送られてきたメッセージは",e.<mark>data</mark>);
});
</code></pre>
<p>MessageEventには<strong>origin</strong>プロパティもありましたね。これはWeb Messagingの場合は、このプロパティでメッセージの送信元のページのオリジンを知ることができます。前回あったlastEventIdはServer-Sent Events用なので、今回は意味がありません。</p>
<p>もう一つ<dfn>sourceプロパティ</dfn>があり、これはメッセージの送信元のブラウジングコンテキストに対応するWindowオブジェクトが入っています。つまり、これを使えばメッセージを送ってきたページに対してメッセージを送り返すことができます。例えば返事を送り返す場合はこうですね。</p>
<pre><code>
window.addEventListener("message",function(e){
  e.<mark>source</mark>.postMessage("返信", e.<mark>origin</mark>);
});
</code></pre>
<p>ではここで、ここまでのをまとめた<a href="13_3_sample2.html">サンプル</a>を用意しました。ソースには簡単な解説を用意してあるあるので参考にして下さい。</p>
<p>次回はWeb Messagingの応用を紹介します。</p>

