<p>第四章のトピックは<b>文字列</b>です。第二章・第三章はDOMの話題でしたが、少し離れることにしましょう。</p>
<p>今回基礎的な<strong>文字列の操作</strong>について解説します。より詳しい説明が<a href="11_5.html">十一章第五回</a>にもあります。</p>

<h3>文字列の長さ</h3>
<p>ある文字列があるとき、その「長さ」を知りたいことがあると思います。長さとは、つまり文字数のことです。そういう方法はちゃんとあります。</p>
<pre><code>
var str = "abcde";
console.log(str.<dfn>length</dfn>);
</code></pre>
<p>このサンプルでは、変数strに<code>"abcde"</code>を代入し、その<dfn>length</dfn>というプロパティを見ています。「5」が表示されます。試しにこのstrの内容を変えてみると、表示されるlengthプロパティの中身もそれにあわせて変わるはずです。</p>
<p>つまり、文字列の長さを知るには、その文字列のlengthプロパティを使えばいいのです。今回の場合何の役に立つのかあまり分からないかもしれませんが、文字列処理の基本であり、たとえばinput要素に入力された文字列を処理するときなどに、役立つことがあります。ちなみに、これは数値です。</p>
<p>ちなみに、ここですごい人なら違和感を覚えるかもしれません。ここで、変数strに代入されている<dfn>"abcde"</dfn>は、<strong>プリミティブ値</strong>（<a href="1_2.html">一章第二回</a>）です。プリミティブ値なら、オブジェクトではないのだから、<strong>プロパティを持たない</strong>はずです。</p>
<p>それにもかかわらずプリミティブ値のプロパティを参照できているのにはまた特殊な事情があります。なかなか難しいので、今は解説しません（<a href="9_7.html">九章第七回</a>に説明があります）。不思議に思った人も、今はそういうものだと思っておきましょう。この先も文字列がプロパティ（あるいはメソッド）を持っているような解説が続きますが、まあそういうものなので気にしないようにしましょう。</p>

<div class="sidenote">
  <p>少し細かい話をすると、JavaScriptにおける文字列はUTF-16で符号化されています。つまり、文字列は16bit符号なし整数（UTF-16コードユニット）の列です。<small>（ただし、JavaScriptではUTF-16としては妥当でないコードユニット列を文字列として扱うこともできます。）</small></p>
  <p>UTF-16では、コードポイントがU+FFFF以下の文字はコードユニット1つで表されますが、それ以上のコードポイントを持つ文字はコードユニット2つ（サロゲートペア）で表されます。</p>
  <p>文字列のlengthプロパティはコードユニットの数を数えます。つまり、<strong>サロゲートペアで表される文字は2文字として数えられる</strong>ということです。これは意図していない動作となる恐れがあるので注意が必要です。</p>
  <pre><code>
    console.log("𠮷野家".length); // 4
  </code></pre>
  <p>この例では、文字列は3文字であるにも関わらず、<code>"𠮷野家"</code>のlengthプロパティは4です。これは、「𠮷」の文字がサロゲートペアで表される文字だからです。</p>
  <p>また、以降の説明で「何文字目」とか「文字列の位置」といった説明が出てくることがありますが、それは文字列をコードユニット列としてみたときの何番目かということであり、サロゲートペアまで考慮した文字列位置とは異なります。</p>
  <p>これらの問題に対処するにはES2015の新しい機能を使う必要があります。それは後々紹介することにします。</p>
</div>


<h3 id="anchor-indexof">文字列の検索</h3>
<p>ここでいう検索とは、文字列に、ある文字列が含まれているかどうかを調べるということです。次のサンプルを見てみましょう。</p>
<pre><code>
var str = "abcde";
var idx = str.<dfn>indexOf</dfn>("b");
console.log(idx);
</code></pre>
<p>変数idxに、<code>str.indexOf("b")</code>の戻り値を代入して、それを表示しています。1と表示されます。</p>
<p>このindexOfは、<strong>その文字列から、引数で指定した文字列を検索して、その位置を返します</strong>。</p>
<p>今回の場合、strは<code>"abcde"</code>で、そのうち引数の<code>"b"</code>は<strong>1文字目</strong>（JavaScriptでは、最初の文字が0文字目だから、aが0文字目、bが1文字目となります）なので、1が返されたというわけです。</p>
<p>では、もし検索した文字列が含まれていなかったらどうなのでしょう。</p>
<pre><code>
var str = "abcde";
var idx = str.<dfn>indexOf</dfn>("f");
console.log(idx);
</code></pre>
<p>この場合、strから<code>"f"</code>を検索していますが、fは含まれていません。そういう場合は<strong>-1</strong>が返されます。この性質から、ある文字列にある文字列が含まれているかどうかを調べるためにindexOfが利用されることも多くあります。</p>

<p>また、1文字ではない文字列も検索できます。</p>
<pre><code>
var str = "abcde";
var idx = str.<dfn>indexOf</dfn>("bcd");
console.log(idx);
</code></pre>
<p>この場合、strに<code>"bcd"</code>という文字列は含まれているので、その<strong>開始位置</strong>（先頭の文字の位置）である1が返されます。</p>

<h3>文字列から抜き出す</h3>
<p>文字列のうち指定した一部分だけを抜き出した文字列を取得することは、文字列に対する基本的な操作のひとつです。この方法はいくつかあります。</p>

<h4 id="anchor-slice-substring">slice・substring</h4>
<p>まず、<dfn>slice</dfn>を使う方法を紹介します。</p>
<pre><code>
var str = "abcde";
console.log( str.<dfn>slice</dfn>(1,4) );
</code></pre>
<p><code>"bcd"</code>が表示されます。1〜3文字目だけが抜き出されました。</p>
<p>ここで、この2つの引数は、抜き出しの<strong>開始位置</strong>と<strong>終了位置</strong>を表しています。開始位置は1、つまり1文字目だから<code>b</code>です。終了位置は4文字目だから、<code>e</code>の位置になります。</p>
<p>となるとbからeまでが抜き出されるように思えますが、実は<strong>終了位置の1つ手前</strong>まで抜き出されるようになっています。したがって、bからdまでが実際に抜き出されて、<code>"bcd"</code>になりました。終了位置を指定する場合、その位置の文字自体は含まれないということは往々にしてありますから、終了位置が出てきたらそれが何を意味しているのか注意しましょう。</p>
<p>ちなみに、抜き出すといっても、strから<code>"bcd"</code>が取り除かれるというわけではありません。sliceを使ったあともstrの中身は変わらず<code>"abcde"</code>です。ここでの抜き出しとはあくまで「指定した範囲の文字列を得る」ということです。</p>

<p>次に紹介するのは<dfn>substring</dfn>です。これの使い方はsliceと同様で、開始位置と終了位置を指定します。</p>
<pre><code>
var str = "abcde";
console.log( str.<dfn>substring</dfn>(1,4) ); // "bcd"
</code></pre>
<p>結果は同じです。</p>
<p>では、これらの違いはどこにあるかというと、<strong>引数に負の数を指定したとき</strong>に違いがでてきます。「-1文字目」とか「-2文字目」というような位置はありえませんので、負の数を指定された場合は特別な位置指定となります。負の数の扱い方がsliceとsubstringの違いです。</p>
<p>まず、substringは簡単で、負の数が渡されたとき、それは<strong>0ということにします</strong>。つまり、</p>
<pre><code>
str.substring(<mark>-2</mark>,2)
str.substring(0,<mark>-1</mark>)
str.substring(<mark>-100</mark>,3)
</code></pre>
<p>などは、</p>
<pre><code>
aaa.substring(<mark>0</mark>,2)
aaa.substring(0,<mark>0</mark>)
aaa.substring(<mark>0</mark>,3)
</code></pre>
<p>と同義になります。</p>

<p>それに対し、sliceの場合は、負の数が渡されたとき、文字数を<strong>後ろから数えます</strong>。例えば、</p>
<pre><code>
var aaa = "abcde";
console.log( aaa.slice(<mark>-3</mark>,5) );
</code></pre>
<p>の場合、後ろから3番目の文字が開始位置で、終了位置は5文字目です。</p>
<p>ただし、注意点があります。前から普通に数える場合最初の"a"は0番目であるのに対して、後ろから数える場合、最初の"e"は0番目ではなく<strong>1番目</strong>になるということです。理由は、-0というのは0と同じなので-0で"e"の位置を表すことはできないからですね。</p>
<p>つまり、-3で指定した開始位置は"c"の位置になるということです。従って、<code>"cde"</code>が返ります。</p>
<p>第2引数に負の数を指定した場合も同様に後ろから数えます。</p>
<p>sliceのほうがsubstringより機能が豊富であることから、sliceのほうがよく使われる傾向にあるようです。</p>

<p>ちなみに、sliceやsubstringの2つめの引数は<strong>省略できます</strong>。省略した場合、終了位置は文字列の一番最後になり、文字列の一番最後まで抜き出されます。これもよく使われます。</p>

<h4 id="anchor-charat">charAt</h4>
<p>1文字だけ抜き出す場合、もっと簡単なものがあります。それは<dfn>charAt</dfn>です。</p>
<pre><code>
var str = "abcde";
console.log( str.<dfn>charAt</dfn>(1) );
</code></pre>
<p>引数が1つありますね。簡単に、その引数で指定された位置の文字を返します。今回の場合、引数は1だから、1文字目、つまり<code>"b"</code>が返ります。</p>
<p>なお、文字と述べましたが、これは1文字だけからなる文字列のことです。</p>

<h3>メソッドの利用例</h3>
<p>それでは、これらを利用して、実際にどんなことができるか考えてみましょう。</p>

<h4>0詰め</h4>
<p>0詰めとは、例えば、数字を5桁に統一したいとき、4桁以下の数字は<code>"00025"・"01234"</code>のように先頭に0をつけて5文字にするというものです。</p>
<p>その性質上、もともとは数値でも、0詰めされてできたものは文字列になりますね。</p>
<p>よく行われるのは次の方法です。</p>
<pre><code>var num = 1234;		//0詰めする数字
var result = ("00000" + num).slice(-5);	//できた文字列
console.log(result);
</code></pre>
<p>変数resultに、0詰めされた文字列が入ります。3行目で今回解説したsliceが使われていますね。</p>
<p>最初に<code>"00000"</code>の後にnumをくっつけています。今回の場合、<code>"000001234"</code>となります。</p>
<p>その後、その文字列からsliceで抜き出しています。開始位置は-5で、終了位置は省略されているから、最後まで抜き出されます。開始位置が-5ということは、後ろから5文字めということです。そこから最後まで抜き出すから、結果として後ろから5文字を抜き出していることになります。</p>
<p>今回の場合、<code>0000<mark>01234</mark></code>の部分が抜き出されます。見事、0詰めされました。</p>
<p>0を5個つける理由は、0を5個つけておけば必ず5文字以上になるからです。</p>
<p>最後にsliceで5文字抜き出すから、5文字以上ないと困るわけですね。</p>
<p>以上が文字列の基礎の基礎です。次回は<b>正規表現</b>を用いた少し発展的な文字列操作を解説します。</p>

<h3 id="anchor-escape-sequence">エスケープシーケンス</h3>
<p>最後に、少しメソッドから離れて<b>エスケープシーケンス</b>について解説します。これは、文字列リテラルとして文字列を記述する際にソースコード中に書きにくい特殊な文字を表すための方法です。たとえば、次のように改行を含む文字列を表したいとします。</p>
<pre><code>
foo
bar
</code></pre>
<p>これは「foo（改行）bar」ということです。実は、文字列リテラル中に改行を含めることはできません。次のように書くのは文法エラーです。</p>
<pre><code>
var a = <mark>"foo
bar";
</code></pre>
<p>そこで、改行を表すための特別な記法が必要になります。それは、<code>\n</code>です。つまり、前述の文字列を表すには次のように文字列リテラルを記述すればよいです。</p>
<pre><code>
var a = "foo<mark>\n</mark>bar";
</code></pre>
<p>この文字列をconsole.logなどで表示してみましょう。<code>\n</code>が改行になっていることがわかるはずです。なお、ここで改行と呼んでいるのはLF (U+000A) です。</p>
<p>このように、<code>\</code>を使って特殊な文字を表す方法を<strong>エスケープシーケンス</strong>と読んでいます。</p>
<p>主なエスケープシーケンスを次にまとめます。</p>
<table>
  <tr>
    <th>エスケープシーケンス</th>
    <th>対応する文字</th>
  </tr>
  <tr>
    <td><code>\r</code></td>
    <td>CR (U+000D)</td>
  </tr>
  <tr>
    <td><code>\n</code></td>
    <td>LF (U+000A)</td>
  </tr>
  <tr>
    <td><code>\t</code></td>
    <td>タブ (U+0009)</td>
  </tr>
  <tr>
    <td><code>\\</code></td>
    <td>バックスラッシュ <code>\</code> (U+005C)</td>
  </tr>
  <tr>
    <td><code>\'</code></td>
    <td>シングルクォート <code>'</code> (U+0027)</td>
  </tr>
  <tr>
    <td><code>\"</code></td>
    <td>ダブルクォート <code>"</code> (U+0022)</td>
  </tr>
</table>

<p>後ろの2つは、<code>\'</code>で<code>'</code>を表し、<code>\"</code>で<code>"</code>を表せるということです。これは別にエスケープシーケンスを使う必要がないじゃないかと思うかもしれませんが、文字列リテラル中でクォーテーションマークを使いたい場合に必要になることがあります。例えば、次の文字列を表現したい場合を考えます。</p>
<pre><code>He said "foo."</code></pre>
<p>文字列中に<code>"</code>が含まれています。これは、次のように文字列リテラルで記述することができます。</p>
<pre><code>"He said <mark>\"</mark>foo.<mark>\"</mark>"</code></pre>
<p>ここでは、文字列中の<code>"</code>を<code>\"</code>としてエスケープシーケンスを利用することで、文字列リテラル自体の<code>""</code>と区別しています。これは、エスケープシーケンスを使わずに<code>"He said "foo.""</code>とすることはできません。なぜなら、文字列リテラルが<code>"He said "</code>までで終了していると解釈されてしまうからです。</p>
<p>ただし、この場合は文字列リテラルを囲う文字を<code>'</code>に変えて、次のようにしても解決できます。こちらのほうが見やすいため好むという人も多いようです。</p>
<pre><code>'He said "foo."'</code></pre>
<p>下から3つ目の<code>\\</code>も同様に、文字列リテラル中では<code>\</code>という文字はエスケープシーケンス用の特別な文字として扱われるため、<code>\</code>という文字自体を表現するために存在します。</p>

<h4>コードポイントによる指定</h4>
<p>もうひとつの形のエスケープシーケンスとして、コードポイントを指定する方法があります。全ての文字にはコードポイントと呼ばれる番号が定まっており、その番号で文字を指定する方法です。<small>（ただし、JavaScriptが扱うのはUnicodeなので、Unicodeに存在しない文字は表せません。）</small>
<p>コードポイントによる指定は、次のように<code>\u</code>に続けて16進数4桁でコードポイントを指定します。</p>
<pre><code>
"foo<mark>\u28ff</mark>bar"
</code></pre>
<p>コードポイントU+28FFに対応する文字は&#x28ff;なので、この文字列リテラルは<code>"foo&#x28ff;bar"</code>と書くのと同じ意味になります。世の中には変な文字もたくさんありますから、ソースコード中に直接書くと見難くなる場合などはこの方法で書くとよいでしょう。</p>

<div class="sidenote">
  <p>上でも説明したようにJavaScriptの文字列はUTF-16コードユニット列なので、サロゲートペアで表される文字はサロゲートペアのコードユニットを記述する必要があります。</p>
  <pre><code>"\ud842\udfb7" === "𠮷"</code></pre>
  <p>ただし、ES2015ではサロゲートペアではなくコードポイントを直接記述できる次のような記法が用意されています。</p>
  <pre><code>"<mark>\u{20bb7}</mark>" === "𠮷"</code></pre>
</div>
