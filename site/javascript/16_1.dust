<p>第十六章では、<b>ES2015</b>の解説をします。これはその名の通り、2015年に標準化された新しいECMAScript仕様を指します。今までに説明したES5までと比べても新しい機能、新しい文法などを備えています。なお、ECMAScriptというのはJavaScriptの言語仕様の名前です。なぜ素直にJavaScriptと言わないのかは歴史的経緯とかが色々あるのです。</p>
<p>つまりざっくり言えば、ES2015というのは最近JavaScirptに追加された新しい機能とか文法のことです。2015というだけあってこれはなかなかに近代的な文法などが含まれています。今どきはこれくらい分かっていないと中級者とは言えないでしょう。</p>
<p>なお、昔はES5の次のバージョンということで<b>ES6</b>と呼ばれていましたが、のちのちECMAScriptは年に1回バージョンアップされることになり、年の名前で呼ぶことになりました。そのため、ES2016、ES2017なども存在します。それは後々解説することにしましょう。</p>
<p>ES2015はES5から様々な機能追加が行われたなかなか大きなバージョンアップです。このページが最初に作られた段階（2014年）はES2015の機能はブラウザへの実装が徐々に進んでいるという段階でした。ES2015の機能の中でも特に早く利用可能になったのが今回紹介する<b>WeakMap</b>と<b>WeakSet</b>です。</p>
<p>実はWeakではないMapやSetもあるのですが、また今度紹介します。</p>

<h3>WeakMapとは</h3>
<p>WeakMapというのは、その名の通り弱いMapです。まずMapというのはなにかというと、<strong>keyに対して値を保存しておけるもの</strong>です。keyというのは<a href="14_2.html">第十四章のIndexedDBの説明</a>でもでてきましたが、要するに各データに名前（key）を付けて保存しておき、名前（key）を指定すると保存したデータが取り出せるというものです。ただし、今回の話は<a href="14_1.html">localStorage</a>や<a href="14_2.html">IndexedDB</a>のようにブラウザに保存しておける類のものではありません。プログラム中でデータを保持しておくのに利用するための単なるデータ構造です。</p>
<p>既に知っているものの中で今回紹介するWeakMapに近いのは、<em>ただのオブジェクト</em>です。</p>
<p>例えば、次のオブジェクトを見てみましょう。</p>
<pre><code>
var dict={
  "foo":"bar",
  "baz":5,
  "quux":null
};
</code></pre>
<p>このオブジェクトは、文字列<code>"foo"</code>に対して<code>"bar"</code>を、文字列<code>"baz"</code>に対して<code>5</code>を、文字列<code>"quux"</code>に対して<code>null</code>を関連付けるものであると考えることができます。もちろん。JavaScriptのオブジェクトはあとからプロパティを追加することができますから、あとからキーと値のペアを増やすことも可能です。</p>
<p>このように、プロパティをキーとすることで、オブジェクトに好きな値を保存しておくことができるのです。</p>
<p>しかし、この方法にはひとつ欠点があります。それは、<strong>キーに文字列しか使用できない</strong>という点です。これは、キーがそもそもプロパティの名前であることを考えれば当然ですね。<small>（注：ES2015で<a href="16_4.html">シンボル</a>が追加されたのでまた話は違ってくるのですが、今回は考えないことにします。）</small></p>
<p>そこで、この問題を解決するのがWeakMapなのです。WeakMapでは文字列などではなく、<strong>オブジェクトをキーとして使います</strong>。オブジェクトをキーとして使えるということは、WeakMapを使ってオブジェクトに対して別の値を対応付けることができるということです。</p>

<h3>WeakMapの使用</h3>
<p>それでは、実際にWeakMapを使ってみましょう。</p>
<p>WeakMapを使うには、WeakMapの新しいインスタンスを作ります。</p>
<p>作ったら、<dfn>set</dfn>メソッドで新しいキーと値を保存できます。第1引数にキー、第2引数に値です。また、<dfn>get</dfn>メソッドでキーに対応する値を得ることができます。</p>
<pre><code>
var wm = new <mark>WeakMap</mark>();

//キーにはオブジェクトを使用する
var key1={};

wm.<mark>set</mark>(key1, 100); //key1に100を関連付ける

console.log(wm.<mark>get</mark>(key1));  //100が表示される
</code></pre>
<p>注意すべきことは、上のサンプルを実行したあとに次を実行しても100は表示されないということです（対応する値がないことを示すundefinedがgetの返り値となります）。</p>
<pre><code>
console.log(wm.get(<mark>{}</mark>));
</code></pre>
<p>これは、<code>{}</code>に対応する値を得るということです。</p>
<p>さっきのサンプルではkey1に対して100を関連付けていて、key1は
<code>{}</code>
のはずなのに、なぜ次に
<code>{}</code>
に関連付けられた値を取得しようとしても存在しないということになるのでしょうか。</p>
<p>この答えを述べるならば、key1に入っている
<code>{}</code>
と次にgetの引数にした
<code>{}</code>
は別々のオブジェクトだからです。これは<a href="1_2.html">一章第二回</a>で説明したことが関わっています。</p>
<p>オブジェクトリテラル<code>{}</code>は「新しいオブジェクトを作って返す」というはたらきを持ちます。つまり、key1の中のオブジェクトと
<code>{}</code>
で返されたオブジェクトは、形は同じでも別々のオブジェクトなのです。WeakMapのキーとしてオブジェクトを用いる場合は、この意味で“同じ”オブジェクトをキーとする必要があります。上の例では、key1に入っているまさにそのオブジェクトでないと100を取り出すことはできません。なお、オブジェクトを<code>==</code>や<code>===</code>で比較すると同じオブジェクトであるときのみtrueになります。実際に<code>key1 === {}</code>などとするとfalseになりますね。</p>
</p>
<p>なお、WeakMapでkeyにできるのはオブジェクトのみです。プリミティブをkeyにしようとするとエラーになります。</p>

<p>さて、WeakMapには他にも3つメソッドがあります。1つ目は<dfn>has</dfn>です。これは引数としてキーを渡すと、そのキーに対する値がWeakMapに存在するか（setメソッドで登録されているかどうか）を真偽値で返します。存在しているならばtrueです。</p>
<p>2つ目は<dfn>delete</dfn>です。これは名前の通りで、引数にキーを渡すとそのキーに対応する値をWeakMapから削除します。</p>
<p>最後は<dfn>clear</dfn>です。引数なしで、WeakMap内の全ての値を消去します。</p>
<p>また、実はgetメソッドには第2引数を指定することができます。これはデフォルト値であり、対応する値が存在しなかった場合は第2引数の値が返されます。これを使うと、簡単な例ではいちいちhasメソッドを使わなくてもWeakMap内に値が存在しなかった場合の処理が書けるでしょう。</p>

<h3>WeakMapの意味</h3>
<p>さて、WeakMapが今までに比べて革新的なところは、やはり任意のオブジェクトに対して別の値を関連付けられるということです。</p>
<p>今まで、オブジェクトに対して値を関連づけたいならば、例えば適当なプロパティに保存しておくという方法がありました。つまり次のような感じです。</p>
<pre><code>
function saveValueInObject(obj,value){
  obj.<mark>_myvalue</mark>=value;
}
function getValueFromObject(obj){
  return obj.<mark>_myvalue</mark>;
}
</code></pre>
<p>この例では、オブジェクトに対して_myvalueというプロパティを勝手に作り、そこに保存しています。プログラムの他の部分で_myvalueを使っていなければ正しく保存できていることになりますが、万一_myvalueというプロパティが意味を持つようなオブジェクトがあれば、それを勝手に書き換えることになり思わぬ動作をする原因となります。</p>
<p>また、for-in文や<a href="11_4.html">Object.keys</a>を使っている場合も変な動作になる可能性が高いですね。これについては<a href="11_4.html#object-defineproperty">Object.defineProperty</a>などでenumerable属性がfalseのプロパティを作れば回避できますが、Object.getOwnPropertyNamesを使えばやはり見つけることができるので問題ないとはいえません。</p>
<p>他にも、組み込みオブジェクト（もともと定義されているオブジェクト）に対して勝手にプロパティを追加するのも望ましくありません。例えば、配列をはじめとするJavaScriptの言語仕様に存在するオブジェクトや、ノードのようなDOMオブジェクトが組み込みオブジェクトに該当します。これらに追加情報を関連付けたいときもWeakMapは活躍します。もちろん、WeakMapはどんなオブジェクトでもkeyとして利用できるので、関数やRegExp（正規表現オブジェクト）もOKです。</p>

<p>このように、keyとなるオブジェクトを汚さずに情報を付加できるのがWeakMapの1つの利点です。もう1つの利点は、関連付けた値が外部から見えないということです。</p>
<p>あるオブジェクトに対して関連付けた値は、当然WeakMapの中に保存されていると考えられます。ということは、当のWeakMapを持っていないと関連付けた値が分からないということになります。オブジェクトにプロパティとして勝手に付加する方式では、外部からそれを書き換えられてしまう可能性もあるのです。WeakMapならば、それを持っている自分しか値を読んだり書き換えたりすることができず、安全です。</p>
  
<h3>WeakMapの特徴</h3>
<p>さて、実はただのMapもあるという話をしましたが、実はこのようにキーと値を対応付ける機能をもつものをMapというので、いままでの説明で特にWeakな部分がありませんでした。</p>
<p>それではいったい何が弱くてWeakMapなのかというと、実は<strong>参照が弱い</strong>のです。</p>
<p>より詳しく言うと、WeakMapからキーのオブジェクトへの参照が弱いのです。</p>
<p>これを解説するには、<strong>ガベージコレクション</strong>の話をしなければなりません。まず、オブジェクトは突き詰めるとメモリ上にあります。つまり、オブジェクトの情報を覚えておくにはメモリが必要だということです。</p>
<p>ところで、次のサンプルを考えてみましょう。</p>
<pre><code>
var a = {
  foo:3,
  bar:5
};

a={};
</code></pre>
<p>最初に変数aにオブジェクト（オブジェクトAとしましょう）を代入しており、直後に別のオブジェクト（オブジェクトB）を代入しています。</p>
<p>オブジェクトAは当然メモリ上に作られます。その後、オブジェクトBもメモリ上に作られます。</p>
<p>2回目の代入ではオブジェクトBがメモリに入ります。すると、メモリ上のオブジェクトAはメモリから消さなければなりません。なぜなら、オブジェクトAはもう使われていないからです。より具体的には、<em>オブジェクトAへの参照が存在しなくなった</em>からです。参照が存在しないというのは、ざっくり言うとオブジェクトAがどの変数にも入っていないということです。これはすなわち、JavaScriptプログラムからオブジェクトAにアクセスする方法がなくなったということです。</p>
<p>このような場合、もう二度と使われないオブジェクトAをいつまでもメモリ上に取っておくのはメモリの無駄なので、自動的にメモリから破棄されます。このように、もう使われなくなったオブジェクトをメモリ上から消去する働きを<b>ガベージコレクション</b>といいます。</p>
<p>では、次のサンプルはどうでしょう。
<pre><code>
var a = {
  foo:3,
  bar:5
};

<mark class="ins">var wm = new <mark>WeakMap</mark>();
wm.set(a,100);</mark>

a={};
</code></pre>
<p>オブジェクトAをWeakMapのキーとして100を保存したあと、aにオブジェクトBを代入しました。</p>
<p>普通に考えると、wmの中にオブジェクトAをキーとした値が入っているので、getメソッドにオブジェクトAが渡されれば対応する値を返さなければいけません。そのためには、WeakMapはオブジェクトAを覚えておく必要があります。つまり、WeakMapの内部にオブジェクトAへの参照がなければいけません。そうでないと、getメソッドに渡されたオブジェクトがオブジェクトAと一致するかどうか調べられないからです。</p>

<p>しかしこのサンプルでは、変数aからオブジェクトAへの参照が無くなったことで、オブジェクトAへの参照はWeakMapの内部にしかない状態になりました。この場合、さっきと同じ理屈で、プログラムからオブジェクトAを取得する方法は無くなりました。なので、WeakMapのgetメソッドにオブジェクトAが渡されることはもう二度とないでしょう。ということは、WeakMapがオブジェクトAを覚えていても無駄ということです。WeakMapは偉いので、このように覚えていても無駄なオブジェクトは忘れてくれます。具体的にいうと、この場合オブジェクトAはガベージコレクションの対象となります。もちろん、WeakMapの中にオブジェクトAをkeyとして保存されていたデータも捨てられます。</p>
<p>このように、WeakMap内部にまだオブジェクトへの参照が存在していても、他のところに全くない場合はガベージコレクションの対象になります。言い方を変えると、WeakMap内部からオブジェクトへの参照はガベージコレクションを妨げないのです。このような参照を<em>弱い</em>参照といいます。これがWeakMapという名前の由来であり、WeakMapの大きな特徴でもあります。WeakMapのこの特性がなければ、使われなくなったオブジェクトがずっとメモリに残り続ける可能性があるのです。</p>
<p>この特性が役に立つ場面は結構ありますが、そんなに深く考えなくてもWeakMapはオブジェクトに対して値を関連付けられる便利なものとして使えます。</p>

<p>ちなみに、Weakではない普通のMapは後々紹介しますが、これはWeakMapとは異なり参照は弱くありません。つまり、同じ状況になった場合でもMap内部にオブジェクトへの参照が残っている限りガベージコレクションの対象とはなりません。これは、Mapが「キーとなっているオブジェクトの一覧」を返すメソッドなどを持っているため、Map内部にしかオブジェクトへの参照が無くなってもそれを外部から取得する手段があるからです。</p>
<p>逆に言えば、参照を弱くするという目的のためにこれらのメソッドをMapから削ったのがWeakMapであるということです。</p>


<h3>WeakSet</h3>
<p>さて、次のWeakSetについてですが、そもそもSetとは<b>集合</b>のことです。実はWeakSetは、オブジェクトの集合を表すものです。</p>
<p>一般に集合は、ある元が与えられたときにそれが集合に含まれるかどうかを判定できなければいけません。WeakSetは、集合にオブジェクトを追加するメソッド(add)、集合からオブジェクトを除去するメソッド(delete)、あるオブジェクトが集合に含まれるかどうか判定するメソッド(has)を持ちます。他に、集合に含まれるオブジェクトを全て除去するclearメソッドも持ちます。具体例を以下で見てみましょう。</p>
<pre><code>
var key={};
var ws=new <mark>WeakSet</mark>();

console.log(ws.has(key)); //wsにkeyは含まれないのでfalse

ws.add(key);

console.log(ws.has(key)); //さっき追加したのでtrue

console.log(ws.has({}));  //false
</code></pre>
<p>つまり、WeakSetはオブジェクトに対して「集合に含まれる」という情報を関連付けるものであると考えられます。こう考えると、WeakSetはWeakMapの機能を削減したバージョンであると考えられます。WeakMapはオブジェクトに任意の情報を紐付けることができるのに対し、WeakSetは「集合に含まれる」ということを示すのみです。</p>
<p>また、WeakSetには、WeakMapと同じ理由により「含まれるオブジェクトの一覧」を得る方法はありません（ふつうのSetにはあります）。</p>
<p>WeakSetはWeakMapに比べると使い所がないかもしれませんが、機会があれば使ってみましょう。</p>

