<p>次に、前回のFile APIと関連するところもある<strong>Drag and Drop API</strong>（略して<b>DnD API</b>）を紹介します。名前から分かるように、これは<strong>ドラッグ &amp; ドロップ</strong>に関するAPIです。</p>
<p>しかし、ドラッグ&amp;ドロップといっても、「ページ内の要素をつかんで自由に移動させられる」とかそういうのとは少し違います。今回は、ドラッグ（つかんで移動）してドロップ（離す）するということですから、途中の過程ではなく「どこからどこまで何を移動したか」ということを大事にします。</p>

<h3>ドラッグできる要素を作る</h3>
<p>とはいえ、今回つかむことができるのはやはり<b>要素</b>です。ある要素をドラッグできることを示すためには、HTML5の<strong>draggable属性</strong>を使います。</p>
<p>ドラッグできるようにしたい要素には、<code>draggable="true"</code>という属性をつけます。単純に、trueならドラッグできて、falseならドラッグできないということです。</p>
<p>しかし、考えてみるとcheckedみたいに<b>論理属性</b>にして、draggable属性があればドラッグできる、ないならドラッグできないというようにすればいいと思うかもしれませんが、そうもいきません。というのも、a要素やimg要素はもともとドラッグできるからです。そういう要素に対してドラッグできないということを明示するためには<code>draggable="false"</code>とします。</p>
<p>実際にやってみたのが<a href="12_6_sample.html">サンプル1</a>です。ドラッグできる要素とできない要素の違いを確かめてください。</p>

<h3>ドラッグ先を作る</h3>
<p>ところで、このままだと要素をつかむことができても、それをドロップする場所がありません。ということで、ドロップする場所を作りましょう。</p>
<p>それにかかわるのが<dfn>dragenterイベント</dfn>です。これは、ドラッグしながら他の要素の上にさしかかったときに発生するイベントです。普通、ある要素の上にさしかかったら、その要素がドロップ先として認識されます。ところが、このdragenterイベントは面白い<b>デフォルトアクション</b>を持っています。デフォルトアクションというのは以前解説したように、「そのイベントが発生した場合にデフォルトで起こる動作」です。例えばa要素をクリックしたならばリンク先に飛ぶという動作が発生しますね。</p>
<p>それで、dragenterイベントのデフォルトアクションは「ドロップ先をbody要素に変更する」ということです。すなわち、dragenterイベントが発生すると、どこにマウスを持って行っても全部body要素にドロップした扱いになってしまいます。</p>
<p>DnD APIを使ってやりたいことは、やっぱり「これをここにドロップしたらこの処理をする」というようなことでしょう。ですから、どこに置いてもbody要素にドロップした扱いになるのはちょっと困ります。そこで、dragenterイベントのデフォルトアクションを無効にする必要があります（これを、イベントをキャンセルするといいます）。イベントをキャンセルするには<a href="3_5.html#anchor-preventdefault">preventDefault</a>を使うのでしたね。</p>
<p>さらに面倒なことに、実はもうひとつキャンセルすべきイベントがあります。それは<dfn>dragoverイベント</dfn>です。 これについては、<strong>ドラッグオペレーション</strong>というものが関係しています。ドラッグオペレーションとは、そのドラッグ&amp;ドロップにどのような効果があるのかを示す値であり、以下の4種類があります。</p>
<dl>
  <dt>copy</dt>
  <dd>データがコピーされます。</dd>
  <dt>link</dt>
  <dd>データのリンクが張られます。</dd>
  <dt>move</dt>
  <dd>データが移動します。</dd>
  <dt>none</dt>
  <dd>何も起きません。</dd>
</dl>
<p>このドラッグオペレーションがどうなっているかによって、ドラッグ時の表示も変わってきます（親切なブラウザならば）。</p>
<p>ドラッグし始めた段階では、最初は<code>"none"</code>にセットされています。実はこのままだと、ドロップしても何も起こりません。</p>
<p>dragoverイベントは、dragenter同様にマウスが上に差し掛かったときに発生します。そのため、このタイミングでドラッグオペレーションを設定してやることで、その要素にドロップしたときの動作を示すことができます。ただし、後述しますが、実際にドロップしたときの動作はやはりJavaScriptで記述するので、ドラッグオペレーションには表示以上の意味はそんなにありません。しかし、値が<code>"none"</code>になっている場合はドラッグ&amp;ドロップ自体が無効になってしまうので、何か他の値にセットする必要があります。</p>
<p>その方法ですが、dragenter,dragoverなどのDnD APIに関係するイベントでは、そのイベントオブジェクトは<b>DragEvent</b>といい、<strong>dataTransfer</strong>プロパティを持ちます。これを<b>DataTransfer</b>オブジェクトといい、ドラッグ&amp;ドロップに関するさまざまな情報を管理します。</p>
<p>さて、DataTransferオブジェクトは<dfn>dropEffect</dfn>プロパティを持ち、これに代入することでドラッグオペレーションを設定できます。つまり、こういうことですね。</p>
<pre><code>
//elmは適当なHTMLElementとする
elm.addEventListener("<mark>dragover</mark>",function(e){
  e.<mark>dataTransfer</mark>.<mark>dropEffect</mark> = "copy";
});
</code></pre>
<p>ところで、さっきdragoverはキャンセルする必要があると述べました。それは、当然ながらdragoverのデフォルトアクションに理由があります。</p>
<p>dragoverのデフォルトアクションは「ドラッグオペレーションを<code>"none"</code>にする」ということなのです。</p>
<p>こんなデフォルトアクションがあっては、いくらこちらで書き換えてやっても意味がありません。そこで、dragoverをキャンセルしてやります。つまりこうです。</p>
<pre><code>//elmは適当なHTMLElementとする
elm.addEventListener("<mark>dragover</mark>",function(e){
  e.<mark>dataTransfer</mark>.<mark>dropEffect</mark> = "copy";
  <mark class="ins">e.preventDefault();</mark>
});
</code></pre>

<p>ここまでを反映した<a href="12_6_sample2.html">サンプル2</a>を見ると、なんとなくドロップに成功しそうな感じになっているのが分かるとおもいます。いい感じのブラウザ（Chromeとか）だと、ドロップ可能なdiv要素の上にさしかかったときのみマウスカーソルが変わるはずです。ドロップ可能なdiv要素を出るとカーソルが戻る理由は、他の要素（多分body要素）のdragoverイベントが発生してドラッグオペレーションが<code>"none"</code>に戻るからです。</p>

<h3>データを送る</h3>
<p>さて、ドロップはできるようになりましたが、ドロップしたからには何か動作を起こしたいものです。そこで、<strong>dropイベント</strong>を使います。これは、要素に対して何かがドロップされたときにそこで発生するイベントです。</p>
<p>当然ながら、イベントオブジェクトのtargetプロパティはドラッグ先の要素です。そうなると、そこでさらに問題が発生します。それは、<strong>ドラッグされたほうの要素はどうやって調べるのか</strong>です。</p>
<p>実は、要素自体は調べません。ここで登場するのが、先ほどのdataTransferです。このdataTransferはdropEffectを設定できるだけではなく、データを格納しておくことができるのです。</p>

<p>ドラッグ&amp;ドロップにおけるデータの流れは、「ドラッグされる側がdataTransferにデータを格納する」→「ドロップされたとき（dropイベント）にdataTransferからデータを取り出す」ということになります。</p>
<p>では、「ドラッグされる側がdataTransferにデータを格納する」はどのようにすればいいかというと、ここで新しいイベント<dfn>dragstart</dfn>が登場します。これは当然ながら、ドラッグされる側の要素（<code>draggable="true"</code>の要素）で発生するイベントです。dragstartからも当然dataTransferが利用でき、dataTransferに書き込むことができます。</p>

<p>dataTransferは<dfn>setData</dfn>というメソッドを持っています。第一引数が<b>フォーマット</b>の文字列、第二引数がデータの文字列です。</p>
<p>フォーマットというのは、格納されるデータがどんなデータが判別するための文字列なので、わかればいいということで自由に指定していいです。ただし、<b>MIMEタイプ</b>の利用が推奨されます。</p>
<p>例えば、今回データは文字列なので<code>"text/"</code>から始まるとして、普通の文字列は<code>"text/plain"</code>というタイプになります。また、この部分には<code>"x-"</code>から始まる自由な文字列を設定できるので、例えば<code>"text/x-mydata"</code>とかです。</p>
<p>dataTransferには複数のデータを格納することができますが、同じフォーマットのものは複数格納できません。</p>

<p>さて、具体的にやってみましょう。</p>
<p>例えばさっきの<a href="12_6_sample2.html">サンプル2</a>をもとにして、div要素のテキストをドラッグ先に表示してみるというサンプルを作ってみます。</p>
<p>まず今回draggableなdiv要素は3つあるので、ひとつひとつでdragstartイベントを監視するのではなく、documentあたりでまとめて監視してみましょう。</p>
<pre><code>
<mark>document</mark>.addEventListener("<mark>dragstart</mark>",function(ev){

});
</code></pre>
<p>そして、今回はdiv要素のテキスト、すなわちtextContentをdataTransferに入れてあげましょう。</p>
<pre><code>
<mark>document</mark>.addEventListener("<mark>dragstart</mark>",function(ev){
  <mark class="ins">ev.<mark>dataTransfer</mark>.<mark>setData</mark>("text/plain",ev.target.textContent);</mark>
});
</code></pre>
<p>今回は単純に、データの種類は<code>"text/plain"</code>としました。ただのテキストデータなら<code>"text/plain"</code>としておいて損はないでしょう。</p>
<p>これでdragstart側の処理は終了です。次に、ドロップされた側（dropイベント）の処理です。</p>
<p>こっちも同じようにaddEventListenerでイベントを付加してもいいのですが、面倒なので<code>ondrop="drop(<mark>event</mark>)"</code>のようにしてdropという関数を作ってそれに渡すことにしましょう。突如でてきたeventという変数は、<a href="3_5.html">三章第五回</a>で解説したようにイベント属性を使った場合のイベントオブジェクトです。</p>
<p>そして肝心のdrop関数においては、dataTransferからデータを取得します。これは、<dfn>getData</dfn>メソッドを使います。引数にフォーマット文字列を渡すと対応するデータが帰ってきます</p>
<pre><code>
function drop(ev){
  var data = ev.<mark>dataTransfer</mark>.<mark>getData</mark>("text/plain");
}
</code></pre>
<p>これを実際にやってみたのが<a href="12_6_sample3.html">サンプル3</a>です。「div要素1」や「div要素2」などを一番下のdiv要素にドラッグ&amp;ドロップすると、そのとおりに文字が変化することが確認できるでしょう。ドラッグ&amp;ドロップの結果が目に見えて現れるようになったので面白いですね。</p>
<p>なお、dropイベントでも最後にpreventDefaultしているのが分かると思います。これは、（2014年7月現在）Firefoxがドロップ後にページ遷移してしまうので、それを防ぐ目的があります。</p>

<p>さて、今回はドラッグ&amp;ドロップによって受け渡したデータはtextContentでしたが、同様にしてさまざまなデータを渡すことができるでしょう。応用して、機会があったら試してみましょう。</p>

<h3>画像のドラッグ&ドロップ</h3>
<p>上で、「img要素はもともとドラッグ&amp;ドロップ可能である」といいました。実は、img要素がドラッグされる場合自動的にdataTransferに<em>画像のURL</em>（具体的にはsrc属性の内容）が格納されます。その際のフォーマットは<code>"text/uri-list"</code>です。ただし、複数のimg要素が同時にドラッグされている場合もあります。そのようなときは、全てのURLが改行で区切られた文字列が入っています。</p>
<p>ということで、このことを用いて画像がドロップされてきたらそれを表示してみるというサンプルを作ってみました。<a href="12_6_sample4.html">サンプル4</a>です。</p>
<p>このサンプル中では<a href="11_5.html#anchor-split">split</a>メソッドや<a href="11_1.html#anchor-forEach">forEach</a>メソッドを使っています。忘れた方はぜひ戻って復習しましょう。</p>
<p>ちなみに、もうひとつもともとドラッグ&amp;ドロップ可能な要素としてa要素がありました。実はa要素の場合も、そのリンク先のURL（href属性）が<code>"text/uri-list"</code>で入っています。

<h3>テキストコントロールへのドロップ</h3>
<p>デフォルトでドラッグ可能なのがimg要素とa要素でした。実は、デフォルトでドロップ可能な要素も存在します。それはtextarea要素およびinput要素（<code>type="text"</code>の場合）です。</p>
<p>実は、<code>"text/plain"</code>のデータがdataTransferに入った状態でこれらの要素にドロップされると、その内容が入力されます。これも<a href="12_6_sample5.html">サンプル5</a>を用意しましたので、試してみてください。</p>
<p>この特徴のために、何か変なデータをdataTransferに入れる場合でそれが適切なテキスト表現を持つならば、<code>"text/plain"</code>のデータも一緒に入れてあげるのが親切です。</p>

<h3>ドラッグ&amp;ドロップに関わるイベントのまとめ</h3>
<p>ここまでの話で、ドラッグ&amp;ドロップの制御は主にイベントを通して行われることが分かったと思います。ドラッグ&amp;ドロップ時に発生するイベントは、実は今まで紹介したほかにもいくらかあります。ここでは一連の流れの中で発生するイベントをまとめて解説します。</p>
<p>まず、ドラッグ可能な要素をマウス等でつかんでドラッグ開始した時点で、その要素で<b>dragstart</b>イベントが発生します。これは先に紹介した通りですね。dragstartをキャンセルした（preventDefaultでデフォルトアプションを無効化）した場合はその要素はドラッグできません。</p>
<p>ドラッグ中、ドラッグ先（マウス等の真下にある要素）が変わるたびに、ドラッグ先の要素で<b>dragenter</b>イベントが発生します。このイベントで処理すべきことは先に解説した通りで、ドロップを受け入れるにはdragenterイベントをキャンセルする必要があります。</p>
<p>また、実はdragenterと対になるイベントとして<b>dragleave</b>イベントが存在します。これは、ドラッグ先が移り変わった場合に移動前の要素で発生するイベントです。dragenterとdragleaveの関係は<a href="3_6.html">mouseoverとmouseout</a>の関係に近く、基本的に2つのイベントは同時に発生します。実は、dragleaveイベントのイベントオブジェクトのrelatedTargetプロパティは移動先の要素を示しています。

<p>実は、ドラッグを続けている間、ドラッグされている要素では<b>drag</b>イベントが発生し、ドラッグ先の要素では<b>dragover</b>イベントが発生します。これらのイベントは、ドラッグされている最中、一定時間ごとに何度も発生するイベントです。ブラウザにもよりますが、1秒に数回程度のペースで発生します。先に述べたようにdragoverはキャンセルしなければドロップを受け入れられません。一方、dragイベントはキャンセルする必要はありません。逆に、dragイベントをキャンセルした場合はドラッグが中断されます。ドラッグを強制的に止めたい場合はdragイベントをキャンセルしましょう。</p>

<p>そして、ドラッグが終了したときにドロップ先の要素で<b>drop</b>イベントが発生します。ただし、前述のdropEffectが<code>"none"</code>の場合など、ドロップが受け入れられない状況でドラッグが終了した場合はドロップ扱いにならず、dropイベントは発生しません。</p>
<p>また、ドラッグが終了した場合は（ドロップに成功したかどうかに関わらず）<b>dragend</b>イベントがドラッグされている要素で発生します。</p>

<p>まとめると、掴まれてドラッグされる要素では<b>dragstart</b>→<b>drop</b>→<b>drop</b>→……→<b>drop</b>→<b>dragend</b>というようにイベントが発生します。一方、ドロップ先の要素は移り変わりますが、各要素は<b>dragenter</b>→<b>dragover</b>→<b>dragover</b>→……→<b>dragover</b>→<b>dragleave</b>の流れとなります。</p>
<p>他にdragexitというイベントもありますが、これはdragleaveと似ているものの存在理由がよく分からず、使われる機会はないのではないかと思います。</p>

<p>イベントに関してもうひとつ注意すべき点は、セキュリティ上の理由から、dataTransfer内のデータにアクセスできるのは<b>dragstart</b>イベントと<b>drop</b>イベント（すなわち、ドラッグの開始時と終了時）に限られるという点です。ドラッグの途中（例えば<b>dragover</b>イベント）でデータを読めてしまうと、関係ないドラッグ物がたまたまブラウザの上を通った場合に読まれてしまうというようなセキュリティ上のリスクがあります。</p>

<p>やや長くなりましたが、今回はページ内のドラッグ&amp;ドロップを扱う方法を説明しました。実は次回も引き続きドラッグ&amp;ドロップに関わる話です。</p>
