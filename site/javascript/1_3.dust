<p>今回はオブジェクトの扱い方について、配列のコピーを例にとって説明します。前回説明したように、オブジェクトを正しく扱うにはその特徴を正しく理解する必要があります。今回は練習問題みたいなものなので、ぜひ理解して次に進んでください。</p>

<h3>配列のコピーとは</h3>
<p>配列のコピーとは、読んで字のごとく、配列を複製することです。</p>
<p>しかし、前回解説した通り、配列のオブジェクトの一種なので、以下のようにしただけでは、結局同じ配列が複数の変数に入っている状況になります。</p>
<pre><code>var a = [0,1,2,3,4];
<mark>b=a</mark>;
a[5]=5;
alert(a);
alert(b);</code></pre>
<p>このコードでは、変数bにaを代入してからaを変更すると、bの中身も同じように変更されてしまっています。これは、aとbに入っているのが同じオブジェクトだからです。</p>
<p>そこで、ちゃんと別のオブジェクトとして新しい配列を作らないと、配列をコピーしたとはいえません。</p>
<p>今回は、ちゃんと新しいオブジェクトを作って配列をコピーしてみましょうという、今までの知識を利用した演習的な回です。</p>
<p>とりあえず、配列をコピーする関数を作りましょう。引数がコピー元の配列で、戻り値が複製された配列というようにします。</p>
<pre class="line-numbers"><code>function copyArray(arr){
}</code></pre>
<p>「copyArray」が関数名で、引数が「arr」ですね。「Array」とは、配列のことです。ちなみに、関数呼び出しのときに引数としてオブジェクトを渡した場合も、オブジェクトはコピーされません。渡されたのと<em>同じオブジェクト</em>が引数変数に入ります。</p>
<p>正しく配列のコピーを実装するには、新しい配列を作る必要があります。まずはとりあえず新しい配列を作りましょう。新しい配列を作るには、<code>new Array()</code>のようにするか、配列リテラルを使えばよいのでした。配列リテラルを使うほうが一般的ですから、ここでもそれを使うことにします。</p>
<pre class="line-numbers" data-line="2"><code>function copyArray(arr){
  var newarr = [];
}</code></pre>
<p>結論からいうと、この新しい配列に要素を1つずつコピーしていけばいいのです。まず、配列の要素1つずつに処理するときはどのようにしましたか？　そうです。繰り返しの構文を使います。</p>
<pre class="line-numbers" data-line="3-4"><code>function copyeArray(arr){
  var newarr = [];
  for(var i = 0;i&lt;arr.length;i++){
  }
}</code></pre>
<p>このようにfor（やwhile）を使うのでした。この形で、iが0から最後の要素の添字まで増加するのを利用してひとつずつ処理します。</p>
<p>処理の中身は簡単です。元の配列のその番号の要素を、新しい配列の同じ番号の要素に代入するだけです。</p>
<pre class="line-numbers" data-line="4"><code>function copyArray(arr){
  var newarr = [];
  for(var i = 0;i&lt;arr.length;i++){
    newarr[i] = arr[i];
  }
}</code></pre>
<p>最後に、できた配列を戻り値として返します。</p>
<pre class="line-numbers" data-line="6"><code>function copyArray(arr){
  var newarr = [];
  for(var i = 0;i&lt;arr.length;i++){
    newarr[i] = arr[i];
  }
  return newarr;
}</code></pre>
<p>できたら、実際に使ってみましょう。</p>
<pre><code>function copyArray(arr){
  var newarr = [];
  for(var i = 0;i&lt;arr.length;i++){
    newarr[i] = arr[i];
  }
  return newarr;
}
var a = [0,1,2,3,4];
alert(a);
var b = copyArray(a);
alert(b);

a[5]=5;
alert(b); </code></pre>
<p>アラートが3回表示されます。</p>
<p>まず最初にcopyArray関数をつくり、次の行でaに[0,1,2,3,4]を代入しています。</p>
<p>そして、次の行でそのaを表示します。ちなみに、アラートで配列変数を直接表示すると、丁寧に要素が「<code>,</code>」で区切られて表示されます。</p>
<p>そして、次の行でbにcopyArray関数でaと同じ配列を代入しています。アラートでbを表示すると、正常にコピーされていることがわかります。</p>
<p>その後、a[5]に5を代入しています。この時点でaは、<code>[0,1,2,3,4,5]</code>になることが分かると思います。その後bを表示すると、aを変えてもbには影響がないことが分かります。</p>
<p>copyArray関数は内部で作成された新しい配列を返しますから、変数bに入るのは明らかにaとは別のオブジェクトです。</p>

<p>copyArrayを使わない以下の場合と比べてみましょう。</p>
<pre><code>function copyArray(arr){
  var newarr = [];
  for(var i = 0;i&lt;arr.length;i++){
    newarr[i] = arr[i];
  }
  return newarr;
}
var a = [0,1,2,3,4];
alert(a);
<mark class="ins">var b = a;</mark>
alert(b);

a[5]=5;
alert(b);</code></pre>
<p>のようにした場合、bにはaと<em>同じ</em>オブジェクトが代入されるだけです。</p>
<p>その結果、a[5]に5を代入したときに、bを表示してもaへの変更が反映されてしまっています。aとbは同じオブジェクトを指しているのだから、当然のことです。</p>

<p>今回はcopyArray関数を作ることを通してオブジェクトの扱い方を見ました。オブジェクトを作成するとか、オブジェクトが同じであるとかいう概念を理解することが肝心です。</p>

<div class="sidenote">
  <p>余談ですが、今回やったような配列のコピーは、ES2015という比較的新しい記法で次のように書けます。</p>
  <pre><code>
    var b = [...a];
  </code></pre>
  <p>これで<code>var b = copyArray(a);</code>と同じ意味になります。</p>
  <p>昔（最初のこのページを書いたとき）はこんなの無かったのですが、便利な世の中になりましたね。</p>
</div>
<div class="sidenote">
  <p>余談その2ですが、今回実装したcopyArray関数では、配列の各要素を<code>newarr[i] = arr[i];</code>により行っています。懸命な読者はお気づきかもしれませんが、もし<code>arr[i]</code>がオブジェクトだったら、それと同じオブジェクトが新しい配列に入ることになります。</p>
  <p>つまり、配列を表面上コピーしても、その中身のオブジェクトは同じであるということです。これが良いのか悪いのかは、場合によりけりです。中身のオブジェクトも全て新しく作るような複製も可能です。いわゆる再帰関数を作ることになるでしょう。少し難しいですが、興味があれば挑戦してみてください。</p>
</div>

<!--
<h4>多次元配列</h4>
<p>ここからはさらに応用的な話です。実は、上で解説した配列のコピーですが、まだ完璧ではない部分があります。上の例では、copyArrayに渡される配列は<code>[0,1,2,3,4]</code>のように、個々の要素は数値、つまりプリミティブであるものでした。</p>
<p>もし配列の要素にプリミティブではなくオブジェクトが代入されていたらどうでしょうか。copyArray関数において、もとの配列の各要素を新しい配列にコピーする部分は、<code>newarr[i] = arr[i];</code>となっています。これはただの代入ですから、もし<code>arr[i]</code>がオブジェクトだったら、それと同じオブジェクトが<code>newarr[i]</code>に入ることになります。まあ、それで困るかどうかは場合次第ですし、オブジェクトのコピーは配列ほど簡単ではないのでここでは解説しません。</p>
<p>しかし、配列の要素にまた<strong>配列</strong>が代入されているという場合があります。これくらいは対処したいものです。ちなみに、このように配列の要素にまた配列が代入されているものを、<dfn>多次元配列</dfn>ということがあります。</p>
<pre><code>var a = [
  [0,1,2],
  [3,4,5],
  [6,7,8]
];

alert(a[0][1]);
alert(a[2][0]); </code></pre>
<p>このサンプルでは、1〜5行目でaに配列を代入しています。全体が<code>[ 〜 ]</code>で囲まれているのが分かります。しかし、そのひとつひとつの要素ですが、<code>[0,1,2]</code>が0番目の要素、<code>[3,4,5]</code>が1番目の要素、<code>[6,7,8]</code>が2番目の要素となっています。今回は分かりやすく改行を入れています。</p>
<p>これらの要素もそれぞれ配列であることが分かります。つまり、配列の要素がまた配列というわけです。</p>
<p>それをアラートで表示するわけですが、なんと添字が2個ついています。</p>
<p><code>a[0][1]</code>の場合、<strong>左から処理されます</strong>。まず、<code>a[0]</code>が処理されます。これは、<code>[0,1,2]</code>の配列でしたね。つまり、<code>a[0][1]</code>は「（[0,1,2]の配列への参照）<code>[1]</code>」のようになり、<code>[0,1,2]</code>の1番目の要素を表しています。つまり1ですね。</p>
<p>同様に<code>a[2][0]</code>の場合、<code>a[2]</code>が<code>[6,7,8]</code>で、その0番目の要素ですから6ということになります。</p>
<p>ちなみに、「配列の中の配列の要素がまた配列」なんていう場合もあると思います。その場合も<code>a[0][0][0]</code>のように添字の数を増やすことで対応できます。もっとも、よく使われるのはせいぜい2つくらいまでです。</p>

<h4>多次元配列のコピー</h4>
<p>さて、それではcopyArrayを作りなおしましょう。さっきのものだと、配列の要素がまた配列だと、結局そこで参照をコピーしてしまいうまくいかなかったのでした。</p>
<pre><code>function copyArray(arr){
  var newarr = [];
  for(var i = 0;i&lt;arr.length;i++){
    newarr[i] = arr[i];
  }
  return newarr;
}
var a = [ [0,1,2] , [3,4,5] ];
alert(a[0]);
var b = copyArray(a);
alert(b[0]);

a[0][3]=3;
alert(b[0]);</code></pre>
<p>まずaに多次元配列を代入し、<code>a[0]</code>を表示しています。<code>[0,1,2]</code>が表示されます。</p>
<p>bにさっきのcopyArrayでaをコピーしますが、ここで<strong>bはaとは別の配列です</strong>。ややこしくなってきましたが、しっかり理解しましょう。</p>
<p>bそのものは確かにaとは<strong>中身が同じ</strong>別の配列です。その中身は、普通の配列ではプリミティブ値でしたが、今回の多次元配列は<strong>参照</strong>でした。中身は同じですから、当然参照が指すものは<strong>同じ</strong>ということです。</p>
<p>つまり<code>a[0]</code>と<code>b[0]</code>は、同じオブジェクト（今回の場合は<code>[0,1,2]</code>）を指す参照がそれぞれ代入されています。だから、a[0]を通して操作すると、結局同じオブジェクトを操作することになってしまうというわけです。<code>a[1]</code>と<code>b[1]</code>も同じです。</p>

<p>さて、ではどうすればいいかですが、配列の要素をひとつひとつコピーするとき、その要素が配列だったら<strong>その配列の要素をまたひとつひとつコピーする</strong>必要があります。</p>
<p>つまり、こうなります。</p>
<pre><code>function copyArray(arr){
  var newarr = [];
  for(var i = 0;i&lt;arr.length;i++){
    <mark class="ins">if(もしarr[i]が配列だったら){
      newarr[i] = copyArray(arr[i]);
    }else{</mark>
      newarr[i] = arr[i];
    <mark class="ins">}</mark>
  }
  return newarr;
}</code></pre>
<p>copyArrayをcopyArrayの中で使うのです。一見よく分からないように思えますが、確かなのは「copyArrayは配列の要素を1つ1つコピーする関数だ」ということです。だから、配列の要素が配列だったとき、copyArrayを呼び出せばちゃんとコピーしてくれるというわけです。ちなみに、このように関数の中でさらに同じ関数を呼び出す方法を<dfn>再帰</dfn>といいます。</p>

<p>さて、if文が登場しましたが、条件が日本語で書いていますね。これでは動きません。わざわざこう書いたのは、配列かどうかの判定法はまだ解説していなかったからです。それには、<strong>Array.isArray</strong>という関数を使います。これは引数に何かを渡すと、それが配列の場合はtrue、そうでない場合はfalseを返してくれる関数です。これを用いるとcopeArrayの完成形は次のようになります。</p>
<pre><code>function copyArray(arr){
  var newarr = [];
  for(var i = 0;i&lt;arr.length;i++){
    if(<mark class="ins">Array.isArray(<mark>arr[i]</mark>)</mark>){
      newarr[i] = copyArray(arr[i]);
    }else{
      newarr[i] = arr[i];
    }
  }
  return newarr;
}</code></pre>
<p>これをさっきのサンプルに組み入れると、正しく動作することがわかります。やってみましょう。</p>
-->
