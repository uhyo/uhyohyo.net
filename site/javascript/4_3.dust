<h3>正規表現の利用</h3>
<p>正規表現の利用方法として前回紹介したのはtestメソッドでした。これはある文字列がパターンにマッチするかどうかを判定するだけでした。実は、正規表現の利用法は他にもあります。</p>

<h4>match</h4>
<p><dfn>match</dfn>というメソッドがあります。これは、前回のtestと同じように、正規表現と文字列をマッチング<small>（マッチさせること）</small>するものです。</p>
<p>ただし、testの場合とは逆で文字列のメソッドであり、引数に正規表現を指定します。つまり、<code><var>文字列</var>.<strong>match</strong>(<var>正規表現</var>)</code>という形です。</p>
<p>testの返り値はマッチしたかどうかの真偽値でしたが、matchの戻り値は違います。</p>
<p>マッチしなかった場合matchの戻り値は<strong>null</strong>であり、マッチした場合の戻り値は<strong>配列</strong>です。この配列の0番目の要素には、<strong>マッチした文字列</strong>が入っています。</p>
<p>マッチした文字列とはどういうことかというと、例えば、<code>a.{5}c</code>という正規表現が、</p>
<pre><code>
a<mark>abcbcac</mark>buccb
 ^^^^^^^
</code></pre>
<p>という部分にマッチしたとき、この配列の0番目には<code>"abcbcac"</code>が入っています。実際、次のコードを実行すると<code>["abcbcac"]</code>という配列が表示されます。</p>
<pre><code>
console.log("aabcbcacbuccb".match(/a.{5}c/));
</code></pre>

<p>matchにはさらに機能があります。それは前回解説した<strong>グループ化</strong>と関わりがあります。グループ化とは、一部分を括弧で囲んでひとまとめにすることでした。グループ化の方法は<code>( )</code>で囲む方法と<code>(?: )</code>で囲む方法がありました。</p>
<p>実は、前者の<code>( )</code>で囲むグループ化が正規表現に存在するとき、マッチ時にグループ化した部分だけを個別に取得することができます。例えば、上の<code>a.{5}c</code>を、<code>a<mark>(</mark>.{5}<mark>)</mark>c</code>とした場合、括弧で囲んだ<code>.{5}</code>の部分だけを、マッチした全体とは別に取得できます。</p>
<p>つまり、この正規表現が</p>
<pre><code>a<mark>abcbcac</mark>buccb
 ^^^^^^^
</code></pre>
<p>という部分にマッチしたとき、matchの返り値である配列の0番目の要素はマッチした全体である<mark>"abcbcac"</mark>です。さらに、配列の1番目にはグループ化された<code>.{5}</code>に対応する部分、すなわち<code>"bcbca"</code>が入っています。</p>
<p>次のサンプルで確かめてみましょう。</p>
<pre><code>var str = "aabcbcacbuccb";
var result = str.match(/a(.{5})c/);
console.log(result[0]); // "abcbcac"
console.log(result[1]); // "bcbca"
</code></pre>
<p>ちなみに、</p>
<pre><code>a<mark>(</mark>.{5}<mark>)</mark>c<mark>(</mark>.{3}<mark>)</mark></code></pre>
<p>のように括弧が2つ以上ある場合も、1つめの括弧の中は1番目の要素に、2つめは2番目……のようにいくつでも取得することができます。</p>
<p>このように、グループ化した部分を別に取得することをキャプチャと言います。結局のところ、グループ化に<code>( )</code>と<code>(?: )</code>の2種類があった理由は、前者はキャプチャするグループ、後者はキャプチャしないグループという使い分けのためです。キャプチャが目的でないグループ化には<code>(?: )</code>を使いましょう。そのほうが、キャプチャの処理が発生しない分だけ<code>( )</code>よりも速度やメモリ使用量の面で有利と考えられます。</p>

<h4>matchの利用例</h4>
<p>さて、このmatchはかなり応用がきくメソッドで、正規表現を扱う際はtestと並んでよく使うメソッドです。たとえば、<code>'&lt;img src="aaa.gif"&gt;'</code>のような、開始タグの文字列があったとして、ここからタグ名（今回の場合<code>"img"</code>）だけを抜き出したいとします。このとき、どのようにしたらいいと思いますか？</p>
<p>matchを利用して、正規表現を使えばいいのです。いくらでもちゃんとやりようはありますが、例えば次の正規表現を使います。</p>
<pre><code>&lt;<mark>(</mark>\S+<mark>)</mark>\s+.+&gt;</code></pre>
<p>「<code>&lt;</code>があって、その次に\S(＝空白文字以外)がいくつかあって、その次に空白がいくつかあって、さらに次には任意の文字がいくつかあって、最後に<code>&gt;</code>がある」という意味の正規表現ですね。</p>
<p>上のタグの場合だと、<code>&lt;</code>の部分が最初の&lt;で、次の<code>img</code>が<code>(\S+)</code>に当てはまり、次のスペースが<code>\s+</code>になります。</p>
<p><code>src="aaa.gif"</code>の部分は<code>.+</code>が、最後の<code>&gt;</code>には&gt;が当てはまることになります。括弧でグループ化されているのはimgの部分だから、うまくいってますね。</p>

<p>今の正規表現は簡単すぎて片手に収まらないほど問題がありますが、例なのであまり気にしないでください。正規表現を利用するときは自らの需要に合わせて正規表現を作りましょう。</p>

<h4>replace</h4>
<p>ではもう1つメソッドを紹介します。それは<dfn>replace</dfn>です。これは、<strong>正規表現で検索して、マッチした部分を別の文字列に置き換える</strong>というメソッドです。</p>
<pre><code><var>文字列</var>.replace(<var>正規表現オブジェクト</var>,<var>置き換え後文字列</var>)</code></pre>
<p>返り値は、置き換えた後の文字列です。</p>
<p>サンプルは、</p>
<pre><code>
var str = "aaa1234bcd567efg8999h";		//もともとの文字列
var result = str.<mark>replace</mark>(/\d+/, "数字");	//置き換え後の文字列
console.log(result); // "aaa数字bcd567efg8999h"
</code></pre>
<p>という感じです。replaceの引数は、1つめが<code>/\d+/</code>で、2つめが<code>"数字"</code>ですね。</p>
<p>この正規表現オブジェクトは、<code>\d</code>が「数字1文字」を表すから、それが1つ以上ということなので、1234、555、0、29……といった、数字が何文字か連なったものにマッチします。</p>
<p>マッチしたところが2つめの引数に置き換わるということは、例えば</p>
<pre><code>aaa<mark>1234</mark>bcd567efg8999h
   ^^^^
   </code></pre>
<p>の部分がマッチしたとき、その部分が</p>
<pre><code>aaa<mark>数字</mark>bcd567efg8999h
</code></pre>
<p>のように置き換わるということです。結果、できあがる文字列は<code>"aaa数字bcd567efg8999h"</code>ということになります。</p>
<p>ちなみに、「567」や「8999」の部分も<code>\d+</code>の条件には当てはまるのですが、今回置き換えられたのは<code>1234</code>の部分だけです。その理由は、このような場合replaceは最初にマッチしたひとつしか置き換えないためです。また、マッチするときは文字列の前のほうから見ていくため、今回最初にマッチするのは「1234」となります。</p>

<h3>正規表現のオプション</h3>
<p>オプションとは、細かい設定ということです。実は正規表現オブジェクトに対してオプションを設定し、細かい動作を制御することができます。</p>

<h4>iオプション</h4>
<p>iオプションというものがあります。このオプションがあると、マッチするときに<strong>半角英字の大文字と小文字を区別しなくなります</strong>。つまり、例えば<code>/abc/</code>という正規表現が、<code>AbC</code>というような文字列にもマッチするようになります。</p>
<p>では、iオプションはどうやってつけるかというと、正規表現オブジェクトを作るときに<code>/正規表現/<mark>i</mark></code>とします。正規表現の終わりを示すスラッシュの後に、iという文字がつきました。これで、iオプションがつきます。</p>
<p>これを、<code>"ABCDE".match(/abc/<mark>i</mark>)</code>のように使えます。</p>

<h4>gオプション</h4>
<p>もう1つ、gオプションというものがあります。つけ方はiオプションと同じで、スラッシュの後ろに付けます。両方のオプションを付けることもできて、その場合は<code>/正規表現/ig</code>のように並べます（オプションの順番は自由）。</p>
<p>このgオプションがついていると、その正規表現オブジェクトを使ってマッチングしたとき、<strong>複数回マッチします</strong>。</p>
<p>複数回マッチするというのがどういうことかは、メソッドによって変わります。一番わかりやすいのはさっき紹介したreplaceメソッドです。</p>
<p>先ほど、replaceは最初にマッチした部分のみ置き換えると説明しましたが、それは正規表現にgオプションがない場合です。gオプションがある場合、マッチする部分全てを置き換えるという動作に変わります。つまり、次のようになります。</p>
<pre><code>
var str = "aaa1234bcd567efg8999h";		//もともとの文字列
var result = str.replace(/\d+/<mark>g</mark>, "数字");	//置き換え後の文字列
console.log(result); // "aaa数字bcd数字efg数字h"
</code></pre>
<p>先ほどとは異なり、1234の部分だけでなく567と8999も<code>"数字"</code>に置き換わっています。</p>

<p>次に、matchメソッドは、返ってくる配列の中身が変わります。gオプションがついていない場合は、上で解説したように0番目の要素にはマッチした文字列全体が、1番目以降にはグループ化した箇所の文字列が入っているのでした。</p>
<p>これが、gオプションがつくと、マッチした文字列が、0番目から順番に入っているようになります。つまり、</p>
<pre><code>"aaa1234bcd567efg8999h".match(/\d+/<mark>g</mark>)</code></pre>
<p>で返ってくる配列は<code>["1234", "567", "8999"]</code>となります。なぜなら、この文字列に対して</p>
<pre><code>aaa<mark>1234</mark>bcd<mark>567</mark>efg<mark>8999</mark>h
   ^^^^   ^^^   ^^^^
 </code></pre>
<p>のようにマッチするから、です。</p>
<p>matchでgオプションを使う場合、キャプチャは行われなくなります。</p>

<p>最後に前回紹介したtestですが、このメソッドはただマッチするかどうかを調べるだけなので、gオプションがついても動作は変わりません。</p>

<p>ここで紹介したiとgが代表的なオプションです。他にm、y、uがありますがここでは説明しません。</p>


<h3>replaceとグループ化</h3>
<p>上で、replaceでマッチした部分を別の文字列に置き換えるということを解説しました。実は、置き換え後の文字列をマッチした文字列に合わせて変えることが可能です。それには2つの方法があります。</p>
<p>例えば、上ではreplaceで<code>\d+</code>にマッチする部分を"数字"に置き換えましたが、これを、置き換える代わりにもとの数字を残して<code>"数"</code>と<code>"字"</code>で囲みたいとしましょう。例えば、<code>"1234"</code>という文字列にマッチしたなら、これを<code>"数1234字"</code>というふうに置き換えたいとします。</p>
<p>このときは、次のようにします。</p>
<pre><code>"aaa1234bcd567efg8999h".replace(/(\d+)/g, "数<mark>$1</mark>字");</code></pre>
<p>置き換え後の文字列に中にある<code>$1</code>という部分がポイントです。replaceの置き換え後文字列中に<code>$</code> + 数字の記法があると、これはキャプチャされた文字列に置き換わります。<code>$1</code>は1番目の（つまり最初の）グループ化に対応します。グループ化が2つ以上あるなら、$2、$3、……と対応します。</p>
<p>また、<code>$0</code>とすると、これはマッチした部分の全体になります。つまり、今回の場合はグループ化を使わなくても同じことが次のようにできます。
<pre><code>"aaa1234bcd567efg8999h".replace(/\d+/g, "数<mark>$0</mark>字");</code></pre>
<p>この0、1、……という数字は、match（gオプションがない場合）の返り値の配列に対応していることに注意してください。</p>

<p>今回のサンプルではgオプションをつけたので、当てはまるところ全てにマッチして結果は<code>"aaa<mark>数1234字</mark>bcd<mark>数567字</mark>efg<mark>数8999字</mark>h"</code>となります。</p>

<p>もう1つの方法は、replaceの第2引数に置き換え後の文字列ではなく<strong>関数</strong>を与える方法です。この方法では、マッチした文字列をどう置き換えるかを関数が決定します。そのため、より柔軟な処理が可能です。まず、上のサンプルと同じことを関数でやってみると、次のようになります。</p>
<pre><code>
"aaa1234bcd567efg8889h".replace(/\d+/g, function(str){
  return "数" + str + "字";
}); // "aaa数1234字bcd数567字efg数8889字h"
</code></pre>
<p>第二引数には、</p>
<pre><code>function(str){
  return "数" + str + "字";
}</code></pre>
<p>という関数が渡されていることに注意してください。この関数は、引数<code>str</code>を受け取って、その前後を<code>"数"</code>と<code>"字"</code>で囲った文字列を返します。</p>
<p>察しがついているとは思いますが、正規表現にマッチした文字列があったときにこの関数が呼び出されます。その際、引数にマッチした部分の文字列が渡されます。そして、マッチ部分はその関数呼び出しの返り値で置き換えられます。</p>
<p>ちなみに、関数を用いる場合もグループ化によりキャプチャした部分を得ることが可能です。それは関数の第2引数以降に渡されます。例えば、今の置き換えの逆を行うには次のようにします。</p>
<pre><code>
"aaa数1234字bcd数567字efg数8889字h".replace(/数(\d+)字/g, function(str, num){
  return num;
}); // "aaa1234bcd567efg8889h"
</code></pre>
<p>この場合、正規表現<code>/数(\d+)字/g</code>が<code>"数1234字"</code>にマッチして関数が呼び出されたとすると、引数<code>str</code>には<code>"数1234字"</code>が入り、<code>num</code>には1番目のグループでキャプチャされた<code>"1234"</code>が入ります。</p>
<p>最後に、関数ではないとできない例を紹介しておきます。マッチした数値を2倍にしてみましょう。</p>
<pre><code>
"aaa1234bcd567efg8889h".replace(/\d+/g, function(str){
  return parseInt(str) * 2;
}); // "aaa2468bcd1134efg17778h"
</code></pre>
<p>この例では、数値を2倍にするために掛け算を使っていますが、parseInt（<a href="kiso4.html">基礎第4回</a>で紹介）が必要な点に注意しましょう。掛け算は数値に対して行われますが、引数<code>str</code>はマッチした<em>文字列</em>が渡されるので、文字列を数値に変換しないといけません。なお、この例では関数の返り値が数値になってしまいますが、そのような場合は自動的に文字列に変換されます。</p>

<h3>最長マッチと最短マッチ</h3>
<p>最後に少し正規表現の記法に戻って、最長マッチと最短マッチというものについて解説します。</p>
<p>例えば、上で解説したreplaceを使って<code>" 〜 "</code>で囲まれている部分を<code>「 〜 」</code>で囲むように置き換える処理を作ってみたいと思います。</p>
<p><code>" 〜 "</code>で囲まれている部分を表す正規表現は、次のようになりますね。</p>
<pre><code>/".*"/</code></pre>
<p>最初と最後に<code>"</code>があって、その間は<code>.*</code>だから、任意の文字が何個かあるか、もしくはないということです。</p>
<p>囲まれている部分は置き換え時に使うので、</p>
<pre><code>/"<mark class="ins">(</mark>.*<mark class="ins">)</mark>"/</code></pre>
<p>のようにグループ化します。replaceで実際に置き換えるには、<code><var>文字列</var>.replace(/"(.*)"/g, "「$1」")</code>とします。<code>" 〜 "</code>で囲まれた部分が複数あった場合も全て置き換えたいので、今回はgオプションをつけてみました。</p>
<p>実はこれでは問題があります。実際に<code>" 〜 "</code>で囲まれた文字列が2つある<code>'"aaaaa".  "bbbbb".'</code>という文字列を置き換えるとどうなるでしょうか。</p>
<pre><code>
'"aaaaa".  "bbbbb".'.replace(/"(.*)"/g, "「$1」"); // '「aaaaa".  "bbbbb」.'
</code></pre>
<p>期待していた結果は<code>'「aaaaa」.  「bbbbb」.'</code>となることですが、実際の結果は<code>'「aaaaa". "bbbbb」.'</code>となってしまいます。</p>
<p>理由は、正規表現中の<code>.*</code>の部分が<em>最長マッチ</em>になっていることです。最長マッチとは、なるべく長くマッチするということです。</p>
<p>今回の例では、<code>".*"</code>はまず文字列中の</p>
<pre><code><mark>"aaaaa"</mark>.  "bbbbb".
^^^^^^^
 </code></pre>
<p>の部分にマッチしてほしかったわけですが、この位置から始まるマッチとしてはこれは最長ではありません。実際、次のほうがより長くマッチできます。</p>
<pre><code><mark>"aaaaa".  "bbbbb"</mark>.
^^^^^^^^^^^^^^^^^
</code></pre>
<p>これを期待通りの動作にする方法は2つあります。まず、今回説明したい方から解説します。</p>

<p>それは、この最長マッチという性質を変えるという方法です。理想的なのは、<strong>なるべく短くなるようにマッチする</strong>というような性質です。この性質は、<strong>最短マッチ</strong>などとよばれます。</p>
<p>実は、最長マッチをこの最短マッチに変える方法はちゃんとあります。それは、<code>+</code>、<code>*</code>などの、繰り返しを表す記号の直後に、<strong>?</strong>をつけます。注意してほしいのが、この<code>?</code>は、前回紹介した「直前の文字が0回または1回」という意味の<code>?</code>とは別物であるということです。あくまで、<code>+</code>や<code>*</code>などの繰り返しの記号のあとに<code>?</code>をつけるのです。</p>
<p>つまり、<code>/"(.*<mark>?</mark>)"/</code>という正規表現になります。</p>
<p>今回のサンプルは、これで期待通りの結果になります。</p>
<pre><code>
'"aaaaa".  "bbbbb".'.replace(/"(.*?)"/g, "「$1」"); // '「aaaaa」.  「bbbbb」.'
</code></pre>

<p>さて、2つめの方法ですが、こっちはけっこう単純です。</p>
<p><code>.*</code>の部分が、任意の文字だからといって、<code>"</code>が出てきてもそれも含んでどんどん先までマッチしてしまったことが期待通りにならない原因なので、この<code>.</code>が0回以上繰り返すという部分を、<strong><code>"</code>以外の文字</strong>が0回以上繰り返すというようにすればいいのです。</p>
<p>すると、この正規表現がマッチする<code>" 〜 "</code>の間の文字に<code>"</code>が含まれることはなくなるので、期待通りの動作になります。</p>
<pre><code>
'"aaaaa".  "bbbbb".'.replace(/"(<mark>[^"]</mark>*)"/g, "「$1」"); // '「aaaaa」.  「bbbbb」.'
</code></pre>
<p>正規表現の説明は以上です。</p>
