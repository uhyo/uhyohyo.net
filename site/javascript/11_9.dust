<p>今回は<dfn>strictモード</dfn>について解説します。これはES5で導入された、従来より<em>厳しいモード</em>です。これは日本語に訳しただけですが、厳しいというのはどういうことでしょうか。</p>
<p>代表的な例は、前回も少し話に出た、プロパティの<a href="11_4.html">writable属性</a>です。writable属性がfalseとなっているプロパティは、代入しても変更できません。実際に代入しようとした場合、strictモードでない場合は無視されて何も起きませんが、strictモード中にこれをやるとエラーとなります。このように、strictモードでは間違いや望ましくない挙動に対して、エラーを始めとするより厳しい挙動を示します。</p>
<p>詳しくは後で解説しますが、結論から述べると、<strong>JavaScriptプログラムを書く場合は全てstrictモードで書くことが推奨されます</strong>。

<h3>strictモードの利用法</h3>
<p>プログラムをstrictモードにする方法は、プログラムの最初に<code>"use strict";</code>（または<code>'use strict';</code>）という式を置きます。これは、プログラムの一番最初でなければなりません。例えばHTML中にscript要素でJavaScriptを書く場合にはこのように真っ先にこの式を書きます。</p>
<pre class="language-html"><code>
……
&lt;script&gt;
  <mark>"use strict";</mark>
  // ……
&lt;/script&gt;
</code></pre>
<p>また、プログラム全体をstrictモードにするのではなく、ある関数の中だけをstrictモードにすることも可能です。その場合は関数の中身の最初に上の式を書きます。</p>
<pre><code>
function foo(){
  <mark>"use strict";</mark>
  // ……
}
</code></pre>

<h3>strictモードの影響</h3>
<p>プログラムがstrictモードになっているときは、一部のプログラムの挙動が従来と異なります。先に述べたように従来よりもより厳しい挙動になっています。それらのうち影響がありそうなものを見ていきます。</p>

<h4>書き込み不可能なプロパティに対する代入</h4>
<p>上で述べたように、書き込み不可能なプロパティに対する代入は、strictモードではエラーになります。</p>
<pre><code>
var obj = {
  foo: 3,
};

Object.freeze(obj);

obj.foo = 5; // 無視される

(function(){
  'use strict';

  obj.foo = 10; // <em>エラー</em>
})();
</code></pre>

<h4>グローバル変数の作成</h4>
<p>はるか昔に、<em>varを使わずに作った変数はグローバル変数になる</em>と解説したような気がします。一方のstrictモードでは、<em>varを使わずに変数を作ることはできません</em>。</p>
<pre class="line-numbers"><code>
function makeFoo(){
  foo = 3;
}

function makeBarStrict(){
  'use strict';
  bar = 5;
}

makeFoo();
console.log(foo); // 3

makeBarStrict(); // <em>ここでエラーになる</em>
console.log(bar);
</code></pre>
<p>2行目でいきなり変数fooに3を代入していますが、この変数はいままで存在しなかった変数で、しかもvarで宣言されていないのでグローバル変数となります。一方、7行目では同じように変数barへの代入を行っていますがこちらはstrictモードの中です。よって、存在しない変数barへの代入は許可されず、エラーとなります。</p>
<p>とはいえ、makeBarStrictの中で<code>var bar = 5;</code>とするとbarはローカル変数になってしまいます。strictモードでグローバル変数への代入を行いたい場合、先にvarでグローバル変数を作っておく必要があります。次のようにすると、strictモードの関数内からグローバル変数に代入することができます。</p>
<pre class="line-numbers" data-line="1"><code>
var bar;

function makeBarStrict(){
  'use strict';
  bar = 5;
}

makeBarStrict();
console.log(bar); // 5
</code></pre>

<p>strictモードでの挙動は、ミスにより望まないグローバル変数を作ることを防ぐ効果があります。例えば上の例で変数名をタイプミスして<code>ba<mark>t</mark> = 5;</code>とした場合エラーになり、タイプミスに気づくことができます。strictモードでない場合はエラーが出ないがbarには何も入っていないという事態になり、バグが見つかりにくくなるかもしれません。</p>

<h4>関数の引数名は重複できない</h4>

<p>strictモードでは、関数の引数の名前が同じ場合は文法エラーになります。よって、これは文法エラーです。</p>
<pre><code>
function foo(arg, arg){
  'use strict';
}
</code></pre>
<p>逆に言えば、こんなコードもstrictモード以前では許されていたということです。ちなみに、この場合変数argは第2引数に渡された値が入っています。第1引数の値は変数に入りませんが、<a href="9_3.html#anchor-arguments">arguments</a>を使えば取得することができます。</p>

<h4>オブジェクトリテラルのプロパティ名も重複できない</h4>
<p>次のように、オブジェクトリテラル中で同じプロパティを複数回定義しているようなものはstrictモードでは文法エラーです。</p>
<pre><code>
'use strict';
var obj = {
  foo: 3,
  foo: 'bar',
};
</code></pre>
<p>このあたりも、プログラマのミスをなるべく早期に発見できる効果が期待できますね。</p>

<h4>argumentsの闇が消える</h4>
<p>上で何気なく再登場したargumentsですが、これは実はかなり曲者なオブジェクトで、その特殊な挙動はまさに<em>闇</em>と呼ぶにふさわしいものです。strictモードでは、argumentsのそのような特殊な挙動がなくなります。argumentsの闇に依存してしまうといけないのでこの講座ではそういったものを紹介していませんでしたが、もし興味がある人は調べてみるとよいでしょう（しかし利用してはいけません）。</p>
<p>関連して、<code>arguments = ['foo', 'bar'];</code>のようなargumentsへの再代入はstrictモードではエラーとなります。</p>

<h4>withが使えない</h4>
<p>strictモード内では<b>with文</b>という文を使うのは禁止されています。この講座ではwith文は紹介していませんので、気になる方は調べてみましょう。</p>
<p>with文を禁止することで、JavaScriptをより最適化することができるそうです。つまり、strictモードを使うことはJavaScriptコードの実行速度の向上に寄与するかもしれないということです。</p>

<h3>strictモードの意味</h3>
<p>他にも細かい違いがありますが、strictモードにおけるJavaScriptの挙動の違いはだいたいこんな感じです。こうしてみると分かるように、strictモードは一つには<em>ミスの早期発見</em>に貢献してくれます。また、最後にさっくりと紹介しましたがstrictモードにより<em>問題のある挙動が廃止</em>されています。</p>
<p>これらの変更によりJavaScriptがより優れた言語になると考えられますね。しかし問題は、これが<em>変更</em>であるということです。というのも、もし非strictモードの挙動に依存しているプログラムがあったとして、ある日突然JavaScriptの仕様が変わって今まで動いていたプログラムがエラーになったら、JavaScriptの利用者はとても困ります。ですから、こういった変更を行いたくてもそう簡単に行うことはできないのです。</p>
<p>今まで動いていたプログラムがこれからも動くことを<b>後方互換性</b>といいます。つまり、問題のある挙動を廃止したくても、いきなりJavaScriptの仕様を変えてしまうと後方互換性が崩れてしまうため、それはできないのです。</p>
<p>その解決策として導入されたのがstrictモードなのです。つまり、このような変更をstrictモードと明示されたプログラムの中だけに適用することで、従来のプログラム（もちろんstrictモードの宣言はされていないはずです）が壊れてしまうことを防ぎつつ、これから書かれるプログラムには挙動の変更が適用できるようにしたのです。</p>

<p>strictモードの宣言が<code>"use strict";</code>という形になっているのもやはり後方互換性のためです。といっても、今度はブラウザの後方互換性です。これが一番不可解な点は、<code>"文字列";</code>という形になっている点です。わざわざ文字列リテラルにせず、<code>use strict;</code>のような新しい構文を素直に導入すればいいように思えるかもしれません。</p>
<p>そうなっていないのは、古いブラウザに対応するためです。strictモードが最新鋭だった当時は、当然それを使えるのは最新のブラウザのみです。となると、strictモードが認識できない古いブラウザでの挙動が問題となります。<code>use strict;</code>のような新しい構文を導入した場合、古いブラウザでは文法エラーになってしまいます。ということは、古いブラウザではJavaScriptが実行できません。これは大問題です。一方、<code>"use strict";</code>という構文ならば、古いブラウザにとっては何の意味もない文字列が書いてあるだけと認識されます。strictモードにはなりませんが一応実行することはできます。</p>

<p>最後に、strictモードの宣言がプログラムの最初と関数の最初の2箇所で使える理由も同じような感じです。ある巨大なプログラムがあり、せっかくなのでstrictモードに書き換えたいという場合を考えます。しかし巨大なプログラムはどこかで非strictモードの挙動に依存しているためプログラム全体をstrictモードにすると正しく動作してくれません。そのようなとき、関数ごとのstrictモード宣言を使うことで、というより小さな単位ごとにstrictモード化を進めることができるのです。</p>

<p>以上でstrictモードの説明は終わりです。基本的にはこれから新しく書くJavaScriptプログラムでstrictモードを利用しない理由はありませんから、積極的に付けていきましょう。</p>
