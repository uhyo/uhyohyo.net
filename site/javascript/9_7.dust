<p>今回はプリミティブとオブジェクトの関係について解説します。</p>
<p>プリミティブとは、</p>
<pre><code>
"あいうえお"
123
true
</code></pre>
<p>のように、オブジェクトではない値のことでしたね。</p>

<h3>プリミティブのプロパティ</h3>
<p>ここで、次のサンプルを見てください。</p>
<pre><code>
var aaa = "aiueo";

console.log(aaa.<strong>length</strong>);
</code></pre>
<p>「5」と表示されます。実はこの<dfn>length</dfn>プロパティは<strong>文字列の長さ</strong>がわかるものなのですが、なかなか便利です。しかし、おかしいと思いませんか。</p>
<p>変数aaaの中身は<code>"aiueo"</code>です。これは<em>プリミティブ</em>であり、オブジェクトではないのだから、プロパティなどないはずです。</p>
<p>実は、プリミティブのプロパティを参照しようとしたときは、内部的にオブジェクトが作られてそのプロパティを参照しているのです。このオブジェクトはプロパティを参照するためだけに作られ、役目が終わったら消えます。</p>
<p>それでは、どんなオブジェクトが作られているのでしょうか。</p>
<p>実はこれは、プリミティブの型ごとに決まっています。プリミティブには文字列・数値・真偽値がありましたが、それぞれString,Number,Booleanというオブジェクトのインスタンスが作られます。</p>
<p>一応、これらのインスタンスは自分でも作れます。</p>
<pre><code>
var abc = new <mark>String</mark>("あああ");
console.log(abc);
</code></pre>
<p>つまり、<code>aaa.length</code>は、内部的に
<code><mark class="ins">(new <mark>String</mark>(aaa))</mark>.length</code>
というようにして処理されていたのです。</p>
<p>このことは、次のようにString.prototypeにプロパティを追加することで確かめることができます。ただし、Stringなどもともと存在するオブジェクト（組み込みオブジェクトと呼ばれることもあります）に対してこのような方法で機能を追加するのは勧められたことではありませんので、実際にはやらないようにしましょう。</p>
<pre><code>
String.prototype.abcabc = "test";

console.log("あああ".abcabc); // "test"
</code></pre>

<p>また、<code>new String("foo")</code>のような、String,Number,Booleanのインスタンスは、あくまでオブジェクトでありプリミティブではありません。これらをプリミティブ値の代わりに使うことはできず、あくまでプリミティブのプロパティを参照する機能の実現のために存在しています。</p>

<p>なお、残り2種のプリミティブ、すなわちnullとundefinedは、プロパティを参照しようとしてもオブジェクトが生成されることはありません。nullやundefinedのプロパティを参照しようとするとエラーになります。

<h3>型変換</h3>
<p>もうひとつプリミティブに関連する値として、<strong>型変換</strong>について紹介します。JavaScriptでは、型の変換を明示的に・あるいは暗黙的に行うことができます。</p>

<h4 id="anchor-type-conversion-boolean">真偽値への変換</h4>
<p>まず最初に真偽値への変換を解説します。以前にも説明したように、if文の条件に渡されるのは真偽値であるべきで、もし真偽値でない値が渡された場合は真偽値に変換されます。</p>
<p>真偽値への変換は次のように行われます。まず、null・undefinedはfalseに変換されます。数値は0とNaN（後述）はfalse、それ以外はtrueです。文字列については、""ならfalse、他は全てtrueです。そして、オブジェクトは全てtrueです。</p>
<p>このことを利用すると、ある値が「オブジェクトまたはnull」であることが分かっている場合に、それがオブジェクトである（nullではない）かどうか判定するために真偽値への変換を用いることができます。そのような例はDOMに多く見受けられます。例えばノードの<a href="2_7.html">previousSibling・nextSibling</a>は該当するノードがあればそのノード、なければnullが入っているプロパティです。ノードは当然オブジェクトなので、真偽値に変換するとtrueとなります。つまり、あるノード<code>node</code>に次の兄弟ノードが存在するかどうかで分岐したいときは、次のようにすることができます。</p>
<pre><code>
if(node.nextSibling){
  ...
}
</code></pre>
<p>もちろん、この場合nullか否かを判定できればいいので、<code>node.nextSibling != null</code>としてもよいでしょう。こちらのほうが意図が明示的なので好む人がいるかもしれません。</p>

<h4>等価演算子</h4>
<p>さて、<strong>等価演算子</strong>（<code>==</code>）でも実はさまざまな型変換が行われます。異なる型の値を比べる場合、型変換で型を揃えてから処理されます。</p>
<p>まず、nullとundefinedは別の値ですが、実はこれらを比べた場合trueです。<code>console.log(null == undefined);</code>などとして確かめてみましょう。nullやundefinedやそれ以外の値とは<code>==</code>になりません。</p>
<p>次に、<strong>数値と文字列</strong>を比べた場合、文字列が数値に変換されます。文字列から数値への変換というのは、例えば<code>"3"</code>という文字列なら3という数値に、<code>"7"</code>という文字列なら7という数値に……という感じです。ただし、<code>"あいう"</code>のような、数値を表さない文字列の場合はNaN（後述）に変換されます。</p>
<p>ということは、例えば<code>3=="3"</code>はtrueになるということです。</p>

<p>その次は、<strong>真偽値</strong>とそれ以外を比べる場合です。この場合はとりあえず真偽値を<strong>数値</strong>に変換します。真偽値は、falseが0、trueが1に変換されます。例えば真偽値と文字列の場合など、真偽値を数値に変換しても型が同じにならない場合はさらに型変換が行われます。例えば、<code>true == "1"</code>はtrueになります。これは、まず真偽値trueが1に変換され、数値1と文字列<code>"1"</code>の比較となります。これは数値と文字列の変換となり、上で説明した場合と同様なので、<code>"1"</code>という文字列が1という数値になります。よって、両辺が1に変換され一致したのでtrueとなります。</p>

<p>さて、残っているのは<strong>オブジェクトとプリミティブの比較</strong>の場合です。オブジェクトと真偽値を比較する場合は前述の通り真偽値が数値に変換されます。オブジェクトと数値または文字列と比較する場合、まず、<strong>オブジェクトをプリミティブに変換</strong>します。これにより、プリミティブどうしの比較となり、今までの説明により解決できます。</p>

<h4 id="anchor-object-translation">オブジェクトの変換</h4>
<p>では、オブジェクトをプリミティブに変換するにはどうするのでしょう。実は、オブジェクトが変換されるときに呼び出される<strong>メソッド</strong>があります。それは、<dfn>toString</dfn>と<dfn>valueOf</dfn>です。一般に、toStringは文字列に変換したいとき、valueOfは数値に変換したいときに呼び出されることになっています。自分でオブジェクトを作ったとき、これらのメソッドを作っておけば変換されたときの値を操作できるというわけです。</p>
<pre><code>
var aaa={
  <mark>toString</mark>: function(){return "aaa!";}
};
console.log("aaa!"==aaa); // true
</code></pre>
<p>この例では、文字列<code>"aaa!"</code>とオブジェクト<code>aaa</code>の比較なので、まずオブジェクトが文字列に変換されます。これはaaaのtoStringメソッドを呼び出した返り値となります。すなわち、<code>"aaa!"</code>です。これで両辺の文字列は一致するため<code>"aaa!" == aaa</code>が成り立ちました。</p>

<div class="sidenote">
  <p>これは細かい内容ですが、オブジェクトを文字列に変換したい場合でも、toStringがない場合はvalueOfを代わりに呼び出します。その逆もありえます。</p>
  <p>ただ、toStringは実はObject.prototypeにあるので、toStringを自分で定義しなくても普通のオブジェクトにはtoStringは存在しています。したがって、「toStringがない」という状況を作るには、例えば次のようにtoStringを上書きしておく必要があります。</p>
  <pre><code>
var aaa={
  <mark>toString</mark>:null,
  <mark>valueOf</mark>:function(){return "aaa!";}
};
console.log("aaa!"==aaa);
</code></pre>
<p>toStringもvalueOfもない場合、変換しようとするとエラーになります。まあ、そんな変なオブジェクトを作る機会は無いと思うのでこんなことは忘れても構いません。</p>

  <p>また、valueOfは数値に変換したい場合に呼び出されると説明しましたが、toStringは「文字列に変換」なのに対して、実はvalueOfは「数値に変換」という意味ではありません。実際、Object.prototype.valueOfは、「自分自身を返す」というメソッドです。例えば<code>({}).valueOf()</code>は<code>{}</code>というオブジェクトを返します。プリミティブに変換したいのにこれは何の役にも立ちません。このようにtoStringやvalueOfがプリミティブ以外を返した場合、それは無効となり、メソッドが無かった場合と同様にもう一方が試されることになります。</p>
  <p>したがって、例えば<code>3 == {toString: function(){ return "3"; }}</code>はtrueとなります。</p>
</div>

<h4 id="anchor-strict-equal">厳密等価演算子</h4>
<p>このように、透過演算子（<code>==</code>）は実は型変換を行ってから一致判定を行っています。ということは、厳密に「同じ」値でないもの（例えば文字列<code>"3"</code>と数値3）を判定してもtrueが返ることがあるということです。このことから、実は<code>==</code>（と<code>!=</code>）はJavaScriptプログラマ達からは嫌われており、実はあまり使われていません。そもそも、勝手に型を変換してしまうというのが直感的な挙動ではありませんね。</p>
<p>そこで、本当に「同じ」値の場合のみtrueを返す比較演算子があります。それが<dfn>厳密等価演算子</dfn>です。これは、<code>===</code>という、イコールを3つ並べた演算子で、使い方は等価演算子(<code>==</code>)と同じです。</p>

<p>厳密等価演算子が普通の演算子とどこが違うかというと、<strong>型が違うものどうしは全てfalseを返す</strong>という点です。等価演算子では、型変換をして調整してくれていましたが、厳密等価演算子は型変換を行わず、全てfalseにされます。等価演算子ではtrueだったnullとundefinedの比較も、falseになります。</p>
<p>この性質により、<code>0 === false</code>や<code>"3" === 3</code>などはfalseを返します。</p>
<p>JavaScript初心者はこの<code>===</code>の存在をあまり知りません。型変換が必要ない場面（というよりそれがほとんどですが）では厳密等価演算子を使うようになれば、一歩ステップアップです。もし型変換が必要な場合、<code>==</code>による暗黙の型変換に頼るのではなく型変換の処理を明示的に書いたほうが分かりやすいと思います。</p>
<p>ただ、普通の等価演算子（<code>==</code>）をよく使われる場面が1つだけあります。それは、<code>何か == null</code>というようにnullと比較する場合です。この場合の動作を正確に述べるならば、左辺の値が<em>undefinedまたはnull</em>のときこの式はtrueとなります。undefinedとnullは別物ですが、この2つを一緒くたに扱って差し支えない場面も多く、そのような場面にこの書き方が使われます。特に、undefinedとnullに共通する特徴は「プロパティを参照しようとするとエラーになる」ことなので、その場合を除外したい場合などにこの比較を用います。</p>
<p>ちなみに、<code>===</code>の否定形は<code>!==</code>です。</p>

<h4>加法演算子</h4>
<p>さて、次は<strong>加法演算子</strong>(<code>+</code>)について見ていきます。今までやたら説明が長かったですが、基礎がわかったのでこれからは簡単です。</p>
<p>ご存知の通り、加法演算子には2つの機能があります。1つは<code>3 + 5</code>のような<b>数値の加算</b>で、もう1つは<code>"foo" + "bar"</code>のような<b>文字列の連結</b>です。</p>
<p>これらは両方ともプリミティブ同士の演算であるということで、まず最初に両辺のオブジェクトはプリミティブに変換されます。これはvalueOf優先です。</p>
<p>ここで、どちらか一方でも<strong>文字列</strong>であれば文字列の連結となりなす。この場合、もう片方が文字列以外の場合は文字列に変換されます。</p>
<p>どちらも文字列でない場合（すなわち数値、真偽値、null、undefinedの場合）、数値の加算となり両辺が数値に変換されます。</p>
<p>例えば、<code>2 + true</code>はtrueが1に変換されるので3です。また、<code>"2" + true</code>の場合、trueは文字列に変換されるので<code>"2true"</code>になります。</p>

<h4>その他の算術演算子</h4>
<p>加法演算子以外の四則演算（具体的には<code>-</code>，<code>*</code>，<code>/</code>，<code>%</code>）は、文字列の連結機能がないのでもっと単純です。両辺は必ず数値に変換されます。</p>
<p>そこで、数値以外を数値に変換する手軽な方法として、「0を引く」というものがあります。そうすれば減法演算子が左辺を数値に変換してくれて、0を引いても変わらないので結果左辺を数値に変換できたことになります。</p>
<pre><code>
console.log(true - 0); // 1
</code></pre>
<p>また、falseも0に変換されるので、falseを引いてもいいです。</pre>
<pre><code>
console.log(true-false); // 1
</code></pre>
<p>こうすれば、一目見ただけでは何がしたいのか分かりません。コードを汚くするのに一役かってくれます。</p>

<h4 id="anchor-nan">NaN</h4>
<p>ただ、ひとつ注意したいのが、<strong>NaN</strong>の存在です。今回の説明では<b>NaN</b>が出てきました。これは、数値への変換の結果として現れることがある<em>特殊な数値</em>です。NaNという名前は<i lang="en">Not a Number</i>（数値ではない）から来ており、数値ではないのに数値という不思議な値です。これは、必ず数値へ変換しなければならないのに数値への変換は不可能という困った状況をなんとかするために存在します。また、数値の演算の結果を数値で表せない場合にもNaNとなります（例えば<code>0 / 0</code>など）。</p>
<p>例えば、<code>"foo"</code>という文字列は数値を表す文字列ではないので数値に変換できません。例えば<code>"foo" - 0</code>とすると<code>"foo"</code>がNaNに変換されるため結果はNaNとなります。確かめてみましょう。</p>
<p>なお、NaNを含む四則演算は全てNaNになります。たとえば<code>0 + NaN</code>や<code>NaN * 3</code>はNaNになります。</p>

<p>NaNの他の特徴は、NaNを含む比較演算の結果は必ずfalseとなることです。<code>3 &lt; NaN</code>や<code>NaN &lt;= 3</code>などはfalseになります。さらに驚くべきことに、<code>NaN === NaN</code>ですらfalseになります。</p>
<p>NaNはプログラム上では<code>NaN</code>と書くと取得できます。これはundefinedと同様、NaNという変数にNaNが入っています。また、<code>Number.NaN</code>としても取得できます（つまり、NumberオブジェクトのプロパティNaNにNaNが入っています）。後者のほうが新しくて推奨されています。</p>

<p>前述の理由から、ある数<code>x</code>がNaNかどうか判定するのに<code>x === NaN</code>という方法は使えません。NaNは<code>x !== x</code>となる唯一の値なのでこの方法でもよいのですが、もっとスマートな方法があります。それは、<code>isNaN</code>（または<code>Number.isNaN</code>）です。これは、引数がNaNのときのにtrueを返す組み込み関数です。すなわち、<code>isNaN(x)</code>とすることでxがNaNかどうか判定できます。</p>

<p>NaNは前述のように、数値に変換できない値を数値に変換しようとしたときや、おかしな演算をした場合に発生します。意図せずNaNが発生した場合はこのような箇所を疑いましょう。</p>

<h3>プリミティブの変換方法</h3>
<p>今回はプリミティブの変換を扱いました。それは<code>==</code>や<code>+</code>などの、プリミティブを扱う演算子に値が渡されたときに発生します。しかし、もっと明示的にプリミティブの変換を行う方法が存在します。それは、次のような方法です。</p>
<pre><code>
String(x)  // xを文字列に変換した値を返す
Number(x)  // xを数値に変換した値を返す
Boolean(x) // xを真偽値に変換した値を返す
</code></pre>
<p>先ほども出てきたString, Number, Booleanは、コンストラクタの名前だったはずです。しかし今回、これらは普通の関数として使われています。これらの関数は特殊で、普通の関数としての用法とコンストラクタとしての用法を持っています。組み込み関数はこのような動作をするものが他にもあります。<small>（ここでは解説しませんが、そのような関数を自分で作ることもできます。）</small></p>
