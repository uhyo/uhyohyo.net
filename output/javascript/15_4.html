<!doctype html>
<html lang="ja-jp">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <link href="/css/css.css" rel="stylesheet">
                  <link href="/css/js.css" rel="stylesheet">
                        <title>十五章第四回　Resource Timing — JavaScript初級者から中級者になろう &#x2014; uhyohyo.net</title>
        <script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-46093038-1', 'auto');
ga('send', 'pageview');
    </script>
  </head>
  <body>
    <header>
      <h1>
        <a href="/">uhyohyo.net</a>
      </h1>
    </header>
    <main>
      
<article> 
  <h1>JavaScript初級者から中級者になろう</h1>
  <aside class="ad-javascript">
    <!-- Google Adsense -->
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:inline-block;width:180px;height:150px"
     data-ad-client="ca-pub-1080533149094679"
     data-ad-slot="7536196754"></ins>
    <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
  </aside>
        <nav>
      <p>
        <a href="index.html" rel="bookmark">戻る</a>
                            |
          <a rel="prev" href="15_3.html">十五章第三回</a>
                          |
          <a rel="next" href="15_5.html">十五章第五回</a>
              </p>
    </nav>
    <h2>十五章第四回　Resource Timing</h2>
<p><a href="15_3.html">前回</a>の続きです。前回はPerformanceEntryオブジェクトの扱い方を紹介しました。今回はその具体例です。</p>

<p>Resource Timingという仕様では、Webページからimg要素やlink要素によって読み込まれたリソースについて、それにかかった時間などを知ることができます。これは、<a href="15_2.html">一五章第二回</a>で紹介したnavigation Timingと似ていますね。あちらはページ本体に読み込みにかかった時間であり、本体が読み込み完了してHTMLのパース・DOMの構築まで終わったら読み込み完了としていたので、外部リソースに読み込みにかかった時間までは測れませんでした。</p>

<h3>PerformanceRequestTiming</h3>
<p>Resource Timingでは、ページから読み込まれた外部リソース一つ一つについて<dfn>PerformanceRequestTiming</dfn>オブジェクトが作成され、Performanceオブジェクトに登録されます。このPerformanceRequestTimingというのは、前回紹介したPerformanceEntryを継承したオブジェクトです。このページもCSSなどを読み込んでいますので、試しに次のコードを実行してみると、PerformanceRequestTimingオブジェクトがいくつも入った配列が得られるのがわかります。<small>注：現在（2014年7月）対応しているのはGoogle Chrome, Opera, IE11でした。</small></p>
<pre><code>console.log(performance.getEntries());</code></pre>
<p>それではこのPerformanceRequestTimingからはどんな情報が得られるのでしょうか。プロパティを次に列挙してみました。</p>
<dl>
  <dt>initiatorType</dt>
  <dd>そのリソースが何によって読み込まれたか。HTML要素ならばその要素名、CSSならば<code>"css"</code>、XMLHttpRequestならば<code>"xmlhttprequest"</code>になる。
  <dt>redirectStart</dt>
  <dd>リダイレクトがあった場合、一番最初のリソースにアクセスした瞬間の時間です。リダイレクトが無かった場合は0です。</dd>
  <dt>redirectEnd</dt>
  <dd>リダイレクトがあった場合、最後のリダイレクトページから受信を完了した瞬間の時間です。リダイレクトが無かった場合は0です。</dd>
  <dt>fetchStart</dt>
  <dd>リソースへのアクセスを開始した瞬間です。これは厳密には、URLの文字列解析を開始する瞬間と（多くの場合）一致します。</dd>
  <dt>domainLookupStart</dt>
  <dd>URLの解析が終わり、DNSサーバーに問い合わせを開始した瞬間です。</dd>
  <dt>domainLookupEnd</dt>
  <dd>DNSサーバーとの通信が終了した瞬間です。</dd>
  <dt>connectStart</dt>
  <dd>リソースのあるサーバーへの通信を開始した瞬間です。</dd>
  <dt>connectEnd</dt>
  <dd>サーバーへの通信を確立した瞬間です。</dd>
  <dt>secureConnectionStart</dt>
  <dd>HTTPS通信の場合、ハンドシェイクを開始した瞬間です（ブラウザによってはサポートしないこともあるようです）。HTTPS通信でない場合は0です。</dd>
  <dt>requestStart</dt>
  <dd>サーバーへリクエストを送信し始める瞬間です。</dd>
  <dt>responseStart</dt>
  <dd>サーバーからレスポンスの最初の1バイトを受信した瞬間です。</dd>
  <dt>responseEnd</dt>
  <dd>サーバーからレスポンスを最後まで受信した瞬間です。</dd>
</dl>
<p>こうしてみると<a href="15_2.html">十五章第二回</a>を思い出しますね。さらに、PerformanceEntryにもともとあるプロパティがどのような値をとるかを次で紹介します。</p>
<dl>
  <dt>name</dt>
  <dd>nameプロパティには、<b>リソースのURL</b>が入っています。</dd>
  <dt>entryType</dt>
  <dd>entryTypeプロパティは<code>"resource"</code>で固定です。これは、このPerformanceEntryがPerformanceRequestTimingであることを示す値になっています。</dd>
  <dt>startTime</dt>
  <dd>redirectStartが有効な場合はその値、そうでなければfetchStartの値です。</dd>
  <dt>duration</dt>
  <dd>responseEndとstartTimeの差です。</dd>
</dl>
<p>つまり、そのリソースを取得するのにどれだけ時間がかかったかを調べるには結局durationの値を見れば十分なわけですね。より細かく遅い原因を調べたいときなど、他のプロパティの値を調べることがあるかもしれません。</p>
<p>ちなみに、時間というのは、<code>performance.timing.navigationStart</code>（<a href="15_2.html">十五章第二回</a>で紹介）の時刻を0とするミリ秒単位の時間で表されます。なので、これらの値を利用して絶対時間を求めることが可能ですが、基本的には2つの値の差をとって使います。</p>
<p>また、initiatorTypeプロパティについて補足しておくと、例えばimg要素で画像を読み込む場合はこの値は<code>"img"</code>になるし、link要素でCSSファイルを読み込む場合は<code>"link"</code>です。また<code>"iframe"</code>などもありえます。CSSのbackground-imageなどで画像ファイルを読み込む場合は、CSSファイル経由で読み込まれているので<code>"css"</code>ですね。</p>
<p>ただ、やはりJavaScript他の<b>オリジン</b>の情報には厳しくて、他のオリジンのリソースの場合にはfetchStartとresponseEndの値以外は軒並み0になってしまいます。この2つが有効なのでdurationなどは取得することができますが、他の値は役に立ちません。ただし、リソースをHTTPで読み込む際に<code>Timing-Allow-Origin</code>ヘッダがある場合は、他のオリジンであっても時間の情報を取得することができます。これは、<a href="13_1.html">十三章第一回</a>で紹介したAccess-Control-Allow-Originヘッダと似ています。</p>

<h3>Performanceオブジェクトの拡張</h3>
<p>実は、PerformanceオブジェクトはResource Timing関連のメソッド等を持っています。</p>
<p>一つは<dfn>clearResourceTimings</dfn>（引数なし）です。これは、Performanceに登録されているPerformanceRequestTimingオブジェクトを消去してしまいます。</p>
<p>もう一つは<dfn>setResourceTimingBufferSize</dfn>です。これは引数に数値を指定することで、「最大何件までPerformanceRequestTimingオブジェクトを保存するか」を設定できます。</p>
<p>実は、デフォルトでは150件まで保存されることになっています。これは、やはり情報を保存するというのはメモリを食うので、何らかの形で制限する必要があるからでしょう。</p>
<p>それだと困るという場合には、こちら側から数を増やしてやることもできます。</p>
<p>また、実はPerformanceオブジェクトはEventTargetであるので、イベントが発生することがあります。Performanceオブジェクトで発生するイベントの一つが<dfn>resourcetimingbufferfull</dfn>イベントです。
  これは、PerformanceRequestTimingが保存できる最大件数に達した場合に発生します。このイベントが発生したらそれに併せてsetResourceTimingBufferSizeメソッドで数を増やすということも可能ではありますね。</p>
<pre><code>performance.addEventListener("<mark>resourcetimingbufferfull</mark>",function(e){
  //最大件数に達した場合の処理
});</code></pre>
<p>addEventListenerを使ってイベントを登録する方法のほかに、次のようにイベントハンドラを直接プロパティにセットする方法もあります。</p>
<pre><code>performance.<mark>onresourcetimingbufferfull</mark>=function(e){
};</code></pre>

<p>以上でResource Timingに関して紹介すべきことは終了です。最後にサンプルを用意しました。このページから読み込まれたリソースを列挙するサンプルです。</p>
<pre><code>window.addEventListener("<mark>load</mark>",function(e){
  //ページ内に&lt;div id="resultarea"&gt;&lt;/div&gt;をあらかじめ用意しておく
  setTimeout(function(){
    var div=document.getElementById("resultarea");

    var entries=performance.getEntriesByType("<mark>resource</mark>");
    entries.forEach(function(obj){
      //objはPerformanceRequestTimingオブジェクト
      var p=document.createElement("p");
      p.textContent=obj.name+"を"+obj.duration.toFixed(2)+"ミリ秒かけて読み込みました";
      div.appendChild(p);
    });
  },1000);
},false);</code></pre>
<p>最初の<b>loadイベント</b>というのは、ページ本体の読み込みが完了したときに発生するイベントでしたね。ここではとりあえず、読み込み時間を考慮して1000ミリ秒待った後で実行しています。これを実際にこのページで動かしてみた結果が以下です。</p>
<div id="resultarea" style="margin:1em;padding:1em;border:2px solid black"></div>
<script>
window.addEventListener("load",function(e){
  setTimeout(function(){
    var div=document.getElementById("resultarea");

    var entries=performance.getEntriesByType("resource");
    entries.forEach(function(obj){
      //objはPerformanceRequestTimingオブジェクト
      var p=document.createElement("p");
      p.textContent=obj.name+"を"+obj.duration.toFixed(2)+"ミリ秒かけて読み込みました";
      div.appendChild(p);
    });
  },1000);
},false);
</script>
<p>こんな感じでリソースに関する情報を取得することができます。</p>
<p>次回も関連した話です。</p>
        <nav>
      <p>
        <a href="index.html" rel="bookmark">戻る</a>
                            |
          <a rel="prev" href="15_3.html">十五章第三回</a>
                          |
          <a rel="next" href="15_5.html">十五章第五回</a>
              </p>
    </nav>
  </article>

    </main>
  </body>
</html>
    
