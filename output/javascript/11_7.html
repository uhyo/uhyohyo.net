<!doctype html>
<html lang="ja-jp">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <link href="/css/css.css" rel="stylesheet">
                  <link href="/css/js.css" rel="stylesheet">
                        <title>十一章第七回　継承2 — JavaScript初級者から中級者になろう &#x2014; uhyohyo.net</title>
        <script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-46093038-1', 'auto');
ga('send', 'pageview');
    </script>
  </head>
  <body>
    <header>
      <h1>
        <a href="/">uhyohyo.net</a>
      </h1>
    </header>
    <main>
      
<article> 
  <h1>JavaScript初級者から中級者になろう</h1>
  <aside class="ad-javascript">
    <!-- Google Adsense -->
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:inline-block;width:180px;height:150px"
     data-ad-client="ca-pub-1080533149094679"
     data-ad-slot="7536196754"></ins>
    <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
  </aside>
        <nav>
      <p>
        <a href="index.html" rel="bookmark">戻る</a>
                            |
          <a rel="prev" href="11_6.html">十一章第六回</a>
                          |
          <a rel="next" href="12_1.html">十二章第一回</a>
              </p>
    </nav>
    <h2>十一章第七回　継承2</h2>
<p>継承については<a href="9_3.html">九章第三回</a>で解説しましたが、じつはあれは今では少し古い方法となっています。第十一章のテーマはECMAScript5なので、ECMAScript5で登場したよりよい継承の方法について説明します。</p>

<p>継承の仕組みは既に説明しました。すなわち、各インスタンスはコンストラクタのprototypeに結びついていて、インスタンスのプロパティを探すときは、自分のプロパティに無かったらprototypeのプロパティを探しに行くのでしたね。</p>
<pre><code>function Teki(n){
  this.name = n;
}
//現れる
Teki.prototype.appear = function(){
  console.log(this.name + "があらわれた！");
};

var zako1 = new Teki("ザコ敵");	//敵をつくる
zako1.appear();	//現れる

console.log(zako1.name);	<mark class="ins">//"ザコ敵"</mark>
console.log(zako1.hasOwnProperty("name"));	<mark class="ins">//true</mark>
console.log(zako1.hasOwnProperty("appear"));	<mark class="ins">//false</mark>
        </code></pre>
<p>このzako1はnameとappearという2つのプロパティがありますが、前にもみたようにnameとappearでは少し性質が違いましたね。nameを代入しているのはTekiコンストラクタ内です。</p>
        <pre><code>var zako1=new Teki("ザコ敵");</code></pre>
<p>の行で</p>
        <pre><code>this.name = n;</code></pre>
<p>として代入しています。このthisはnewの返り値となるべきオブジェクトで、zako1になるものです。つまり、nameプロパティはzako1に直接くっついているわけです。</p>
<p>一方、</p>
        <pre><code>zako1.appear=...</code></pre>
<p>というような記述はありませんね。appearの実態はTeki.prototype.appearです。</p>
<p>ここでまず、新しいメソッド<dfn>Object.getPrototypeOf</dfn>を紹介します。これはインスタンスを引数に渡すと、対応するprototypeオブジェクトが返ってくるわけです。つまり、zako1の場合はTekiのインスタンスですから、Teki.prototypeが返ってくるわけです。</p>
        <pre><code>console.log(Object.<mark>getPrototypeOf</mark>(zako1) === Teki.prototype);	<mark class="ins">//true</mark></code></pre>

<p>このように、インスタンスの側からprototypeを取得できるのは今までに無かった、ECMAScript5の新しい機能です（ただし、非標準の__proto__というやつはありました）。</p>
<p>ついでに、<dfn>isPrototypeOf</dfn>も紹介しておきます。これはObject.prototypeにあるメソッドなので、全てのオブジェクトが持っています。これは、そのオブジェクトが、引数に渡したオブジェクトのprototypeであるかを判定して真偽値を返します。いま、zako1のプロトタイプに当たるのはTeki.prototypeなので次のようになります。</p>
        <pre><code>console.log(Teki.prototype.<mark>isPrototypeOf</mark>(zako1));	<mark class="ins">//true</mark></code></pre>
<p>また、このメソッドはプロトタイプチェーンをさかのぼって検証してくれます。例えば次のサンプルです。</p>
<pre><code>//敵を作る
function Teki(){
}

//ドラゴンを作る
function Dragon(){
  Teki.apply(this,arguments);
}
Dragon.prototype = new Teki;

var boss = new Dragon();	//インスタンスをつくる

console.log(Dragon.prototype.<mark>isPrototypeOf</mark>(boss));	<mark class="ins">//true</mark>
console.log(Teki.prototype.<mark>isPrototypeOf</mark>(boss));	<mark class="ins">//true</mark></code></pre>

<p>これは、bossはDragon.prototypeにあるメソッドを使えるし、Teki.prototypeにあるメソッドも使えると解釈することができます。実はこれはinstanceofを使っても同じことができますね。instanceofとの違いは、コンストラクタに対して使うかprototypeオブジェクトに対して使うかですね。</p>
<pre><code>console.log(boss instanceof Dragon);	<mark class="ins">//true</mark>
console.log(boss instanceof Teki);	<mark class="ins">//true</mark></code></pre>

<p>さて、ここでいよいよ本題の継承がでてきました。継承にかかわるのはDragonコンストラクタ内の</p>
        <pre><code>Teki.apply(this,arguments);</code></pre>
<p>と、プロトタイプの</p>
        <pre><code>Dragon.prototype = new Teki;</code></pre>
<p>のところでしたね。</p>
<p>実は、後者に問題があるのです。そもそもコンストラクタというのは、そのオブジェクトが作られたときの処理を表すものでしたね。ですから、Tekiコンストラクタにログを残す処理を書いてみましょう。</p>
<pre><code>function Teki(){
  <mark class="ins">console.log("新しい敵オブジェクトができました。");</mark>
}

//ドラゴンを作る
function Dragon(){
  Teki.apply(this,arguments);
}
Dragon.prototype = new Teki;

var zako = new Teki();
var boss = new Dragon();</code></pre>
<p>これを実行すると、「新しい敵オブジェクトができました。」というログは<strong>3回</strong>でますね。でも、敵オブジェクトを作ったのはzakoとbossの2つだけのはずですね。</p>
<p>もう1回は何なのでしょうか。</p>
<p>もうお分かりだと思いますが、</p>
        <pre><code>Dragon.prototype = new Teki;</code></pre>
<p>の行で一度Tekiのインスタンスを作っていましたね。これが一番最初のログだったのです。</p>
<p>しかしこれは困りますよね。コンストラクタが呼ばれた時にもっと複雑な処理をしたい場合、実際にインスタンスを作ったわけではないのに（プログラム上は確かに作ってますが意味合いが違いますよね）コンストラクタが呼ばれたら不都合だという場合も多いことでしょう。</p>
<p>そこで、この問題を解決する方法があります。それが<dfn>Object.create</dfn>です。これは第一引数にプロトタイプオブジェクトを指定すると、それをプロトタイプに持つオブジェクトを作成します。つまりこんな具合です。</p>
        <pre><code>var zako2=<mark>Object.create</mark>(Teki.prototype);</code></pre>
<p>このzako2を調べると、new Tekiとしてインスタンスを作った場合と同じ結果になります。</p>
        <pre><code>console.log(Teki.prototype.isPrototypeOf(zako2));	<mark class="ins">//true</mark></code></pre>

<p>ただし、newを使って作った場合とObject.createを作った場合では一つ違いがあります。Object.createの場合は<strong>コンストラクタが呼ばれません</strong>。つまり、さっきの<code>var zako2=Object.create(Teki.prototype);</code>を実行しても「新しい敵オブジェクトができました。」というログは出ません。</p>
<p>それ以外はnewを使った場合と同じです。zako2はTekiのインスタンスになっています。</p>
<p>newを使っていないのにインスタンスができるというのは不思議かもしれませんが、そもそもオブジェクトが他のコンストラクタのインスタンスであるかどうかは、オブジェクトと関連付けられたprototypeオブジェクトのみによって特徴付けられます。</p>
<p>例えばこのzako2を例にした場合、</p>
        <pre><code>Object.getPrototypeOf(zako2)===Teki.prototype	<mark class="ins">//true</mark></code></pre>
<p>です。これは<code>zako2 instanceof Teki</code>と同値です。だから、newを使っていないけれどもzako2は確かにTekiのインスタンスだということができます。</p>

<p>ちなみに、Object.createでインスタンスを作ったあとに別にコンストラクタを呼べば、newを使わずにnewの挙動を再現することができます。</p>
<pre><code>var zako2=Object.create(Teki.prototype);
Teki.call(zako2);</code></pre>
<p>2行目のcallは、Teki関数を、zako2をthisとして引数なしで呼べという意味ですね。コンストラクタはnewで呼ばれるときはthisの値が特別になっていたので、call（またはapply）を使ってそれを再現すればできます。</p>

<p>さて、このObject.createを使えば、上述の問題を回避して継承することができます。具体的には、</p>
        <pre><code>Dragon.prototype = <strong>Object.create</strong>(Teki.prototype);</code></pre>
<p>とすればいいのです。こっちのほうが不都合が少ないので、継承するときはこうするとよいでしょう（ただしIE8以下では動きませんが）。</p>

<p>ちなみに、Object.createには第二引数もあります。これは<a href="11_4.html">十一章第四回</a>で解説したObject.definePropertiesの第二引数と同じ形のオブジェクトを渡すことができます。つまり、インスタンスを作った後に、第二引数で指定されたようにプロパティをセットして返してくれるのです。これを使って、<code>Dragon.prototype.attack=...</code>というように代入していくのではなく、Object.createで全て済ませるやり方も可能です。例えばこんな感じです。</p>
<pre><code>function Dragon(){
  Teki.apply(this,arguments);
}
Dragon.prototype=Object.create(Teki.prototype,{
  attack:{
    configurable:true,
    value:function(){
      console.log("ドラゴンのこうげき！！");
    },
  },
});</code></pre>

<h3>constructorプロパティ</h3>
<p>最後に、継承をするときは<dfn>constructorプロパティ</dfn>についても気をつける必要があります。これについても紹介します。</p>
<p>実は、constructorプロパティを使えばインスタンスのコンストラクタが何か調べることができます。例えば次のコードです。</p>
<pre><code>//敵を作る
function Teki(){
}

var zako=new Teki();
console.log(zako.<mark>constructor</mark> === Teki);	<mark class="ins">//true</mark></code></pre>

<p>しかし、zakoにconstructorなんてプロパティを付けた覚えはありませんよね。ということは、これはprototypeにあるプロパティです。</p>
        <pre><code>console.log(Teki.prototype.hasOwnProperty("constructor"));	<mark class="ins">//true</mark></code></pre>
<p>実は、関数が作られた時点で、その関数のprototype.constructorにはその関数自身が自動的に入っている状態になります。</p>
<p>ところが、継承した場合を見てみましょう。</p>
<pre><code>function Teki(){
}
function Dragon(){
  Teki.apply(this,arguments);
}
Dragon.prototype=Object.create(Teki.prototype);

var boss=new Dragon();
console.log(boss.constructor);</code></pre>
<p>ここではDragonが出てきて欲しいのに、表示されるのはTekiです。これはなぜかというと、最初関数DragonができたときはちゃんとDragon.prototype.constructorにはDragonが入っていたのですが、直後にDragon.prototypeに代入してしまっていますね。代入されたのはTekiのインスタンスでしたから、Dragon.prototype.constructorを調べることはTekiのインスタンスを調べるのと同じで、さっきのzako.constructorを調べているのと同じようなものだったのです。だからTekiがでたわけです。</p>
<p>とはいえ、これだと困りますね。正しくDragonが表示されるようにする必要があります。そのためには、自分で代入しましょう。</p>
<pre><code>function Teki(){
}
function Dragon(){
  Teki.apply(this,arguments);
}
Dragon.prototype=Object.create(Teki.prototype,<mark class="ins">{
  <mark>constructor</mark>:{
    value:Dragon
  }
}</mark>);

var boss=new Dragon();
console.log(boss.constructor);</code></pre>
<p>こうすれば、boss.constructorがDragonとなり正しくなります。</p>

<p>結局、今回のポイントは2つでした。継承するときはObject.createを使うことと、constructorに正しいコンストラクタを入れてあげることです。</p>
        <nav>
      <p>
        <a href="index.html" rel="bookmark">戻る</a>
                            |
          <a rel="prev" href="11_6.html">十一章第六回</a>
                          |
          <a rel="next" href="12_1.html">十二章第一回</a>
              </p>
    </nav>
  </article>

    </main>
  </body>
</html>
    
