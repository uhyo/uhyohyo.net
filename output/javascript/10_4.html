<!doctype html>
<html lang="ja-jp">
  <head>
    <meta charset="UTF-8">
    <link href="/css/css.css" rel="stylesheet">
                  <link href="/css/js.css" rel="stylesheet">
                        <title>十章第四回　述語による絞り込み — JavaScript初級者から中級者になろう &#x2014; uhyohyo.net</title>
        <script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-46093038-1', 'auto');
ga('send', 'pageview');
    </script>
  </head>
  <body>
    <header>
      <h1>
        <a href="/">uhyohyo.net</a>
      </h1>
    </header>
    <main>
      
<article> 
  <h1>JavaScript初級者から中級者になろう</h1>
  <aside class="ad-javascript">
    <!-- Google Adsense -->
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:inline-block;width:180px;height:150px"
     data-ad-client="ca-pub-1080533149094679"
     data-ad-slot="7536196754"></ins>
    <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
  </aside>
        <nav>
      <p>
        <a href="index.html" rel="bookmark">戻る</a>
                            |
          <a rel="prev" href="10_3.html">十章第三回</a>
                          |
          <a rel="next" href="10_5.html">十章第五回</a>
              </p>
    </nav>
    <h2>十章第四回　述語による絞り込み</h2>
<p>今回は述語(Predicates)について解説します。</p>

<h3>述語とは</h3>
<p>今まで、</p>
        <pre><code>/html/body/child::p</code></pre>
<p>のように、XPathの式を軸とノードテストで記述してきました。軸で大まかに絞り込み、ノードテストでさらに絞り込んできたのです。</p>
<p>といっても、ノードテストで絞り込めるのはせいぜい要素名とか属性名くらいです。もっと細かい条件を指定したい場合もあることでしょう。そういったときに使うのが<dfn>述語</dfn>です。</p>
<p>述語の描き方は、</p>
      <pre><code>/html/body/child::p<mark>[1]</mark></code></pre>
<p>のように、<code>[ ]</code>で囲んだ式をくっつけます。</p>

<h3>述語が数字の場合</h3>
<p>この場合、式といってもただの数字です。</p>
<p>述語が数字の場合、絞りこまれて候補に上がったノードのうち、その番号のもの1つに絞られます。この順番は文書順です。</p>
<p>つまり、今回の場合は「1番目」ということになります。配列などと違い、<strong>1番目が一番最初</strong>なので注意しましょう。</p>
<p>つまり、この式は、body要素の子のp要素のうち一番最初のp要素の1つだけからなるノードセットを表すというわけです。</p>

<p>また、次のような書き方もあります。</p>
      <pre><code>/html/body/p[<mark>last()</mark>]</code></pre>
<p>ここで関数が出てきました。この関数<dfn>last</dfn>は、ノードセットの<strong>一番最後の番号</strong>を返すというものです。</p>
<p>つまり、これはbodyの子のうち一番最後のp要素を表しているということです。</p>
<p>他にも、</p>
      <pre><code>/html/body/p[last() <mark>-</mark> 1]</code></pre>
<p>のように、演算子<code>-</code>を使って、「一番後ろの1つ前」を表したりもできます。</p>

<h3>述語が真偽値の場合</h3>
<p>述語は<strong>真偽値</strong>の場合もあります。この場合、絞りこまれて候補に上がったノードのうち、<strong>述語がtrueになるもの</strong>だけが当てはまります。</p>
<p>例えば、</p>
      <pre><code>/html/body/p[position() &lt;= 2]</code></pre>
<p>というのがあります。ここで、<dfn>position</dfn>関数は、そのノードの番号を返します。つまり、position()が2以下、すなわち1番目と2番目のノードのみが当てはまるということです。</p>
<p>また、さっきの数値の場合も、<code>/html/body/p[1]</code>は<code>/html/body/p[<mark>position()=</mark>1]</code>と同じだということができます。</p>
<p>ここで、XPathでは、<code>==</code>ではなく<code>=</code>で等しいかどうか比較できることに注意しましょう。<code>!=</code>はXPathでも同じです。</p>

<h3>属性による絞り込み</h3>
<p>ノードのうち、属性による絞り込みをしたい場合は次のようにします。例として、lang属性が"ja"であるp要素のみを集めるには、次のようにします。</p>
      <pre><code>/html/body/p[<mark>attribute::lang</mark>="ja"]</code></pre>
<p>attribute::langはlang属性ですが、属性を取得するにはattribute軸を使うのでした。</p>
<p>attribute軸が使えるということは、当然他の軸も使えるのですが、それではどのノードを基準にするのでしょうか。</p>
<p>それはもちろん、ノードテストによって絞りこまれた各ノードです。つまり、</p>
      <pre><code>/html/body/p</code></pre>
<p>によって絞りこまれたbodyの子のp要素それぞれについて、そのattribute::langを取得して、それが"ja"であればtrueになるので、結果としてbodyのp要素のうちlang属性が"ja"であるものが取得されます。</p>
<p>ここで、attribute::langで取得できるのは、Attrというノードであるということを前回解説しました。つまり、<code>attribute::lang="ja"</code>というのはノードセットと文字列を比較していることになります。</p>
<p>こういったときは、<strong>型変換</strong>が行われます。ノードセットと文字列を比較する場合、ノードセットを文字列に変換して比較します。型変換というのは、<a href="9_7.html">九章第七回</a>でも登場した概念ですね。</p>
<p>それでは、ノードセットを文字列に変換するとはどういうことでしょう。実は、各ノードを一つずつ文字列に変換して、<strong>一つでも等しいものがあれば</strong>trueになります。ノードを文字列に変換するときには、その子孫のテキストノードを全て連結します。例えば、</p>
      <pre><code>&lt;p&gt;abc&lt;span&gt;def&lt;/span&gt;ghi&lt;/p&gt;</code></pre>
<p>というp要素を文字列に変換した場合、"abcdefghi"となります。今回の場合属性ですが、属性の場合はその値そのままです。</p>
<p>今回の場合1つずつのp要素についてlang属性を処理しているので、ノードセットはノードが1つだけです。だから、結局lang属性が"ja"かどうか判定しているということです。</p>

<p>これが役立つのは、次の場合です。今回は、その要素に限らず祖先のノードのどれかのlang属性が"ja"であればいいということにしてみます。</p>
      <pre><code>/html/body/descendant::p[ancestor-or-self::*/@lang = "ja"]</code></pre>
<p>今回、まずp要素はdescendant軸です。つまり、bodyの子に限らずbody以下の全てのpから探すということです。</p>
<p>次に、述語の中でancestor-or-self軸が使われています。この軸は、自身とその親以上全てでした。ノードテストは<code>*</code>（全ての要素ノード）なので、p要素とその親全てのノードセットということになります。そして、次の@langはattribute軸で、lang属性です。つまり、ノードセットのノードそれぞれに対してlang属性が取得され、それらのノードセットができあがるということです。</p>
<p>そして、できあがった属性のノードセットと"ja"を比較しているので、lang属性の中に一つでも"ja"があればtrueになり、p要素は当てはまるというわけです。</p>

<p>ところで、今まで見てきた通り、ノードセットと文字列を=で比較すると、1つでも等しいものがあればtrueになります。これを、「全て等しければtrue、他はfalse」とするにはどうすればよいでしょう。</p>
<p>それは、次のようにします。</p>
      <pre><code><mark>not</mark>(ノードセット != "文字列")</code></pre>
<p>notは、JavaScriptでいうところの!のような関数で、trueならfalse、falseならtrueです。一方、!=は、=と同じで「一つでも違えばtrue」です。つまり、全て同じならfalseになるので、これをnotで反転してtrueにすればよいのです。</p>

<p>最後に、述語は次のように複数指定して、条件を複数もたせることができます。</p>
      <pre><code>/html/body/p[@lang="ja"][last()]</code></pre>
<p>まず、ノードテストでbodyの子のpに絞りこまれ、次の述語でlang属性が"ja"のものに絞りこまれ、その次の述語で、<strong>絞りこまれたp要素のうち</strong>最後のp要素になります。</p>
        <nav>
      <p>
        <a href="index.html" rel="bookmark">戻る</a>
                            |
          <a rel="prev" href="10_3.html">十章第三回</a>
                          |
          <a rel="next" href="10_5.html">十章第五回</a>
              </p>
    </nav>
  </article>

    </main>
  </body>
</html>
    
