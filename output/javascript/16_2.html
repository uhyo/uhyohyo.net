<!doctype html>
<html lang="ja-jp">
  <head>
    <meta charset="UTF-8">
    <link href="/css/css.css" rel="stylesheet">
                  <link href="/css/js.css" rel="stylesheet">
                        <title>十六章第二回　イテレータ — JavaScript初級者から中級者になろう &#x2014; uhyohyo.net</title>
        <script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-46093038-1', 'auto');
ga('send', 'pageview');
    </script>
  </head>
  <body>
    <header>
      <h1>
        <a href="/">uhyohyo.net</a>
      </h1>
    </header>
    <main>
      
<article> 
  <h1>JavaScript初級者から中級者になろう</h1>
  <aside class="ad-javascript">
    <!-- Google Adsense -->
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:inline-block;width:180px;height:150px"
     data-ad-client="ca-pub-1080533149094679"
     data-ad-slot="7536196754"></ins>
    <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
  </aside>
        <nav>
      <p>
        <a href="index.html" rel="bookmark">戻る</a>
                            |
          <a rel="prev" href="16_1.html">十六章第一回</a>
                          |
          <a rel="next" href="16_3.html">十六章第三回</a>
              </p>
    </nav>
    <h2>十六章第二回　イテレータ</h2>
<p>今回は<strong>イテレータ</strong>を紹介します。イテレータ（<span lang="en">iterator</span>）とはその名の通り、繰り返し処理できるものです。</p>
<p>そう言われて思い浮かぶのは<b>配列</b>でしょう。例えばfor文なんかでループを回して1つずつ処理するというのは極めてよくあるパターンです。</p>
<p>他にも<b>文字列</b>なども、1文字ずつ処理するという場合はイテレータと見なせます。</p>
<p>ES6ではこれらを抽象化して<b>イテレータ</b>として仕様化されました。</p>

<h3>for-of文</h3>
<p><dfn>for-of文</dfn>とは、イテレータの中身を1つずつ取り出して処理する文です。その名前から連想される通り、for文やfor-in文と似た使い方ができます。次の例を見てください。</p>
<pre><code>var arr=[0,1,2,3,4];
<mark>for</mark>(var value <mark>of</mark> arr){
  console.log(value);
}</code></pre>
<p>この文を実行すると、0から4までが順番に出力されます。この動作は分かりやすいですね。</p>
<p>なお、配列は厳密にはイテレータではありませんが、for-of文は与えられたものをイテレータに変換してから処理します（この表現も厳密には正確ではありませんが）。まだイテレータがどのように定義されるか解説していないので微妙ですが、配列からイテレータへの変換は明らかですね。同様に文字列もイテレータに変換できます。</p>

<pre><code><mark>for</mark>(var value <mark>of</mark> "foobar"){
  console.log(value);
}</code></pre>

<p>この場合は文字列に含まれる文字が1文字ずつ出力されます。</p>
<p>なお、for-of文でもcontinue文やbreak文が使用可能です。</p>

<h3>イテレータオブジェクト</h3>
<p>イテレータもやはりオブジェクトです。for-of文では内部的に配列をイテレータに変換するためイテレータオブジェクトを直接触ることができませんでしたが、直接触る方法もあります。</p>
<p>配列の場合、<dfn>values</dfn>メソッドによりイテレータを得ることができます。イテレータは<dfn>next</dfn>メソッドを持ちます。nextメソッドは「次」の値を取得することを意味します。</p>
<p>試しに呼んでみましょう。</p>
<pre><code>var iterator = [1,2,3,4,5].<mark>values</mark>();
console.log(iterator.<mark>next</mark>());</code></pre>
<p>nextメソッドの結果はオブジェクトです。この場合、次のような結果になるはずです。</p>
<pre><code>{
  <mark>value</mark>: 1,
  <mark>done</mark>: false
}</code></pre>
<p>イテレータのnextメソッドの返り値は、このように<b>value</b>プロパティと<b>done</b>プロパティを持つオブジェクトになります。valueプロパティがイテレータが返す値です。doneプロパティは真偽値で、繰り返しが「終了」したかどうかを表します。というのも、イテレータの繰り返しには終わりがある場合があります。配列の場合、配列を最後まで読んでしまったらもう次がないですね。このような場合に、もう次がないのにnextメソッドが呼ばれた場合、イテレータはdoneプロパティがtrueのオブジェクトを返します。一般に、その場合はvalueはundefinedになります。</p>
<p>よって、上のfor-of文の例は次のように書くことができます（実際に処理系の内部で起こっていることは少し違うかもしれませんが）。</p>
<pre><code>var iterator=arr.values();
var result;
while(true){
  result=iterator.next();
  if(result.done){
    break;
  }
  console.log(result.value);
}</code></pre>
<p>なお、配列はvaluesメソッドの他に<dfn>keys</dfn>メソッドと<dfn>entries</dfn>メソッドを持ちます。valuesメソッドは配列の各要素を順番に返すイテレータを作りましたが、keysは添字のイテレータを返します。つまり、単に0,1,2,…という値を返すイテレータになります。当然長さ分だけ繰り返したら終了です。</p>
<p>entriesメソッドは添字と値をペアにした配列を値として返します。これは繰り返すときに配列の値でだけでなく添字もほしいときに使えます。具体的には：</p>
<pre><code>for(var arr of ["foo","bar","baz"].<mark>entries</mark>()){
  console.log(arr);
}</code></pre>
<p>というコードを実行すると、次のようなログがでます。</p>
<pre><code>[0,"foo"]
[1,"bar"]
[2,"baz"]</code></pre>

<h3>イテレータを作る</h3>
<p>さて、それでは自分でイテレータを作ってみましょう。実は、nextメソッドを備えたオブジェクトならイテレータになります。</p>
<p>例えば、次のオブジェクトはフィボナッチ数を順に返すイテレータです。</p>
<pre><code>{
  a:1,
  b:0,
  <mark>next</mark>:function(){
    var n=this.a+this.b, oldb=this.b;
    this.a=oldb, this.b=n;
    return {
      <code>value</code>: oldb,
      <code>done</code>: false
    };
  }
}</code></pre>
<p>このオブジェクトのnextメソッドは常にdoneがfalseのオブジェクトを返しますから、無限イテレータであることが分かります。しかし無限イテレータは無限ループを引き起こす場合もあり、扱いに注意が必要です。</p>

<p>さて、イテレータが出来たのでfor-of文で回してみようとしても、実はエラーが出てうまくいきません。それはなぜかというと、for-of文に渡さなければならないのは<b>イテレータ</b>ではなく<strong>iterable</strong>だからです。</p>
<p><dfn>iterable</dfn>とは、<strong>イテレータにより順に取り出すことができるオブジェクト</strong>のことです。for-of文はiterableを受け取って、それに対応するイテレータを取り出してそれを回して処理します。</p>
<p>最後にfor-of文に配列を渡した例がありましたが、配列もiterableの一種です。上で「配列をイテレータに変換する」という表現が厳密には正確ではないといいましたが、それは配列はあくまでイテレータではなくiterableであり、配列をイテレータに変換というよりはその配列に対応するイテレータを得るといったほうが正しいからです。実際、配列をfor-of文で回している最中に元の配列を変更すると影響がでます。それは、実際回っているイテレータが元の配列を参照しているからであり、イテレータがもとのiterableから切り離されて作られるのではなくあくまでiterableを参照しながら動作していることの証です。強引な例ですが、次のサンプルを実行した場合を考えましょう。</p>
<pre><code>var arr=[1,2,3,4,5];
for(var v of arr){
  console.log(v);
  arr[2]=0;
}</code></pre>
<p>結果は以下になります。1回目のループの時点で<code>arr[2]</code>が0に変更されているからですね。</p>
<pre><code>1
2
0
4
5</code></pre>
<p>これはvaluesメソッドなどを使ってイテレータを得た場合も同様です。これはイテレータ自体がデータを持つのではなく、あくまでiterableがデータを持っているからですね。</p>

<p>以上のように、イテレータそのものではなくiterableを作らないとfor-of文は受け付けてくれません。for-of文以外にもiterableが活躍する場面はありますが、イテレータ単体で使う機会というのはなかなかないでしょう。</p>
<p>さて、どうすればiterableなオブジェクトを作れるかですが、<strong>対応するイテレータを取り出す方法</strong>を与えればiterableになります。まあ上の説明からして当然ですね。具体的には、<b>@@iteratorメソッド</b>なるものを持つオブジェクトがiterableなオブジェクトです。</p>
<p>@@iteratorというメソッド名らしからぬ名前が出てきましたが、これを解説するにはまだ予備知識が足りません。残念ながら、<code>obj["@@iterator"]=function(){…};</code>なんて書いても意味はありません。自分でiterableを作る方法はまた今度紹介します。</p>

<h3>iterableの活用例</h3>
<p>iterableが使われるのはfor-of文だけではありません。ここでは他の例を見てみましょう。</p>
<p><dfn>Array.from</dfn>というメソッドがあります。これは、配列ではないものから配列を作るメソッドです。Object.create（<a href="11_7.html">十一章第七回</a>）みたいに、コンストラクタに直接くっついているメソッドですね。</p>
<p>Array.fromは、iterableから配列を作ることができます。イテレータを回して得た値を順番に入れていけばいいわけですね。例えば、文字列もiterableであり、イテレータにより1文字ずつ返されるということを紹介したので、文字列をArray.fromで配列にしてみましょう。</p>
<pre><code>console.log(<mark>Array.from</mark>("foobar"));</code></pre>
<p>結果は以下のような配列になります。</p>
<pre><code>["f","o","o","b","a","r"]</code></pre>
<p>また、Array.fromには第二引数として関数を指定することができます。これは配列に対するmap操作のような感じで、イテレータから取り出された値を引数にしてその関数が呼び出され、その返り値が配列に入るようになります。イテレータから取り出した値に対して何らかの処理を噛ませてやることができます。例えば先ほどの例で各文字を全て大文字にしたい場合、文字列を大文字して返すメソッドtoUpperCaseを使用して次のように書けます。</p>
<pre><code>console.log(Array.from("foobar",function(char){
  return char.toUpperCase();
}));</code></pre>
<p>この結果は<code>["F","O","O","B","A","R"]</code>になります。まあこの場合は<code>Array.from("foobar".toUpperCase())</code>と書けばいいのであまり関数を使う意味が無かったですね。</p>
<p>なお、関数の第二引数には、Array.prototype.mapと同様に添字が渡されます。また関数呼び出し時のthis値を、Array.fromの第三引数で指定できます。</p>

<p>また、iterableとは関係ない話になりますが、Array.formはiterableだけでなく、<b>array-likeなオブジェクト</b>からも配列を作ることができます。array-likeなオブジェクトとは、"0","1",…という連番のプロパティとlengthプロパティを持ち、配列のように利用できるオブジェクトです。これはDOM関連でよく出現します。例えばNodeList（<a href="2_3.html">二章第三回</a>）などです。これらのarray-likeなオブジェクトは、配列と同様に扱うことができるものの、配列ではないので配列が持つ各種のメソッドを使用することができません。また、基本的にはiterableではありません（DOMなどは、JavaScriptにイテレータの概念ができるずっと前から定義されていたし、またDOMはもともとJavaScript専用ではなく、Javaなどでも実装例があります）。Array.fromを用いて配列に変換することでこれらの恩恵を受けることができます。例えば次の例です。</p>
<pre><code>console.log(Array.from({
  "0":"foo",
  "1":"bar",
  "2":"baz",
  length:3
}));</code></pre>
<p>これを実行すると<code>["foo","bar","baz"]</code>という配列が得られ、array-likeなオブジェクトを配列に変換できたことがわかります。</p>
<p>なお、先ほど例に出したNodeListは実はメソッドの戻り値として返されたあとに変化する可能性があります。適当なページで次のコードを実行すると、<code>ps.length</code>が変化していることが分かります。</p>
<pre><code>ps = document.getElementsByTagName("p");
console.log(ps.length);
document.body.appendChild(document.createElement("p"));
console.log(ps.length);</code></pre>
<p>Array.fromで配列に変換した場合、もとのオブジェクトとは切り離されるので、その後に元のオブジェクトが変更されたとしても当然反映されません。</p>

<h3>補足</h3>
<p>上のArray#entriesの例で次のようなコードがあったのに気づいたでしょうか。</p>
<pre><code>for(var arr of ["foo","bar","baz"].<mark>entries</mark>()){
  console.log(arr);
}</code></pre>
<p>for-of文に渡すのはiterableであってイテレータ自体を渡すのではないと説明したのに、ここでfor-of文にイテレータを渡しています。</p>
<p>実はこのように、配列や文字列などの組み込みのiterableから得られるイテレータはそれ自体iterableになるように作られています（すなわち、@@iteratorなるメソッドが備わっているということです）。当然、対応するイテレータは自分自身になります。</p>
<p>このように、iterableから得られるちゃんとしたイテレータは、それ自体がiterableとなっているのが望ましいですね。先にも述べたように、そのようなiterableの作り方はまた今度です（<a href="16_4.html">一六章第四回</a>で説明します）。</p>

<hr>

<p>今回は以上です。ここではイテレータの例として配列と文字列しかやっていないので、なんだか当たり前でイテレータの凄さが分かりにくいかもしれませんが、イテレータは色々と応用がききます。後々紹介できるといいですね。</p>
        <nav>
      <p>
        <a href="index.html" rel="bookmark">戻る</a>
                            |
          <a rel="prev" href="16_1.html">十六章第一回</a>
                          |
          <a rel="next" href="16_3.html">十六章第三回</a>
              </p>
    </nav>
  </article>

    </main>
  </body>
</html>
    
