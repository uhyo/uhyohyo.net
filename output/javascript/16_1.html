<!doctype html>
<html lang="ja-jp">
  <head>
    <meta charset="UTF-8">
    <link href="/css/css.css" rel="stylesheet">
                  <link href="/css/js.css" rel="stylesheet">
                        <title>十六章第一回　WeakMapとWeakSet — JavaScript初級者から中級者になろう &#x2014; uhyohyo.net</title>
        <script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-46093038-1', 'auto');
ga('send', 'pageview');
    </script>
  </head>
  <body>
    <header>
      <h1>
        <a href="/">uhyohyo.net</a>
      </h1>
    </header>
    <main>
      
<article> 
  <h1>JavaScript初級者から中級者になろう</h1>
  <aside class="ad-javascript">
    <!-- Google Adsense -->
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:inline-block;width:180px;height:150px"
     data-ad-client="ca-pub-1080533149094679"
     data-ad-slot="7536196754"></ins>
    <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
  </aside>
        <nav>
      <p>
        <a href="index.html" rel="bookmark">戻る</a>
                            |
          <a rel="prev" href="15_5.html">十五章第五回</a>
                      </p>
    </nav>
    <h2>十六章第一回　WeakMapとWeakSet</h2>
<p>第十六章では、<b>ECMAScript6</b>の解説をします。これはECMAScript5（第十一章で解説）のさらに次のバージョンで、新しい機能、新しい文法などを備えています。</p>
<p>現在（2014年）、各ブラウザがECMAScript6の新機能を徐々に実装してきています。その中でも特に速く利用可能になったのが今回紹介する<b>WeakMap</b>と<b>WeakSet</b>です。</p>
<p>実はWeakではないMapやSetもあるのですが、そちらはECMAScript6の新しい文法により深く関わっているので現段階では実装が進んでいないため、今回は紹介しません。</p>

<h3>WeakMapとは</h3>
<p>WeakMapというのは、その名の通り弱いMapです。まずMapというのはなにかというと、<strong>keyに対して値を保存しておけるもの</strong>です。keyというのは<a href="14_2.html">第十四章のIndexedDBの説明</a>でもでてきましたが、要するにあるものに対して別のものを関連付けておくことができるというものです。</p>
<p>このような機能をもつものは、今までのJavaScriptでも一応存在していました。ただのオブジェクトもその1つです。</p>
<p>例えば、次のオブジェクトを見てみましょう。</p>
<pre><code>var dict={
  "foo":"bar",
  "baz":5,
  "quux":null
};</code></pre>
<p>このオブジェクトは、文字列<code>"foo"</code>に対して<code>"bar"</code>を、文字列<code>"baz"</code>に対して<code>5</code>を、文字列<code>"quux"</code>に対して<code>null</code>を関連付けるものであると考えることができます。もちろん。JavaScriptのオブジェクトはあとからプロパティを追加することができますから、あとからキーと値のペアを増やすことも可能です。</p>
<p>このようにオブジェクトを用いればキーに対して値を保存しておくというのは可能なように見えますが、この方法にはひとつ問題があります。それは、<strong>キーに文字列しか使用できない</strong>ということです。これは、キーがそもそもプロパティの名前であることを考えれば当然ですね。</p>
<p>そこで、この問題を解決するのがWeakMapなのです。WeakMapでは文字列などではなく、<strong>オブジェクトをキーとして使います</strong>。オブジェクトをキーとして使えるということは、WeakMapを使ってオブジェクトに対して別の値を対応付けることができるということです。</p>

<h3>WeakMapの使用</h3>
<p>それでは、実際にWeakMapを使ってみましょう。</p>
<p>WeakMapを使うには、WeakMapの新しいインスタンスを作ります。</p>
<p>作ったら、<dfn>set</dfn>メソッドで新しいキーと値を保存できます。第一引数にキー、第二引数に値です。また、<dfn>get</dfn>メソッドでキーに対応する値を得ることができます。</p>
<pre><code>var wm = new <mark>WeakMap</mark>();

//キーにはオブジェクトを使用する
var key={};

wm.<mark>set</mark>(key, 100); //keyに100を関連付ける

console.log(wm.<mark>get</mark>(key));  //100が表示される
</code></pre>
<p>注意すべきことは、上のサンプルを実行したあとに次を実行しても100は表示されないということです（対応する値がないことを示すundefinedがgetの返り値となります）。</p>
<pre><code>console.log(wm.get(<mark>{}</mark>));</code></pre>
<p>これは、<code>{}</code>に対応する値を得るということです。</p>
<p>さっきのサンプルではkey1に対して100を関連付けて、key1は<code>{}</code>が入っていたはずなのに、なぜ次に<code>{}</code>に関連付けられた値を取得しようとしても存在しないということになるのでしょうか。</p>
<p>この答えを述べるならば、key1に入っている<code>{}</code>と次にgetの引数にした<code>{}</code>は別々のオブジェクトだからです。これは<a href="1_2.html">一章第二回</a>で説明したことが関わっています。</p>
<p>オブジェクトを変数に入れる場合、変数に入るのはオブジェクトの実体ではなくオブジェクトへの参照だと考えることができます。さらに、<code>{}</code>というのはオブジェクトリテラルである、「新しいオブジェクトを作って（その参照を）返す」というはたらきを持つと考えられます。</p>
<p>つまり、空のオブジェクトは<code>var key={};</code>の行で1回、<code>console.log(wm.get({}));</code>でもう1回作られたことになり、別々に作られたのだから当然別のオブジェクトである（から参照も異なる）のです。このように、WeakMapは別々のオブジェクトを区別します。</p>o
<p>また、keyとしてオブジェクト以外（プリミティブ）を使おうとした場合はエラーになります。</p>

<p>さて、WeakMapには他にも3つメソッドがあります。1つ目は<dfn>has</dfn>です。これは引数としてキーを渡すと、そのキーに対する値がWeakMapに存在するか（setメソッドで登録されているかどうか）を真偽値で返します。存在しているならばtrueです。</p>
<p>2つ目は<dfn>delete</dfn>です。これは名前の通りで、引数にキーを渡すとそのキーに対応する値をWeakMapから削除します。</p>
<p>最後は<dfn>clear</dfn>です。引数なしで、WeakMap内の全ての値を消去します。</p>
<p>また、実はgetメソッドには第二引数を指定することができます。これは、対応する値が存在しなかった場合は第二引数の値を返すという仕様になっているためです。さきほど、対応する値がない場合は（第二引数がなければ）undefinedがgetの返り値になると述べたので、通常は返り値がundefinedかどうかで判定できそうなものですが、万一setメソッドで明示的にキーに対してundefinedを関連付ける場合などは、その結果がキーと関連付けられた値としてのundefinedなのか、対応する値がなかったという意味でのundefinedなのか区別できません。これを区別するためにはhasメソッドを使う必要があり面倒です。値が登録されてなかった場合に別の動作をさせたいという場合はどのみちhasメソッドが必要になりますが、値がなければかわりに0を用いたいとか、そういう「デフォルト値」を指定する用途ならばこのgetの第二引数は役立ちます。</p>

<h3>WeakMapの意味</h3>
<p>さて、WeakMapが今までに比べて革新的なところは、やはり任意のオブジェクトに対して別の値を関連付けられるということです。</p>
<p>今まで、オブジェクトに対して値を関連づけるならば、例えば適当なプロパティに保存しておくという方法がありました。つまり次のような感じです。</p>
<pre><code>function saveValueInObject(obj,value){
  obj.<mark>_myvalue</mark>=value;
}
function getValueFromObject(obj){
  return obj.<mark>_myvalue</mark>;
}
</code></pre>
<p>この例では、オブジェクトに対して_myvalueというプロパティを勝手に作り、そこに保存しています。プログラムの他の部分で_myvalueを使っていなければ正しく保存できていることになりますが、万一_myvalueというプロパティが意味を持つようなオブジェクトがあれば、それを勝手に書き換えることになり思わぬ動作をする原因となります。</p>
<p>また、for-in文やObject.keys（<a href="11_4.html">十一章第四回</a>）を使っている場合も変な動作になる可能性が高いですね。これについてはObject.definePropertyなどでenumerable属性がfalseのプロパティを作れば回避できますが、Object.getOwnPropertyNamesを使えばやはり見つけることができるので問題ないとはいえません。</p>
<p>他にも、組み込みオブジェクト（もともと定義されているオブジェクト）に対して勝手にプロパティを追加するのも望ましくありません。例えば、配列をはじめとするJavaScriptの言語仕様に存在するオブジェクトや、ノードのようなDOMオブジェクトが組み込みオブジェクトに該当します。これらに追加情報を関連付けたいときもWeakMapは活躍します。もちろん、WeakMapはどんなオブジェクトでもkeyとして利用できるので、関数やRegExp（正規表現オブジェクト）もOKです。</p>

<h3>WeakMapの特徴</h3>
<p>さて、実はただのMapもあるという話をしましたが、実はこのようにキーと値を対応付ける機能をもつものをMapというので、いままでの説明で特にWeakな部分がありませんでした。</p>
<p>それではいったい何が弱くてWeakMapなのかというと、実は<strong>参照が弱い</strong>のです。</p>
<p>より詳しく言うと、WeakMapからキーのオブジェクトへの参照が弱いのです。</p>
<p>これを解説するには、<strong>ガベージコレクション</strong>の話をしなければなりません。そもそも<a href="1_2.html">一章第二回</a>で「オブジェクトの実体は別のところにある」と述べましたが、オブジェクトは突き詰めるとメモリ上にあります。つまり、オブジェクトの情報を覚えておくにはメモリが必要だということです。</p>
<p>ところで、次のサンプルを考えてみましょう。</p>
<pre><code>var a = {
  foo:3,
  bar:5
};

a={};
</code></pre>
<p>最初に変数aにオブジェクト（オブジェクトAとしましょう）を代入しており、直後に別のオブジェクト（オブジェクトB）を代入しています。</p>
<p>何度も述べているように、オブジェクトリテラルでは新しいオブジェクトが（メモリ上に）作成され、それへの参照が返されて変数aに代入されます。</p>
<p>すると、二回目の代入ではaに新しく作られたオブジェクトBへの参照が入り、もともと入っていたオブジェクトAへの参照は上書きされます。</p>
<p>これにより、オブジェクトAへの参照は全く存在しなくなりました。これはすなわち、JavaScriptプログラムからオブジェクトAにアクセスする方法がなくなったということを意味します。</p>
<p>このような場合、もう二度と使われないオブジェクトAをいつまでもメモリ上に取っておくのはメモリの無駄なので、自動的にメモリから破棄されます。このように、もう使われなくなったオブジェクトをメモリ上から消去する働きを<b>ガベージコレクション</b>といいます。</p>
<p>一方、次のサンプルはどうでしょう。
<pre><code>var a = {
  foo:3,
  bar:5
};

<mark class="ins">var wm = new <mark>WeakMap</mark>();
wm.set(a,100);</mark>

a={};
</code></pre>
<p>オブジェクトAをWeakMapのキーとして100を保存したあと、aをオブジェクトBへの参照で上書きしました。</p>
<p>この場合、wmの中にオブジェクトAをキーとした値が入っているので、getメソッドにオブジェクトA（への参照）が渡されれば対応する値を返さなければいけません。そのためには、WeakMapの内部でオブジェクトAへの参照を保持している必要があります。そうでないと、getメソッドに渡されたオブジェクトがオブジェクトAと一致するかどうか調べられないからです。</p>

<p>しかしこのサンプルでは、その後やはりaにオブジェクトB（への参照）が代入されます。こうなると、オブジェクトAへの参照はWeakMapの内部にしかありません。この場合、さっきと同様に、WeakMapのgetメソッドにオブジェクトAへの参照が渡されることはないでしょう。すなわち、もはやオブジェクトAに対応する値を要求されることはないのですから、WeakMap内部にあるオブジェクトAへの参照は意味がないことになります。したがって、この場合もオブジェクトAはガベージコレクションの対象となります。</p>
<p>このように、WeakMap内部にまだオブジェクトへの参照が存在していても、他のところに全くない場合はガベージコレクションの対象になります。これを、（WeakMap内部の）「オブジェクトへの参照が<em>弱い</em>」と表現します。これがWeakMapという名前の由来であり、WeakMapの大きな特徴でもあります。</p>
<p>WeakMapのこの特性がなければ、使われなくなったオブジェクトが延々メモリに残り続ける可能性があるのです。</p>
<p>ちなみに、Weakではない普通のMapは後々紹介しますが、これは同じ状況になっても、Map内部にオブジェクトへの参照が残っている限りガベージコレクションの対象とはなりません。これは、Mapが「キーとなっているオブジェクトの一覧」を返すメソッドなどを持っているため、Map内部にしかオブジェクトへの参照が無くなってもそれを外部から取得する手段があるからです。</p>
<p>逆に言えば、参照を弱くするという目的のためにこれらのメソッドをMapから削ったのがWeakMapであるということです。</p>

<p>このような事情があるWeakMapですが、一般的にはオブジェクトに対して値を関連付けられる便利なものとして使われています。</p>

<h3>WeakSet</h3>
<p>さて、次のWeakSetについてですが、そもそもSetとは<b>集合</b>のことです。実はWeakSetは、オブジェクトの集合を表すものです。</p>
<p>一般に集合は、ある元が与えられたときにそれが集合に含まれるかどうかを判定できなければいけません。WeakSetは、集合にオブジェクトを追加するメソッド(add)、集合からオブジェクトを除去するメソッド(delete)、あるオブジェクトが集合に含まれるかどうか判定するメソッド(has)を持ちます。他に、集合に含まれるオブジェクトを全て除去するclearメソッドも持ちます。具体例を以下で見てみましょう。</p>
<pre><code>
var key={};
var ws=new <mark>WeakSet</mark>();

console.log(ws.has(key)); //wsにkeyは含まれないのでfalse

ws.add(key);

console.log(ws.has(key)); //さっき追加したのでtrue

console.log(ws.has({}));  //false
</code></pre>
<p>つまり、WeakSetはオブジェクトに対して「集合に含まれる」という情報を関連付けるものであると考えられます。こう考えると、WeakSetはWeakMapの機能を削減したバージョンであると考えられます。WeakMapはオブジェクトに任意の情報を紐付けることができるのに対し、WeakSetは「集合に含まれる」ということを示すのみです。</p>
<p>また、WeakSetには、WeakMapと同じ理由により「含まれるオブジェクトの一覧」を得る方法はありません（ふつうのSetにはあります）。</p>
<p>WeakSetはWeakMapに比べると使い所がないかもしれませんが、機会があれば使ってみましょう。</p>
        <nav>
      <p>
        <a href="index.html" rel="bookmark">戻る</a>
                            |
          <a rel="prev" href="15_5.html">十五章第五回</a>
                      </p>
    </nav>
  </article>

    </main>
  </body>
</html>
    
