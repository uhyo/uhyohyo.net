<!doctype html>
<html lang="ja-jp">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <link href="/css/css.css" rel="stylesheet">
                  <link href="/css/js.css" rel="stylesheet">
                        <title>十三章第一回　XMLHTTPRequest — JavaScript初級者から中級者になろう &#x2014; uhyohyo.net</title>
        <script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-46093038-1', 'auto');
ga('send', 'pageview');
    </script>
  </head>
  <body>
    <header>
      <h1>
        <a href="/">uhyohyo.net</a>
      </h1>
    </header>
    <main>
      
<article> 
  <h1>JavaScript初級者から中級者になろう</h1>
  <aside class="ad-javascript">
    <!-- Google Adsense -->
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:inline-block;width:180px;height:150px"
     data-ad-client="ca-pub-1080533149094679"
     data-ad-slot="7536196754"></ins>
    <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
  </aside>
        <nav>
      <p>
        <a href="index.html" rel="bookmark">戻る</a>
                            |
          <a rel="prev" href="12_6.html">十二章第六回</a>
                          |
          <a rel="next" href="13_2.html">十三章第二回</a>
              </p>
    </nav>
    <h2>十三章第一回　XMLHTTPRequest</h2>
<p>今回は、かなりよく使われる<dfn>XMLHTTPRequest</dfn>を紹介します。</p>
<p>新しいといってもわりと昔からある技術ですが、最近まで進化を続けているのでここで紹介します。</p>
<p>略してXHRと呼ばれることもあるこの技術は何かというと、<strong>JavaScriptでHTTP通信を行う</strong>ためのAPIです。Ajaxという言葉を聞いたことがあるかもしれませんが、その根幹をなす技術といっていいでしょう。</p>

<h3>リクエストを送る</h3>
<p>XHRには、レベル1とレベル2があります。使う上でそんなに意識しなくてもいいですが、レベル1がわりと昔からあった古典的なもので、レベル2は新しめのものであるという認識でよいでしょう。</p>
<p>さて、もっとも基本的に、HTTPリクエストを発行するには、XMLHttpRequestオブジェクトのインスタンスを作ります。</p>
        <pre><code>var xhr= new <mark>XMLHttpRequest</mark>();</code></pre>
<p>そして、<dfn>open</dfn>メソッドでリクエストを開始します。このとき、<strong>URL</strong>と<strong>メソッド</strong>を渡してやります。</p>
<p>メソッドというのは、<strong>GET</strong>とか<strong>POST</strong>とかです。ほかにDELETE,PUT,HEAD,OPTION,TRACE,CONNECTがありますが、XHRから使うのは、GET,POSTのほかにせいぜいがHEADくらいでしょう。また、CONNECTとTRACEはセキュリティの観点から使えないことになっています。</p>
<p>GETというのはサーバーからデータを送ってもらうということであり、POSTというのは逆にサーバーへデータを送ることであるとされています。例えば、POSTは掲示板に投稿したりとかそういう時に使うそうです。しかし現実的には、GETでもデータを送ることができますし（HTMLのform要素ではmethod属性でgetかpostか選択可能です）、POSTでもサーバーは結果としてデータを送り返してきます。まあ、状況に応じて使い分けて下さい。</p>
<p>具体的にはこうです。</p>
<pre><code>var xhr= new XMLHttpRequest();
<mark class="ins">xhr.<mark>open</mark>("<mark>GET</mark>","/index.html");</mark>
          </code></pre>
<p>第一引数がメソッドであり、第二引数はURLです。このように「/」から始まるURLはルートからの絶対パスですね。このサイトの場合、「http://uhyohyo.net/index.html」に該当します。</p>
<p>ちなみに今回は省略していますが、第三引数は非同期フラグ（後述）で、また必要な場合、第四引数にユーザー名、第五引数にパスワードを渡すことが可能です。</p>

<p>さて、これだけだとリクエストは送信されません。リクエストを実際に送信するのが<dfn>send</dfn>メソッドです。</p>
<p>sendには引数が一つあり、<strong>リクエストの本文</strong>です。リクエストの本文というのは、例えばPOSTメソッドの場合、サーバーに送信するデータです。文字列など（後述）を送信することが可能です。GETやHEADの場合は本文は必要ありませんので、省略できます。</p>
<pre><code>var xhr= new XMLHttpRequest();
xhr.open("GET","/index.html");
<mark class="ins">xhr.<mark>send</mark>();</mark>
          </code></pre>
<p>これでリクエストが送信されました。</p>

<h3>結果を受け取る</h3>
<p>リクエストが送信されたのはいいですが、サーバーから戻ってくる結果はどうやって受け取るのでしょうか。基本的には、リクエストには時間がかかるので、<strong>非同期</strong>です。ここのところおなじみの非同期ですが、つまり<strong>コールバック</strong>で受け取るということです。</p>
<p>XHRにおいては<strong>イベント</strong>を用います。ここで、リクエストが完了して結果が戻ってきたときのイベントは<strong>load</strong>です。すなわちこうです。</p>
<pre><code>
xhr.<mark>addEventListener</mark>("<mark>load</mark>",function(ev){
});
          </code></pre>
<p>addEventListenerの第三引数は省略できます。</p>
<p>また、いちいちaddEventListenerを使わなくてもよい省略形もあります。</p>
<pre><code>xhr.<mark>onload</mark>=function(ev){
};</code></pre>
<p>こちらのほうが古典的な方法です。onがついていることに注意しましょう。</p>
<p>さて、それではloadイベントが発生したら、リクエストの結果は<dfn>response</dfn>または<dfn>responseText</dfn>に入っています。これらの違いも後述です。まあTextというくらいですから、今回は結果は<strong>テキスト</strong>です。</p>
<p>ここまでをまとめた<a href="13_1_sample.html">サンプル</a>を見てみましょう。ページを開くと、HTMLが表示されたと思います。これは<a href="/index.html">/index.html</a>のソースです。すなわち、あのページからHTTP通信によって/index.htmlの内容を取得し、その内容を表示したわけです。</p>

<h3>結果の種類</h3>
<p>さて、responseとresponseTextの違いですが、それは結果の種類というものが関係しています。</p>
<p>結果をどんな風に受け取りたいかは<dfn>responseType</dfn>プロパティに文字列を代入してやることで決定します。デフォルトは空で、その場合基本的には"text"と同様の扱いになります（後述）。いずれの場合でも、結果はresponseプロパティに入っていることになります。</p>
<p>responseTypeには以下の種類の文字列を設定することが可能です。</p>
<dl>
  <dt>text</dt>
  <dd>結果をテキストで受け取ります。結果はresponseプロパティのほかresponseTextプロパティでも取得できます。</dd>
  <dt>json</dt>
  <dd>結果はJSONで送られてきて、それを解析したオブジェクトを受け取ります。結果にJSON.parseを適用したものと同じです（詳しくはまた今度）。</dd>
  <dt>arraybuffer</dt>
  <dd>結果をArrayBuffer（<a href="12_5.html">十二章第五回</a>）で受け取ります。この方法ならばバイナリデータも受け取れます。</dd>
  <dt>blob</dt>
  <dd>結果をBlob（<a href="12_5.html">十二章第五回</a>）で受け取ります。arraybufferとの違いは、Blobの<dfn>type</dfn>プロパティ（そのデータのMIMEタイプ）が使用できる点です。</dd>
  <dt>document</dt>
  <dd>HTMLまたはXMLのファイルを受け取ります。結果はHTMLDocument（送られてきたHTMLファイルのdocument）またはXMLDocument（<a href="6_1.html">六章第一回</a>）で受け取ります。HTMLになるかXMLになるかは、サーバーから送られてきたデータ（のMIMEタイプ）によって自動的に判定されます。HTMLかXMLかに関わらず、<dfn>responseXML</dfn>プロパティでも受け取れます。</dd>
</dl>
<p>なぜresponseプロパティ一つあればいいのにresponseText,responseXMLといった専用プロパティあが用意されているかというと、これはLevel 1時代のなごりです。</p>
<p>responseTypeはLevel 2になって導入されたもので、それ以前はresponseという汎用のプロパティは無く、responseTextとresponseXMLで、使いたいほうを使うという形でした。この名残として、responseTypeが設定されていない（空である）昔のコードでは、textと同じ動作をするので当然ながらresponseTextを使えるほか、responseTypeを"document"にしなくてもresponseXMLは使えます。</p>

<h3>リクエストヘッダ</h3>
<p>HTTPには、リクエストやレスポンスの付帯状況として<strong>ヘッダ</strong>を送ることができます。例えば、</p>
        <pre><code>From: foo@example.com</code></pre>
<p>みたいなやつです。このようなヘッダを設定するには、<dfn>setRequestHeader</dfn>メソッドを使います。ただし、タイミングはopenメソッドのあと、sendする前でなければいけません。</p>
<p>引数は、第一引数にヘッダ名、第二引数に値です。上の例だとこのようになります。</p>
        <pre><code>xhr.<mark>setRequestHeader</mark>("From","foo@example.com");</code></pre>
<p>ちなみに、XHRではわりと多くのヘッダが制限されています。完全に自由にヘッダを操作できるわけではありません。</p>

<h3>レスポンスヘッダ</h3>
<p>また、HTTPでは、送るとき（リクエスト）以外にも、結果が戻ってくるとき（レスポンス）にもさまざまなヘッダがついています。これを取得するのが<dfn>getResponseHeader</dfn>です。引数はヘッダ名の一つだけです。</p>
        <pre><code>var length=xhr.<mark>getResponseHeader</mark>("Content-Length");</code></pre>
<p>こういう感じです。</p>
<p>また、全てのヘッダを一度に得る<dfn>getAllResponseHeaders</dfn>メソッド（引数無し）もあります。しかし文字列で次のような感じで帰ってきます。</p>
<pre><code>Content-Type: text/plain;charset=UTF-8
Content-Length: 5</code></pre>
<p>あまり使い所はないかもしれません。</p>

<h3>レスポンス</h3>
<p>ほかにレスポンスには、あまり使う機会はないと思いますが<dfn>overrideMimeType</dfn>というメソッドがあります。これは引数を一つとり、結果のMIMEタイプを書き換えます。</p>
<p>例えば、ただのテキスト（text/plain）で帰ってきたものを</p>
        <pre><code>xhr.<mark>overrideMimeType</mark>("text/html");</code></pre>
<p>のようにすれば、responseTypeを"document"にすることでHTMLとして解析してもらえるでしょう。もっと実用的な例もあるかもしれません。</p>

<p>次に、<dfn>status</dfn>プロパティを紹介します。これは、帰ってきた結果の<strong>HTTPステータスコード</strong>を数値で得ます。例えば。正常にページが帰ってきたならば大抵は200です。ほかに、403とか404が有名です。注意すべきことは、たとえ404などであっても、サーバーから何かしら結果が帰ってきたならばそれはXMLHttpRequest的には「正常に結果が帰ってきた」ということであるということです。</p>
<p>また、<dfn>statusText</dfn>プロパティは、テキストでの説明です。例えば200なら"OK"とか、404なら"Not Found"です。statusとつなげれば「404 Not Found」みたいな感じにすることもできますね。</p>

<h3>readyStateとその他のイベント</h3>
<p>さて、上では受信に成功したときとしてloadイベントを紹介しました。ほかには次のようなイベントがあります。</p>
<dl>
  <dt>loadstart</dt>
  <dd>リクエストを開始した瞬間。</dd>
  <dt>progress</dt>
  <dd>データを受信しているとき（後述）。</dd>
  <dt>abort</dt>
  <dd>リクエストが中断して失敗しとき。</dd>
  <dt>error</dt>
  <dd>リクエストに失敗したとき。</dd>
  <dt>timeout</dt>
  <dd>タイムアウト（後述）によりリクエストが失敗したとき。</dd>
  <dt>loadend</dt>
  <dd>失敗か成功かにかかわらずリクエストが終了したとき。つまり、loadまたはabort,errorイベントと同じタイミングで発生する。</dd>
  <dt>readystatechange</dt>
  <dd>後述</dd>
</dl>
<p>まとめると、処理完了時点で成功した場合にはloadイベントが発生し、失敗した場合は原因によって、abort（中断）またはtimeout（タイムアウト）またはerror（その他）イベントが発生します。いずれの場合もloadendイベントは発生します。</p>
<p>ちなみに、abortイベントが発生する原因の一つとしては、<dfn>abortメソッド</dfn>（引数無し）を呼び出すことで自分から中断させることができます。その場合にも発生します。</p>
<p>404でも成功と判断されるのにリクエストが失敗するとはどういう場合かというと、例えばサーバーが落ちていて接続できないとか、そういう場合です。</p>
<p>成功しても失敗しても何らかの動作をしたい場合には、loadendイベントを利用するのが楽でしょう。ちなみに、loadendイベントにおいて成功か失敗か見分ける方法は、<strong>statusプロパティ</strong>を使う方法があります。成功した場合は何らかのコードが入っていますが、失敗した場合は0になっています。また、まだリクエストしていない場合も0なので注意しましょう。また、失敗した場合にはresponseプロパティがnullになりますが、成功したけれどもnullになる場合も多少あるため（変なJSONが送られてきたとか、サーバーが何も送って来なかった場合など）、statusで判断したほうが確実でしょう。</p>
<p>ちなみに、loadstartイベントが発生するのはsendメソッドが呼ばれたときです。</p>
<p>そして、<strong>readystatechange</strong>イベントについてですが、これは<dfn>readyState</dfn>というプロパティと関連しています。これは「現在の状態」を表す数値で、以下に列挙します。</p>
<dl>
  <dt>0 (UNSENT)</dt>
  <dd>まだopenメソッドが呼ばれていない状態。</dd>
  <dt>1 (OPENED)</dt>
  <dd>openメソッドが呼ばれたがsendメソッドは呼ばれていない状態。</dd>
  <dt>2 (HEADER_RECEIVED)</dt>
  <dd>sendが呼ばれた後、HTTPヘッダを全て受信し終えた状態。この状態からstatusプロパティやgetResponseHeaderメソッドなどが利用可能。まだデータ本体は受信していない。</dd>
  <dt>3 (LOADING)</dt>
  <dd>本文のデータを受信中である状態。</dd>
  <dt>4 (DONE)</dt>
  <dd>受信完了したか、リクエストに失敗して終了した状態。</dd>
</dl>
<p>見て分かるように、readyStateが4になるのはloadendイベントと同時といっていいでしょう。</p>
<p>さて、readystatechangeイベントは、その名の通りreadystateが変化したときに発生するイベントです。</p>
<p>実はLevel 1ではこのreadystatechangeイベントしか無かったため、例えばロード完了は、readystatechangeイベントでreadyStateが4になった場合に終了だと判断していました。</p>
<p>今はあえてこのreadystatechangeイベントを使う機会は少ないかもしれません。</p>
<p>最速でstatusを得たい（readyStateが2になったタイミング）とかそういう場合は使い道があるかもしれません。</p>

<p>また、実は、readyStateが変わっていないのにreadystatechangeイベントが発生する場合があります。</p>
<p>たとえば、send()が呼ばれた時点、つまりloadstartと同時にreadystatechangeも起こっています。これは、Level 1からの「歴史的理由」によるそうです。</p>

<p>さて、タイムアウトとは制限時間のようなものです。一定時間のうちに処理が完了しなかった場合サーバーが応答しないと判断され、そこで終了となります。</p>
<p>タイムアウトの設定方法は、<dfn>timeout</dfn>プロパティを使います。これはミリ秒の数値であり、例えば</p>
        <pre><code>xhr.timeout=1000;</code></pre>
<p>としたならば1秒以内に処理を完了できないとタイムアウトで失敗するということです。デフォルトは0ですが、0の場合無制限ということになります。</p>

<h3>イベントオブジェクト</h3>
<p>ところで、イベントですから、イベントオブジェクトが存在します。readystatechangeはただのイベントですが、その他のイベントのイベントオブジェクトは<dfn>ProgressEvent</dfn>といいます。</p>
<p>ちなみに、イベントオブジェクトには<strong>target</strong>（<a href="3_5.html">三章第五回</a>）がありますね。この場合、targetはそのXMLHttpRequestオブジェクトになります。</p>
<p>さて、ProgressEventに特有なプロパティは主に3つです。一つ目は<dfn>loaded</dfn>です。これは数値で、<strong>すでに受信した本文のバイト数</strong>です。</p>
<p>次は<dfn>total</dfn>です。これは、受信すべきデータサイズの全体です。例えば、1024バイトのファイルのうち100バイトをすでに受信したとしたら、loadedは100でtotalは1024ということになります。</p>
<p>ところで、totalのはデータサイズの全体ですが、まだ全部受信していないのにどうしてデータサイズが分かるのでしょう。実は、HTTPヘッダのCotent-Lengthにより、データサイズは先にサーバーから教えてもらっているのです。したがって、readyStateが2以上でないとtotalは使えません。</p>
<p>そこで、totalがすでに判明しているかどうかを表すプロパティとして<dfn>lengthComputable</dfn>があります。これがtrueならばtotalは利用可能で、falseならばtotalはまだ利用できません（このときtotalは0になっています）。</p>
<p>ProgressEventに特有なプロパティは以上の3つです。</p>
<p>これらが活躍するのは、主に上の<strong>progressイベント</strong>でしょう。progressイベントは、0.05秒に1回発生することになっています（例外もたまにあります）。</p>
<p>このprogressイベントを用いてダウンロードの進捗状況を把握すれば、よくある「0%」からはじまって「100%」までいくやつなどが可能でしょう。具体的にはこんな感じです。</p>
<pre><code>var xhr=new XMLHttpRequest();
xhr.open("GET","/index.html");
xhr.addEventListener("<mark>progress</mark>",function(ev){
  console.log(<mark>ev.loaded</mark>,<mark>ev.total</mark>);
});
xhr.send();
          </code></pre>
<p>こんな感じでconsole.logでloadedとtotalを表示してやれば、loadedがだんだん増えていく様子がわかるでしょう。ただ、あまりに小さいファイルだと一瞬で終わってしまって分からないかもしれません。実際には、progress要素などに表示するとよいでしょう。</p>

<h3>XMLHttpRequestUpload</h3>
<p>さて、イベントと関連して紹介するのが<dfn>XMLHttpRequestUpload</dfn>です。これは、XMLHttpRequestオブジェクトとセットになっていて、<dfn>upload</dfn>プロパティに入っています。</p>
<p>このXMLHttpRequestUploadの機能は、<strong>イベントを発生すること</strong>です。発生するイベントの名前はXMLHttpRequestと同じです。</p>
<p>さて、実は、さっきのprogressイベントは、サーバーからこちらへ送られてくるデータを観測するものでした。では、POSTでこちらから巨大なデータを送る場合（後述のFormDataでファイルを送る場合とか）は進捗状況を得ることはできないのでしょうか。</p>
<p>それを可能にするのがこのXMLHttpRequestUploadであり、クライアント（リクエスト元）からサーバーにデータを送る部分に関するイベントを発生してくれます。ただし、sendの引数がないなど送るデータが全くない場合はイベントは一つも発生しないので、注意しましょう。</p>
<p>loadstart, abort, error, timeoutについては、クライアントからサーバーへ送る部分とサーバーからクライアントへデータが送られてくるが細分化されていたりはしないので、通常のXMLHttpRequestのイベントと同じです。つまり、わざわざXMLHttpRequestUploadのほうのイベントを監視することもないでしょう。</p>
<p>また、readystatechangeはありません。残ったload,loadend,progressが、XMLHttpRequestUploadで違う部分です。要するに、XMLHttpRequestUploadの用途は主にprogressイベントを監視することだということです。</p>
<p>それでは、XMLHttpRequestUploadにおけるload,loadend,progressの意味を見て行きましょう。とはいっても、これは単純です。</p>
<p>progressイベントのloaded・totalは、受信済みデータ量・受信する総データ量の代わりに、送信済みデータ量・送信する総データ量に変わっただけです。load・loadendは同じタイミングであり、こちら側から送るデータを全て送った段階で発生します。大きいデータを送信して時間がかかりそうな場合は、これを利用してインターフェースを作ると面白いでしょう。これについても、サンプルを示しておきます。</p>
<pre><code>//変数dataには巨大なデータが入っていると仮定
var xhr=new XMLHttpRequest();
xhr.open("POST","/index.html");
xhr.<mark>upload</mark>.addEventListener("<mark>progress</mark>",function(ev){
  console.log(<mark>ev.loaded</mark>,<mark>ev.total</mark>);
});
xhr.send(data);
        </code></pre>

<h3>クロスオリジンリクエスト</h3>
<p>次に、<strong>クロスオリジン</strong>のリクエストについて解説します。これは、オリジンをまたぐということです。オリジンとは、簡単にいうとドメイン（やポート番号）の概念で、一般にオリジンが同じWebページ（≒同じドメインのWebページ）は所有者が同じであるとみなされます。逆に、JavaScriptのセキュリティにおいては、オリジンが異なるページ（iframeで表示してみたりとか）を操作することは基本的にできません。よそのサイトを自由にいじってパスワードを抜かれるとかしても困るからでしょう。逆に、所有者が同じならば安全だろうということです。</p>
<p>しかし、XHRにおいてはあるオリジンのページから違うオリジンのページへHTTPリクエストを送ることができます。これがクロスオリジンリクエストです。ただし、制限もあります。</p>
<p>具体的にどうすればクロスオリジンのリクエストができるかというと、<strong>リクエストを受ける側</strong>がHTTPヘッダを追加する必要があります。例えば、</p>
        <pre><code>xhr.open("GET","http://example.com/");</code></pre>
<p>という場合には、example.com側が変更を行わないといけないということです。すなわち<strong>許可制</strong>です。向こう側が許可しているならセキュリティも保たれるだろうという考え方ですね。</p>
<p>具体的には、<dfn>Access-Control-Allow-Origin</dfn>というヘッダをレスポンスに追加します。これで、XHRを許可するドメインを列挙します。例えば、</p>
        <pre><code>Access-Control-Allow-Origin: http://example.com http://uhyohyo.net</code></pre>
<p>のようにします。たとえば、この例だと、example.comとuhyohyo.netにあるWebページからのXHRは許可するということです。また、ドメインを列挙する代わりに「*」とすることもできます。これは、「全てのオリジンからのXHRを許可」ということです。</p>

<p>ここで登場するのが、<dfn>withCredentials</dfn>です。これはクロスオリジンのときに関係するプロパティで、falseまたはtrue、デフォルトはfalseです。</p>
<p>trueになると何が起こるかというと、CookieとかSSL証明書などの情報も一緒に送られるようになります。これらが必要な場合はwithCredentialsをtrueにしましょう。</p>
<p>ただし、注意するのは、このwithCredentialsがtrueの状態で、さらにAccess-Control-Allow-Originが"*"でない場合（ちゃんと列挙してある場合）には、さらに追加のHTTPヘッダが必要になります。</p>
        <pre><code>Access-Control-Allow-Credientials: true</code></pre>
<p>このヘッダがないと失敗してしまいます。</p>

<p>さて、クロスオリジンのXHRを試してもらうために、<a href="13_1_test.cgi">http://uhyohyohyo.sakura.ne.jp/javascript/13_1_test.cgi</a>に、<code>Access-Control-Allow-Origin: *</code>を返すCGIを用意しました。</p>
<pre><code>var xhr=new XMLHttpRequest();
xhr.open("GET","http://uhyohyo.net/javascript/13_1_test.cgi");
xhr.onload=function(){console.log(xhr.response);}
xhr.send();
          </code></pre>
<p>こんな感じのコードで実際に試してみましょう。</p>

<h3>匿名リクエスト</h3>
<p>XMLHttpRequestの代わりに<dfn>AnonXMLHttpRequest</dfn>を使うと「匿名フラグ」が立ちます。</p>
<p>しかし、匿名だからといって身元がバレないとか、そういう機能はありません。あまり使う機会もないことと思います。</p>
<p>何が変わるかというと、まずwithCredentialsはfalse固定で、trueにすることはできなくなります。さらに、リクエスト元のオリジンがリクエスト先に分からないようになります。まあ、あまり使う機会もないでしょう（2014年7月現在、これに対応しているのはOpera12だけでした）。</p>

<h3>同期リクエスト</h3>
<p>XMLHttpRequestは非同期であるといいました。しかし、同期的なリクエストにすることもできます。</p>
<p>それを決めるのが、openの第三引数です。これはさっき「非同期フラグ」といいました。これがtrueならば非同期になります。今までのは非同期ですから、<strong>省略するとtrue扱い</strong>ということです。わりと珍しいですね。</p>
<p>それではこれをfalseにすると、同期リクエストになります。同期ということはどういうことかというと、<strong>リクエストが完了するまでsendメソッドから戻ってこない</strong>ということになります。この場合イベントはあまり使わないことになるでしょう。</p>
<p>つまり、send()の処理が完了した時点でもう結果が帰ってきているということです。</p>
<pre><code>var xhr=new XMLHttpRequest();
xhr.open("GET","index.html",<mark>false</mark>);
xhr.send();
console.log(xhr.response);	//←ここでもう結果が手に入る
          </code></pre>
<p>今までのように非同期だと、send()した段階ではまだリクエストを送っただけなので、結果が届いているという保証などありませんから、loadイベントなどを利用する必要があります。</p>
<p>また、同期リクエストだと、通信失敗した際に例外（<a href="9_8.html">九章第八回</a>）を投げるので多少やっかいです。まあ、同期だと通信中に何も他の処理ができませんから、普通は非同期を使うことのほうが多いでしょう。</p>

<h3>sendで送るデータ</h3>
<p>さて、sendでは、POSTの場合などに本文を送ることができました。例えばこうです。</p>
<pre><code>var xhr=new XMLHttpRequest();
xhr.open("POST","sample.cgi");
xhr.send("foo=bar&amp;hoge=piyo");</code></pre>
<p>しかし、実は文字列以外も送ることができます。</p>
<p>sendの引数に、ArrayBufferやBlobを渡すことができます。Blobの場合は、本文のデータのMIMEタイプもしっかり設定して送れます。</p>
<p>他に、HTMLDocumentやXMLのDocumentを渡すこともできます。そうなると、そのソースを送ってくれます。</p>
<p>こうしてみると、JSONはありませんが、上のresponseTypeと似ています。しかし、send用にもう一つ実は渡せるものがあります。それは<dfn>FormData</dfn>です。</p>
<p>実は、HTMLのフォームのデータをPOSTで送る際は、特にファイル送信などが混ざってくると、multipart/form-dataという形式にする必要がありこれは複雑です。</p>
<p>そこで、multipart/form-dataの形式を作ってくれるのがFormDataです。FormDataを使うには、そのインスタンスを作ります。</p>
        <pre><code>var data = new <mark>FormData</mark>();</code></pre>
<p>また、FormDataの第一引数にHTMLFormElement（<a href="2_12.html">二章第十二回</a>）を渡すと、その内容を持ったFormDataが得られます。そうでない場合は、最初データは空です。</p>
        <pre><code>var data = new FormData(<mark class="ins">form</mark>);</code></pre>
<p>また、こうして作ったFormDataのインスタンスには、さらに<dfn>append</dfn>メソッドでデータを追加することができます。FormDataのデータは基本的にname-value形式です。例えば、</p>
        <pre><code>&lt;input name="foo" value="bar"&gt;</code></pre>
<p>というinput要素で表されるデータは、名前(name)がfooで値(value)がbarというわけです。これを追加するには、appendメソッドの第一引数に名前、第二引数に値を渡します。つまり上の例の場合こうなります。</p>
        <pre><code>data.<mark>append</mark>("foo","bar");</code></pre>
<p>また、appendメソッドは<strong>ファイル</strong>をデータに追加することができます。これは</p>
        <pre><code>&lt;input type="file"&gt;</code></pre>
<p>に相当するデータです。この時第一引数は名前で同じですが、第二引数は<strong>Blob</strong>です（もちろん、Blobを継承しているFileでもいいということに注意しましょう）。そして、第三引数にファイル名を与えることも可能です。すなわちこんな感じです。</p>
<pre><code>//変数blobには何かのBlobが入っている
data.append("foo",blob,"file.txt");
        </code></pre>
<p>このようにして作ったFormDataオブジェクトをsendに渡すと、multipart/form-dataの形式にして送ってくれます。つまり、HTMLのフォーム（enctype属性が"multipart/form-data"）を送信したときと同じ形式のデータを送ってくれます。</p>

<p>さて、以上にわたってXMLHttpRequestを解説してきましたが、要するに使い道は、HTMLファイルとは別のデータをロードして使いたいとか、そういうときでしょう。結構使い道はあるので、活用しましょう。</p>
        <nav>
      <p>
        <a href="index.html" rel="bookmark">戻る</a>
                            |
          <a rel="prev" href="12_6.html">十二章第六回</a>
                          |
          <a rel="next" href="13_2.html">十三章第二回</a>
              </p>
    </nav>
  </article>

    </main>
  </body>
</html>
    
