<!doctype html>
<html lang="ja-jp">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <link href="/css/css.css" rel="stylesheet">
                  <link href="/css/js.css" rel="stylesheet">
                        <title>九章第六回　ゲッタとセッタ — JavaScript初級者から中級者になろう &#x2014; uhyohyo.net</title>
        <script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-46093038-1', 'auto');
ga('send', 'pageview');
    </script>
  </head>
  <body>
    <header>
      <h1>
        <a href="/">uhyohyo.net</a>
      </h1>
    </header>
    <main>
      
<article> 
  <h1>JavaScript初級者から中級者になろう</h1>
  <aside class="ad-javascript">
    <!-- Google Adsense -->
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:inline-block;width:180px;height:150px"
     data-ad-client="ca-pub-1080533149094679"
     data-ad-slot="7536196754"></ins>
    <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
  </aside>
        <nav>
      <p>
        <a href="index.html" rel="bookmark">戻る</a>
                            |
          <a rel="prev" href="9_5.html">九章第五回</a>
                          |
          <a rel="next" href="9_7.html">九章第七回</a>
              </p>
    </nav>
    <h2>九章第六回　ゲッタとセッタ</h2>

<p>今回はゲッタとセッタの解説をします。前回解説したクロージャと関わってくる話です。</p>
<p>というのも、前回の話は、クロージャを利用してローカル変数に関数を通してアクセスするようにすれば、値の操作を制限できるというものでした。今回は、その別のアプローチです。</p>

<h3>ゲッタとセッタ</h3>
<p>どうするかというと、<dfn>ゲッタ</dfn>と<dfn>セッタ</dfn>を使います。これらは、あるプロパティを参照したり変更しようとするときに、関数を呼ぶというものです。このとき呼ばれる関数が、ゲッタやセッタです。参照されたときに呼ばれるのがゲッタで、値を変更するときに呼ばれるのがセッタです。</p>
<p>したがって、ゲッタやセッタは<strong>関数</strong>です。それでは、ゲッタやセッタをどう作るのか解説します。</p>

<h4>作り方</h4>
<p>作り方の1つは、<strong>オブジェクトを初期化するとき</strong>（オブジェクトを作るとき）にゲッタやセッタを作る方法です。前に、</p>
        <pre><code> { プロパティ:値, プロパティ:値 }</code></pre>
<p>という形でオブジェクトを作ることを解説しました。ここに、<code>プロパティ:値</code>ではない特殊な形を入れます。</p>
<p>次のサンプルを見てみましょう。</p>
<pre><code>var a = {
  <strong>get</strong> <mark>aaa</mark>(){ return 3; },
  <strong>set</strong> <mark>aaa</mark>(){}
};
console.log(a.<mark>aaa</mark>);
a.<mark>aaa</mark>=5;
console.log(a.<mark>aaa</mark>);
          </code></pre>
<p>ログは2つとも3です。</p>
<p>オブジェクトaをつくるとき、<code>プロパティ:値</code>のかわりに、getとsetの形で書かれています。この形は、</p>
        <pre><code><mark>function</mark> 関数名(){ 〜 }</code></pre>
<p>のfunctionがget,setに変わった形です。</p>
<p>まず最初のログで、aのプロパティaaaが参照されています。ここで、get aaaの関数（ゲッタ）が呼ばれるのです。</p>
<p>ゲッタの戻り値が、そのままa.aaaの値として扱われます。今回ゲッタは無条件で3を返すので、a.aaaは3ということになり、3が表示されました。</p>
<p>次では、aaaに5を代入しようとしています。このとき呼ばれるのがセッタ（set aaa）です。</p>
<p>今回セッタの中身は空っぽです。つまり、何も処理をしないということです。ちなみに、今回は使ってませんが、代入されようとしている値は<strong>第一引数</strong>に入っているので、それを利用できます。</p>
<p>さて、セッタが何もしなかったので、</p>
        <pre><code>a.aaa=5;</code></pre>
<p>の行では何も起こらなかったということになります。</p>
<p>次にまたa.aaaを表示していますが、ゲッタは相変わらず3を返すので3が表示されます。</p>

<h3>ゲッタ・セッタの利用</h3>
<p>さて、さっきのサンプルでは、aaaがプロパティとしての役割を果たしていませんでした。これらを、クロージャのときのようにアクセスの制限のために使うのにはどうすればよいのでしょう。</p>
<p>例えば、ゲッタとセッタでaというプロパティを作りたいとします。そうすると、実際のaの値を別のところに保存しておけばいいのです。</p>
<pre><code>var obj = {
  <mark>_a</mark> : 0,
  get <mark>a</mark>(){return this.<mark>_a</mark>; },
  set <mark>a</mark>(n){this._a = n; }
};

obj.a=3;
console.log(obj.a);
          </code></pre>
<p>この例では、プロパティaが参照されるときには_aの値がそのまま返され、代入するときには_aにそのまま代入されます。つまり、_aがそのままaとしての役割を果たしているということです。このようにして、内容を保存することができます。</p>
<pre><code>var obj = {
  <mark>_a</mark> : 0,
  get <mark>a</mark>(){return this.<mark>_a</mark>; },
  set <mark>a</mark>(n){this._a = n<mark class="ins">*2</mark>; }
};

obj.a=3;
console.log(obj.a);
        </code></pre>
<p>こんどは、_aに代入するときに2倍してみました。するとログは「6」になりました。</p>
<p>もう少し実用的な例としては、真偽値以外代入できないというのを作ってみましょう。真偽値とは、trueまたはfalseのことですね。</p>
<p>つまり、値がtrueまたはfalseかどうか判定して、その場合のみ代入すればいいのです。</p>
<pre><code>var obj = {
  <mark>_a</mark> : false,
  get <mark>a</mark>(){return this.<mark>_a</mark>; },
  set <mark>a</mark>(n){
    if(n==false || n==true){
      this.<mark>_a</mark> = n;
    }
  }
};

obj.a=true;
console.log(obj.a);
obj.a="あいうえお";
console.log(obj.a);
        </code></pre>
<p>この場合、最初に<code>obj.a=true;</code>ではtrueが_aに代入され、console.logではtrueが表示されます。</p>
<p>次に"あいうえお"を代入しようとしますが、これはtrueまたはfalseではないので_aに代入されません。したがって、_aは変わらずtrueのままとなります。</p>
<p><small>注： 真偽値かどうかの判定にはtypeof演算子（<a href="11_5">十一章第五回</a>）を使う方法もあります。</small></p>

<p>このように、応用次第でいろいろ使い道があります。前回のクロージャのパターンではいちいち関数を使わないといけませんでしたが、これなら普通のプロパティと同じ感覚で扱えます。ただ、プロパティを扱うたびに関数が処理されるので、普通のプロパティより重いと思われます。</p>
<p>また、配列のlengthも、もともとあるやつなので全く同じではないかもしれませんが、同じ感じで処理されているようです。したがって、lengthは重いと言われることもあります。</p>
<p>例えば、</p>
<pre><code>for(var i=0;i&lt;<mark>aaa</mark>.length;i++){
}</code></pre>
<p>これは普通に配列の1つ1つに処理する感じのforループです。aaaが配列変数ですね。ここで、ループ一回ごとにi&lt;aaa.lengthが処理されるので、aaa.lengthが処理されることになります。したがって、無駄ということになるので、次のような書き方がされることがあります。</p>
<pre><code>for(var i=0<mark class="ins">,l=<mark>aaa.length</mark></mark>;i&lt;<mark class="ins">l</mark>;i++){
}</code></pre>
<p>最初にlengthを変数に入れておいて、あとはそれを使うということです。</p>

<h3>既存のオブジェクトに設定する方法</h3>
<p>さて、ゲッタとセッタにはもうひとつ設定方法があります。いままでの方法は、新しくオブジェクトを作っていましたが、すでにあるオブジェクトにこれらを追加したいときはどうするのでしょう。実は、そのためのメソッドがありました。</p>
<pre><code>var obj = { _a : false };
obj.<dfn>__defineGetter__</dfn>("<mark>a</mark>", function(){ return this.<mark>_a</mark>; });
obj.<dfn>__defineSetter__</dfn>("<mark>a</mark>", function(n){
  if(n==true || n==false){
    this.<mark>_a</mark> = n;
  }
});

obj.a=true;
console.log(obj.a);
obj.a="あいうえお";
console.log(obj.a);
        </code></pre>
<p>__defineGetter__と__defineSetter__が、それぞれゲッタとセッタを設定するメソッドです。第一引数がプロパティ名で、第二引数が関数となっています。このサンプルは、さっきのをこれらを使って書き換えたもので、同じ動作をします。</p>
<p>ところで、「ありました」と過去形なのは、今ではこれは使われないからです。<a href="11_4.html">十一章第四回</a>で紹介するdefinePropertyのほうが今では使われます。ここで紹介した__defineGetter__と__defineSetter__は昔はこれが使われていたという程度に覚えておきましょう。</p>

<h3>ゲッタ・セッタの応用</h3>
<p>ゲッタ・セッタは応用がききます。九章で解説してきたprototypeあたりと組み合わせることができます。あるオブジェクトのprototypeにセッタ・ゲッタを設定すると、そのインスタンス全てで使うことができます。</p>

<p>ところで、次の問題が分かりますか。</p>
<pre><code><mark>//問題：最終的にobj._aの値は何になるか</mark>
var obj = {
  _a : 0,
  get a(){
    this._a++;
    return this._a;
  },
  set a(n){
    this._a=n;
  }
};

obj.a=3;
obj.a+=2;
obj.a;
        </code></pre>
<p>今回のポイントは、ゲッタで_aの値が変動しているということです。</p>
<p>まず、<code>obj.a=3;</code>の行で、_aは3になります。次の行が問題です。</p>
      <pre><code>obj.a+=2;</code></pre>
<p>これは、obj.aに2を足すということです。これを詳しく見ると、「obj.aを参照して、2を足した値を代入する」ということです。この過程で、一度obj.aが参照されます。ここでゲッタが呼ばれるのです。</p>
<p>ゲッタでは、_aが1たされて4になります。それを返すので、参照した結果は4です。2を足すので6になり、それがセッタで_aに代入されます。</p>
<p>最後に<code>obj.a;</code>ですが、書いてあると、とりあえず参照されます。そこでゲッタが呼ばれ、_aは1増えて7となります。</p>
<p>したがって、答えは7です。</p>
<p>今、書いてあると参照されると言いましたが、最初の</p>
      <pre><code>obj.a=3;</code></pre>
<p>やその次では参照されないのでしょうか。これは、真ん中にある<strong>代入演算子</strong>がまず処理されるので、この時点では処理されません。</p>
<p>代入演算子の働きは、左に右を代入することなので、特にobj.aを参照はしません。ここではセッタが呼ばれました。</p>
<p>そして、代入演算子は右の値を<strong>返し</strong>ます。したがって、この文は</p>
      <pre><code><mark class="ins">3</mark>;</code></pre>
<p>となります。ここで終了します。次の行も同じ感じです。</p>
<p>一方、<code>obj.a;</code>は、文を処理し始めると、いきなりobj.aが出てきます。ここで、処理の対象はobj.aそのものとなるので、参照されるのです。</p>
<p>だから、例えば</p>
      <pre><code>b = obj.a;</code></pre>
<p>というように右側にある場合は、まず代入演算子が処理されますが、左に右を代入する過程で、右の値が処理の対象となり、即ち参照されます。ここでゲッタが呼ばれます。</p>
<p>この後代入演算子が値を返し、</p>
      <pre><code><mark class="ins">obj.a</mark>;</code></pre>
<p>の形になりもう一度呼ばれると思えるかもしれませんが、そういうことはありません。<code>b = obj.a;</code>を処理するときにまずobj.aを参照して<code>b = <mark class="ins">(値)</mark>;</code>のように具体的な値になってしまうからです。</p>
<h3>クロージャの利用</h3>
<p>ところで、さっきから実際の値を保存しておくプロパティとして<code>_a</code>を使ってきました。しかしこれでは、<code>_a</code>を直接参照されてしまうと意図しない動作をすることになります。これを回避するためには、前回解説したクロージャを使います。</p>
<pre><code>var obj=(function(){
  var _a=false;
  return {
    get a(){return _a;},
    set a(n){
      if(n==true || n==false){
        _a=n;
      }
    }
  };
})();
</code></pre>
<p>おなじみの、無名関数を作って即座に呼び出す形ですね。無名関数の返り値がオブジェクトであり、変数objに代入されます。</p>
<p>ところが、今回実際にプロパティの値として使われているのは無名関数内のローカル変数です。返り値として新しく作られたオブジェクトのゲッタやセッタも、クロージャとして無名関数の中の環境を利用可能です。これならは、ゲッタとセッタを介す以外に<code>_a</code>にアクセスする方法がないので安全です。</p>
        <nav>
      <p>
        <a href="index.html" rel="bookmark">戻る</a>
                            |
          <a rel="prev" href="9_5.html">九章第五回</a>
                          |
          <a rel="next" href="9_7.html">九章第七回</a>
              </p>
    </nav>
  </article>

    </main>
  </body>
</html>
    
