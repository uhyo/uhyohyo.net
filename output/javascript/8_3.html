<!doctype html>
<html lang="ja-jp">
  <head>
    <meta charset="UTF-8">
    <link href="/css/css.css" rel="stylesheet">
                  <link href="/css/js.css" rel="stylesheet">
                        <title>八章第三回　Rangeの活用とSelection — JavaScript初級者から中級者になろう &#x2014; uhyohyo.net</title>
        <script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-46093038-1', 'auto');
ga('send', 'pageview');
    </script>
  </head>
  <body>
    <header>
      <h1>
        <a href="/">uhyohyo.net</a>
      </h1>
    </header>
    <main>
      
<article> 
  <h1>JavaScript初級者から中級者になろう</h1>
  <aside class="ad-javascript">
    <!-- Google Adsense -->
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:inline-block;width:180px;height:150px"
     data-ad-client="ca-pub-1080533149094679"
     data-ad-slot="7536196754"></ins>
    <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
  </aside>
        <nav>
      <p>
        <a href="index.html" rel="bookmark">戻る</a>
                            |
          <a rel="prev" href="8_2.html">八章第二回</a>
                          |
          <a rel="next" href="8_4.html">八章第四回</a>
              </p>
    </nav>
    <h2>八章第三回　Rangeの活用とSelection</h2>
<h3>Selectionとは</h3>
<p>前回でRangeの機能はだいたい解説しました。しかし、正直なところ、これをいつ使う機会があるのか分からないという人もいるかもしれません。しかし、<dfn>Selection</dfn>というものを使うとき、Rangeが大きく関わってきます。</p>
<p>それでは、この<strong>Selection</strong>とは何なのでしょうか。</p>
<p>これは、<strong>ユーザーがドラッグして選択した範囲</strong>を表すものです。始めから終わりまでマウスでドラッグして選択するわけですから、「開始点」と「終了点」がありますね。ここでRangeが登場するわけです。</p>

<h4>Selectionの取得</h4>
<p>Selectionは、Rangeとは違うオブジェクトです。Selectionを取得するには、<dfn>getSelection</dfn>という関数を使います。引数はありません。</p>
        <pre><code>var selection = <strong>getSelection</strong>();</code></pre>
<p>何かのメソッドでない関数というのも久しぶりですね。</p>

<p>これでSelectionオブジェクトを取得できました。しかし、なぜ直接選択範囲のRangeを取得できないか疑問に思うかもしれません。これにはいくつか理由がありますが、「選択していない場合」や「2つ以上選択している場合」がありえるというのが理由の1つです。</p>
<p>それでは、このSelectionオブジェクトからRangeを取得するには、メソッド<dfn>getRangeAt</dfn>を使います。これは数値の引数を1つ持ち、<strong>何番目のRangeを取得するか</strong>を指定します。</p>
<p>基本は、1つしかRangeがないので0ですが、もし2つ以上の範囲を同時に選択している場合に1以上を使用することがあるかもしれません。ちなみに、今何個Rangeがあるかは、<dfn>rangeCount</dfn>というプロパティでわかります。Rangeを処理するときは、これが0かどうかで処理を分ける必要がでてきます。0の場合、そもそも選択していないのでRangeを取得できません。</p>

<h3>Selectionの機能</h3>
<p>よく使う機能は、<strong>SelectionからRangeを除去する機能</strong>です。選択部分をSelectionから除去すると、実際に選択が解除されます。</p>
<p>Selectionのメソッドで、<dfn>removeRange</dfn>というメソッドがあります。これは、<strong>引数で指定したRangeをSelectionから除去する</strong>というものです。このように除去すべきオブジェクトを直接指定するものには、かつてremoveChild(<a href="2_4.html">二章第四回</a>）がありましたね。</p>
<p>このメソッドの場合、getRangeAtで取得したRangeを引数に指定して削除することになるでしょう。</p>
<pre><code>var sel = getSelection();
if(sel.<mark>rangeCount</mark>&gt;0){
  //Rangeが最低一つある場合
  sel.<strong>removeRange</strong>(sel.<mark>getRangeAt</mark>(<mark>0</mark>));
}
        </code></pre>
<p>しかし、このremoveRangeというメソッドはFirefoxでは実装されていますが、Chromeでは実装されていないようです（2014年7月現在）。これでは少し頼りないので、もう1つ紹介します。</p>
<p>それは、<dfn>removeAllRanges</dfn>です。これは、引数無しで、全てのRangeを除去するというものです。</p>
        <pre><code>sel.<strong>removeAllRanges</strong>();</code></pre>

<h3>Selectionの実践</h3>
<p>さて、Selectionを使えば、Rangeの機能を活かすことができそうです。ちょっとやってみましょう。</p>
<p>しかし、今までのようにbody要素の最後にscript要素を書くパターンだと、ページを読み込んだ瞬間にそれが実行されてそれっきりです。</p>
<p>Selectionはブラウザが選択した範囲をいじるものですから、読み込まれた瞬間に実行されても選択できません。そこで、選択したときを見計らって実行する必要があります。そういうときに使うのが、そう、<strong>イベント</strong>です。忘れた人は、<a href="3_1.html">三章</a>を見るとよいでしょう。</p>

<p>今回どういう時に実行すればいいかですが、ずばり<strong>マウスボタンが上がったタイミング</strong>がいいでしょう。つまり、選択し終わった直後ですね。</p>
<p>ここで使うのは、<dfn>mouseup</dfn>というイベントです。「マウスが上がったとき」ですね。逆に、<strong>mousedown</strong>もあります。これを使って、</p>
<pre><code>
document.addEventListener('<mark>mouseup</mark>',function(ev){


},false);
          </code></pre>
<p>というようにします。さて、これを基本にやっていくわけですが、まずは簡単に、「選択しても消える」というのをやってみましょう。これは簡単で、mouseup時にremoveAllRangesを実行するだけです。</p>
<pre><code>&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;test&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;

    &lt;p&gt;あいうえおかきくけこさしすせそたちつてとなにぬねのはひふへほまみむめもやゆよらりるれろわをん&lt;/p&gt;
    &lt;p&gt;あいうえおかきくけこさしすせそたちつてとなにぬねのはひふへほまみむめもやゆよらりるれろわをん&lt;/p&gt;
    &lt;p&gt;あいうえおかきくけこさしすせそたちつてとなにぬねのはひふへほまみむめもやゆよらりるれろわをん&lt;/p&gt;

    &lt;script type="text/javascript"&gt;
      document.addEventListener('<mark>mouseup</mark>',function(ev){
        <mark class="ins">var selection = <mark>getSelection</mark>();
        selection.<mark>removeAllRanges</mark>();</mark>
      },false);
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
        </code></pre>
<p>簡単にできました。しかし、これを見て「サイトにコピーして欲しくない文章があるから、これを使って対策しよう」とは思いませんよね。ソースを見れば簡単にコピーされるのですから。そんなことを思っているうちはまだまだ初心者なのです。</p>

<p>次に、「選択した部分がページから消える」というのを作ってみましょう。これも簡単です。前回、Rangeの<strong>deleteContents</strong>を解説したので、選択部分のRangeを取得してこれを使えば一発です。</p>
<pre><code>&lt;script type="text/javascript"&gt;
  document.addEventListener('mouseup',function(ev){
    <mark class="ins">var selection = getSelection();
    if(selection.<mark>rangeCount</mark> &gt; 0){
      var range = selection.getRangeAt(0);
      range.<mark>deleteContents</mark>();
      selection.removeAllRanges();
    }</mark>
  },false);
&lt;/script&gt;
          </code></pre>
<p>今回はRangeを取得して扱うので、マウスを押したけど選択していない場合を考慮し、rangeCountを比較してRangeが取得できる場合のみ処理をしています。</p>

<p>さらにさらに、もう少し工夫がいる例として、「選択した部分の背景色が変わる」というのをやってみましょう。</p>
<p>色を変えるには、<strong>スタイルシート</strong>を使うことになります。今回の場合、background-colorプロパティを変えればよいのです。</p>
<p>さて、これは今までのより少し複雑です。ちょっと考えてみましょう。</p>

<h4>まとめて囲む</h4>
<p>まず思いつくのが、background-colorを指定した要素を用意し、選択部分全部そこにいれてしまうというものです。例えば、汎用性の高いspan要素で囲むとすると、</p>
<pre><code>abcde&lt;em&gt;fghijklmn&lt;/em&gt;opqrstuvwxyz
   <mark>|---------------------|</mark>
          </code></pre>
<p>というように選択したとすると、</p>
<pre><code>abc<mark class="ins">&lt;span&gt;</mark>de&lt;em&gt;fghijklmn&lt;/em&gt;opq<mark class="ins">&lt;/span&gt;</mark>rstuvwxyz
          </code></pre>
<p>となるということです。</p>

<p>実は、前回紹介しませんでしたが、まさにこれ用のメソッドがあります。<dfn>surroundContents</dfn>です。引数に、新しい親となるノードを指定します。</p>
<pre><code>&lt;script type="text/javascript"&gt;
  document.addEventListener('mouseup',function(ev){
    var selection = getSelection();
    if(selection.<mark>rangeCount</mark> &gt; 0){
      var range = selection.getRangeAt(0);
      <mark class="ins">//新しいspan要素を作る
      var newspan = document.createElement('span');
      //background-colorを設定
      newspan.style.backgroundColor="<mark>#ffff00</mark>";

      range.<strong>surroundContents</strong>(newspan);</mark>
    }
  },false);
&lt;/script&gt;
          </code></pre>
<p>テキストを適当に選択してみると、いい感じに背景が変わってくれます。</p>
<p>しかし、まだまだ不完全です。3つのp要素がありますが、2つ以上のp要素にまたがって選択すると、なんとエラーが起きます。このエラーはsurrondContentsが起こしたもので、原因はつまりこういうことです。</p>
        <pre><code>&lt;p&gt;......<mark>...&lt;/p&gt;&lt;p&gt;...</mark>.....&lt;/p&gt;</code></pre>
<p>のようにRangeで選択されているとき、これを囲もうとすると</p>
        <pre><code>&lt;p&gt;......<mark class="ins">&lt;span&gt;</mark><mark>...&lt;/p&gt;&lt;p&gt;...</mark><mark class="ins">&lt;/span&gt;</mark>.....&lt;/p&gt;</code></pre>
<p>となります。これは明らかに文法違反ですね。このように囲むことができない場合には、エラーを出してくるのです。これは仕方ないことですが、surrondContentsを使う際は注意しましょう。</p>
<p>ちなみに、動作しないのは仕方ないにしても、いちいちエラーを出すのが格好悪いという場合には、「try-catch構文」（機会があれば紹介するかもしれません）を使えばなんとかなります。</p>

<p>そこで、surrondContentsを使わず手動でこの作業をやると、エラーを起こさずにやることができます。つまり、囲むという作業を分解すると、「抜き出す」「親で囲む」「親を戻す」という3つの作業に分解することができます。これをそれぞれやればいいのです。</p>
<p>まず抜き出すのは<strong>extractContents</strong>を使います。戻り値は<strong>DocumentFragment</strong>でした。このextractContentsは、どんな範囲であろうとうまく抜き出してくれます。</p>
<p>次に親で囲むのは、上と同じようにspan要素を作った後、戻り値のDocumentFragmentをappendChildするだけです。DocumentFragmentは「親がいない兄弟」のような感じなので、ここでも問題は起こりません。</p>
<p>最後に、<strong>insertNode</strong>で抜き出した場所にspan要素を戻します。ここでは、隙間に新しい要素を埋めるだけなので、やはり問題は起こりません。</p>
<p>つまり、こうです。</p>
<pre><code>&lt;script type="text/javascript"&gt;
  document.addEventListener('mouseup',function(ev){
    var selection = getSelection();
    if(selection.<mark>rangeCount</mark> &gt; 0){
      var range = selection.getRangeAt(0);
      <mark class="ins">//新しいspan要素を作る
      var newspan = document.createElement('span');
      //background-colorを設定
      newspan.style.backgroundColor="<mark>#ffff00</mark>";

      var df = range.<mark>extractContents</mark>();
      newspan.<mark>appendChild</mark>(df);
      range.<mark>insertNode</mark>(newspan);</mark>
    }
  },false);
&lt;/script&gt;
            </code></pre>
<p>これでも同じようなことができています。しかしさっきのようにp要素をまたいで選択すると、エラーは起きないものの、p要素が増殖してしまいます。もっとも、それ以前にもう1つ問題があるのですが。</p>
<p>p要素が増殖する原因は、extractContentsの動作にあります。といっても、これも仕方ないことです。</p>
<pre><code>&lt;p&gt;.....<mark>.......&lt;/p&gt;......…</mark>
        <mark>|----------------…</mark></code></pre>
<p>というような範囲の状態でextractContentsをすると、開始点より左の部分も確かにp要素の中、右もp要素の中、ということを両立するために、</p>
<pre><code>&lt;p&gt;.....<mark class="ins">&lt;/p&gt;</mark><mark>&lt;p&gt;.......&lt;/p&gt;......…</mark>
            <mark>|-------------------…</mark></code></pre>
<p>というようにp要素が分割されて抜き出されます。</p>
<p>右の部分をspanで囲んで戻すと、</p>
          <pre><code>&lt;p&gt;.....&lt;/p&gt;<mark class="ins">&lt;span&gt;</mark>&lt;p&gt;.......&lt;/p&gt;......…<mark class="ins">&lt;/span&gt;</mark></code></pre>
<p>となり、1つだったp要素が2つに増えています。</p>
<p>ちなみに、「それ以前の問題」とは、そもそもspan要素の中にp要素が入っていることです。これはいけません。</p>

<p>さて、原因が分かったところで、これの解決は次回ということにします。</p>
        <nav>
      <p>
        <a href="index.html" rel="bookmark">戻る</a>
                            |
          <a rel="prev" href="8_2.html">八章第二回</a>
                          |
          <a rel="next" href="8_4.html">八章第四回</a>
              </p>
    </nav>
  </article>

    </main>
  </body>
</html>
    
