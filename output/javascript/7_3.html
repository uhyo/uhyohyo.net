<!doctype html>
<html lang="ja-jp">
  <head>
    <meta charset="UTF-8">
    <link href="/css/css.css" rel="stylesheet">
                  <link href="/css/js.css" rel="stylesheet">
                        <title>七章第三回　条件を満たすノードをまとめて処理する: TreeWalker — JavaScript初級者から中級者になろう &#x2014; uhyohyo.net</title>
        <script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-46093038-1', 'auto');
ga('send', 'pageview');
    </script>
  </head>
  <body>
    <header>
      <h1>
        <a href="/">uhyohyo.net</a>
      </h1>
    </header>
    <main>
      
<article> 
  <h1>JavaScript初級者から中級者になろう</h1>
  <aside class="ad-javascript">
    <!-- Google Adsense -->
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:inline-block;width:180px;height:150px"
     data-ad-client="ca-pub-1080533149094679"
     data-ad-slot="7536196754"></ins>
    <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
  </aside>
        <nav>
      <p>
        <a href="index.html" rel="bookmark">戻る</a>
                            |
          <a rel="prev" href="7_2.html">七章第二回</a>
                          |
          <a rel="next" href="7_4.html">七章第四回</a>
              </p>
    </nav>
    <h2>七章第三回　条件を満たすノードをまとめて処理する: TreeWalker</h2>
<p>今回も、役立つものを紹介します。ある条件を満たすノードを、まとめて処理する方法です。</p>
<p>同じ感じのことは、今までに多少やってきました。例えば、getElementsByTagName（<a href="2_6.html">二章第六回</a>）は、あるタグ名を持つ要素の一覧を得るためのものです。そうして得たNodeListをfor文などで1つずつ処理すれば、「ある要素名を持つ」という条件を満たすノードをまとめて処理したということになります。</p>
<p>しかし、今回紹介する方法では、要素名だけでなく、もっと複雑な条件を指定できます。</p>
<p>今回紹介するのは、<strong>TreeWalker</strong>です。</p>
<p>直訳すると「木を歩くもの」という意味です。木とは木構造のことで、分かりにくいと思いますが、木構造の上を移動しながら次々処理をしていくというイメージです。</p>
<p>とりあえずやってみましょう。</p>

<h3>TreeWalkerのオブジェクトを作る</h3>
<p>TreeWalkerを使うには、まず<strong>TreeWalkerのオブジェクトを作る</strong>必要があります。それには、documentの<dfn>createTreeWalker</dfn>というメソッドを使います。</p>
<p>これには引数が4つ必要で、1つめの引数は<strong>頂点ノード</strong>、2つめと3つめは<strong>条件</strong>、4つめは実体参照を展開するかどうかです。</p>
<p>頂点ノードとは、そのノード以下（そのノードとその子孫）を探索するというものです。例えば、body要素を指定すると、そこが頂点ですから、その親のhtml要素や兄弟のhead要素は探索されません。文書全体を探索するには、ルート要素であるhtml要素か、あるいはその上であるdocument自体を指定するといいです。ちなみに、ルート要素は、document.documentElement（<a href="3_5.html">三章第五回</a>）で取得できます。</p>
<p>2つめと3つめは条件です。TreeWalkerを作るときに、もう条件を決めてしまうわけですね。できたオブジェクトは、その条件専用のTreeWalkerになります。そして、なぜ引数を2つも条件に使うかですが、それには意味があります。</p>
<p>まず2つめの引数では、<strong>おおまかな条件</strong>を指定します。この大まかな条件は、ノードの種類による絞り込みを行います。ノードの種類は、たとえば「要素ノード(HTMLElement)」とか、「テキストノード」とかです。</p>
<p>これは<strong>数値</strong>で指定しますが、前回と同じように<strong>定数</strong>があります。使えそうなのをいくつか紹介します。</p>
<dl>
  <dt>SHOW_ELEMENT</dt>
  <dd>要素ノードのみ。</dd>
  <dt>SHOW_TEXT</dt>
  <dd>テキストノードのみ。</dt>
  <dt>SHOW_CDATA_SECTION</dt>
  <dd>CDATAセクション（<a href="6_1.html">六章第一回</a>）のみ。</dt>
  <dt>SHOW_COMMENT</dt>
  <dd>コメントノードのみ。</dd>
  <dt>SHOW_ALL</dt>
  <dd>全種類。</dd>
</dl>
<p>これらの定数を引数として渡すわけですが、今回もJavaScriptでどうやって利用するのか解説します。実は、<strong>NodeFilter</strong>という名のついたオブジェクトがあり、これのプロパティとして参照できます。</p>
<p>さらに、これらの定数は、<strong>1つのビットのみが立った数値</strong>で、2つ以上のビットが立った値を渡した場合、その<strong>両方</strong>が対象となります。1つのビットのみが立った数2つからその両方のビットが立った値を得るには、<strong>ビットごとの論理和</strong>を使うのでした。だから、例えば「要素ノード」と「テキストノード」の二種類を対象にしたいとき、</p>
        <pre><code>NodeFilter.<mark>SHOW_ELEMENT</mark> <mark>|</mark> NodeFilter.<mark>SHOW_TEXT</mark></code></pre>
<p>のようにします。これは前回紹介したcompareDocumentPositionと似た感じですね。</p>

<p>さて、3つめの引数では、さらに詳しい条件を指定できます。3つめの引数に指定するのは<strong>関数</strong>です。この関数は<strong>フィルター</strong>と呼ばれ、引数としてノードが渡されます。そのノードが条件を満たすかどうかを判定し、返り値で判定結果をTreeWalkerに教えます。だから、例えばこんな感じです。</p>
<pre><code>function (node){
    if(node.className == "aaa"){
        return <mark>NodeFilter.FILTER_ACCEPT</mark>;
    }else{
        return <mark>NodeFilter.FILTER_SKIP</mark>;
    }
}
          </code></pre>
<p>返り値として、よくわからないものを返しています。実は、これも<strong>定数</strong>で、上と同じようにNodeFilterのプロパティです。</p>
<dl>
  <dt>FILTER_ACCEPT</dt>
  <dd>そのノードは条件を満たす。</dd>
  <dt>FILTER_REJECT</dt>
  <dd>そのノードは条件を満たさず、その子孫も全て条件を満たさない。</dd>
  <dt>FILTER_SKIP</dt>
  <dd>そのノードは条件を満たさない。</dd>
</dl>
<p>の3種類があります。今回の場合そのノードのクラス名が"aaa"であれば（ただしこの方法は"aaa bbb"のように複数のクラスに属する可能性があるから不完全です。<a href="12_1.html">十二章第一回</a>で紹介するclassListを使いましょう）、FILTER_ACCEPTを返すから条件を満たしているということになります。</p>
<p>そうでない場合（else）、FILTER_SKIPを返していて、条件を満たさないということになります。</p>
<p>今回使われていないFILTER_REJECTですが、これも条件を満たさないことを意味します。FILTER_SKIPとの違いは、FILTER_REJECTの場合、その子孫も一緒に問答無用で条件を満たさないことになります。例えば、</p>
<pre><code> A
｜
├―― B
｜　　｜
｜　　├―― C
｜　　｜
｜　　└―― D
｜
└―― E
          </code></pre>
<p>という木構造の場合、BでFILTER_REJECTが返されたら、C,Dが条件を満たしていたとしても、B以下は全て条件を満たさないということにされます。EはBの子孫でないから、影響は受けません。</p>
<p>FILTER_SKIPの場合は、子孫に影響を与えません。上のサンプルの場合、BがFILTER_SKIPだとしても、C,Dもちゃんと判定されて、もし条件を満たしていたら満たしているということになります。</p>
<p>最後に、4番目の引数ですが、基本的に深く考えずにfalseでいいです。これは実体参照(EntityReference)ノードが文書中に存在する場合にそれをそのまま残すか展開するかのオプションなのですが、たいていの処理系は実体参照を読み込み時に展開してしまうので、基本的にはfalseでもtrueでも違いがありません。</p>


<p>さて、今までのを踏まえて、createTreeWalkerを使ってみましょう。条件は、「クラス名が"abc"である要素」ということにしてみます。</p>
<pre><code>var tw = document.<dfn>createTreeWalker</dfn>( document,
NodeFilter.SHOW_ELEMENT,
function(node){
    if(node.className == "abc"){
        return NodeFilter.FILTER_ACCEPT;
    }else{
        return NodeFilter.FILTER_SKIP;
    }
},
false);
          </code></pre>
<p>何行もありますが、これはただcreateTreeWalkerを呼んでいるだけです。見やすいように、引数1つごとに改行をしています。1つめの引数が<code>document</code>、2つめが<code>NodeFilter.SHOW_ELEMENT</code>で、3つめが</p>
<pre><code>function(node){
    if(node.className == "abc"){
        return NodeFilter.FILTER_ACCEPT;
    }else{
        return NodeFilter.FILTER_SKIP;
    }
}</code></pre>
<p>で、4つめが<code>false</code>です。</p>

<h3>TreeWalkerを使う</h3>
<p>さて、こうしてできたTreeWalkerオブジェクトを使ってみましょう。</p>

<h4>TreeWalkerの「位置」</h4>
<p>TreeWalkerには、<strong>位置</strong>というものがあります。TreeWalkerはどこかの<strong>ノード</strong>のところに居ます。そして、ノードからノードへと動き回るのです。</p>
<p>TreeWalkerが動くノードは、それに設定された条件を満たすノードのみです。木構造の上を順番に動いていってひとつずつ処理することで、条件を満たすノードをまとめて処理するという目的を果たすのです。</p>
<p>そして、TreeWalkerを動かすのには、TreeWalkerのメソッドを使います。</p>

<h4>previousNode,nextNode</h4>
<p><dfn>previousNode</dfn>、<dfn>nextNode</dfn>は、TreeWalkerを動かす基本的なメソッドのひとつです。それぞれ、「前のノード」「次のノード」という意味です。</p>
<p>これは、親とか子とかは関係なく、ただ単に「前」「次」のノードです。例えば、</p>
<pre><code> A
｜
├―― <mark>B</mark>
｜　　｜
｜　　├―― C
｜　　｜　　｜
｜　　｜　　└―― <mark>D</mark>
｜　　｜
｜　　└―― <mark>E</mark>
｜　　　　　｜
｜　　　　　└―― F
｜
└―― <mark>G</mark>
　　　｜
　　　├―― <mark>H</mark>
　　　｜
　　　└―― I
　　　　　　｜
　　　　　　└―― <mark>J</mark>
          </code></pre>
<p>という木構造があり、B,D,E,G,H,Jが条件を満たしている場合を考えます。</p>
<p>このとき、Bの次はD、その次がE,G,H,Jとなります。逆も同じです。直感的で分かりやすいと思います。</p>

<p>JavaScriptでは、previousNode,nextNodeを使って次のようにします。</p>
<pre><code>//（twはTreeWalkerオブジェクト）
var node = tw.<mark>nextNode</mark>();
var node2= tw.<mark>previousNode</mark>();
          </code></pre>
<p>これらのメソッドには返り値があり、<strong>移動後の位置にあるノードのオブジェクト</strong>を返します。つまり、例えば最初にBの位置のTreeWalkerがあった場合、nextNodeでDに移動し、変数nodeにはDのノードが入るというわけです。</p>
<p>その後previousNodeで前に移動するとBの位置に移動するから、previousNodeはBを返します。</p>
<p>また、Jの位置でnextNodeを使ったり、Bの位置でpreviousNodeをつかった場合、<strong>nullを返します</strong>。その場合、移動先がないから、TreeWalkerの位置は変わりません。</p>
<p>そして、TreeWalkerが作られた直後は、TreeWalkerの位置は<strong>特に定まっていません</strong>。まだどこにもないという状態ですね。この最初の状態でnextNodeを使うと、最初のノード、つまり上の例の場合Bに移動するということになっています。</p>

<p>これらの性質を利用して、nextNodeだけで条件を満たすノードを全て処理することができます。この方法が、TreeWalkerでもっともよく使われると思います。</p>
<pre><code>//（twは作ったばかりのTreeWalkerオブジェクト）
var node;
while( <mark>node = tw.nextNode()</mark> ){
    node;	//そのノードに対する処理
}
          </code></pre>
<p>という形です。</p>
<p>whileの条件が代入文になっていますね。代入演算子は代入されたその値を返すということは<a href="kiso2.html">基礎編第二回</a>で解説しました。つまり、whileで何回も処理される処理の開始時に変数nodeにnextNodeで移動先のノードを代入し、同時にその値をwhileの条件にしているということです。</p>
<p>順を追ってみていきます。また上のサンプルを使ってみます。</p>
<p>まず、while文に入ると条件式でtw.nextNodeが実行されます。上で解説したとおり、最初のノードであるBが返されます。オブジェクトなら真なので、whileの条件は真となり実行されます。その処理では、変数nodeにBが入っているから、まずBに対して処理ができました。</p>
<p>次、nextNodeはDを返し、TreeWalkerもDの位置に移動します。同様にnodeにはDが入り、Dが処理されます。</p>
<p>以下同様に、E,G,H,Jと処理していきます。</p>
<p>Jの処理が終わったとき、次にnextNodeはJの次がないから<strong>nullを返します</strong>。変数nodeにもnullが代入されます。そして、nullは<strong>偽</strong>だから、while文は無事終了します。</p>
<p>このようにして、nextNodeだけで条件を満たす全てのノードを処理することができました。正直、これさえわかれば十分という感じもしますが、一応他のも紹介しておきます。</p>

<h4>firstChild,lastChild,parentNode</h4>
<p>この3つはいずれもメソッドです。firstChildは「最初の子」、lastChildは「最後の子」、parentNodeは「親ノード」という意味です。それぞれ対応するノードの位置に移動してそのノードを返すというメソッドです。</p>
<p>ただ、firstChild,lastChildは、「条件を満たす子のなかで最初のノード」、「条件を満たす子のなかで最後のノード」です。条件を満たす子がひとつもなければ、nullとなり移動しません。また、対象となるのは直接の子だけということになっています（実際はブラウザによって動作が違ったりします）。</p>
<p>例えば、上の例で、Aから見たらfirstChildはBで、lastChildはGです。Bからみたら、firstChildもlastChildもEです。</p>

<p>また、parentNodeでは、条件を満たす親ノードに移動します。しかし、親ノードはもともと一つしかないですね。もしその親ノードが条件を満たしていない場合は、そのさらに親を探して移動するということになっています。親の親がだめなら親の親の親…のように探します。最終的に頂点ノードまで探しても無かったら、nullとなり移動しません。</p>
<p>例えばDの位置から見たparentNodeは、直接の親のCが条件を満たさないからその上のBが見られ、Bが条件を満たすからBに移動するということになります。</p>

<p>なかなか使いにくいのであまり使われません。</p>

<h4>previousSibling,nextSibling</h4>
<p>previousSiblingは「前の兄弟ノード」、nextSiblingは「次の兄弟ノード」にそれぞれ移動します。previousSiblingは直前の兄弟が条件を満たさなければもうひとつ前、それも満たさなければさらに前…のようにして探します。なければいつものようにnullです。nextSiblingも同様です。</p>

<p>firstChild,lastChild,parentNode,previousSibling,nextSiblingはノードが持つプロパティと同じ名前ですが、こちらはあくまでTreeWalkerが持つメソッドなので、区別しましょう。</p>

<h3>実際のサンプル</h3>
<p>実際に使ってみましょう。今回は、「p要素またはdiv要素の背景色を黄色にする」ということをやってみます。本当は<a href="5_1.html">第五章</a>で解説した方法でやるのがいいですが、サンプルだし気にしません。</p>
<pre><code>&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;test&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;p1&lt;/p&gt;
      &lt;div&gt;div1&lt;/p&gt;
    &lt;p&gt;p2&lt;/p&gt;

    &lt;script type="text/javascript"&gt;
      var tw = document.createTreeWalker(document,
      NodeFilter.SHOW_ELEMENT,
      function(node){
          if(node.tagName=="P" || node.tagName=="DIV"){
              return NodeFilter.FILTER_ACCEPT;
          }else{
              return NodeFilter.FILTER_SKIP;
          }
      },
      false);

      var node;
      while(node = tw.nextNode()){
          node.style.backgroundColor="yellow";
      }
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
        <nav>
      <p>
        <a href="index.html" rel="bookmark">戻る</a>
                            |
          <a rel="prev" href="7_2.html">七章第二回</a>
                          |
          <a rel="next" href="7_4.html">七章第四回</a>
              </p>
    </nav>
  </article>

    </main>
  </body>
</html>
    
