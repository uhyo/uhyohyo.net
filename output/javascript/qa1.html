<!doctype html>
<html lang="ja-jp">
  <head>
    <meta charset="UTF-8">
    <link href="/css/css.css" rel="stylesheet">
                  <link href="/css/js.css" rel="stylesheet">
                        <title>質問と回答 — JavaScript初級者から中級者になろう &#x2014; uhyohyo.net</title>
      </head>
  <body>
    <header>
      <h1>
        <a href="/">uhyohyo.net</a>
      </h1>
    </header>
    <main>
      
<article> 
  <h1>JavaScript初級者から中級者になろう</h1>
  <aside class="ad-javascript">
    <!-- Google Adsense -->
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:inline-block;width:180px;height:150px"
     data-ad-client="ca-pub-1080533149094679"
     data-ad-slot="7536196754"></ins>
    <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
  </aside>
        <nav>
      <p>
        <a href="index.html" rel="bookmark">戻る</a>
                      </p>
    </nav>
    <h2>質問と回答</h2>
<p>寄せられた質問に対して回答します。</p>

<h3 id="2012-11-17">String#matchの複数マッチについて</h3>
<p>回答日: <time>2012-11-17</time></p>
<div class="q">
  <p>String#matchでgオプションをつけると、返り値でグループ化の情報が落ちる。複数マッチさせた上グループ化の情報も得たい。</p>
</div>
<nav class="re">
  <p>関連ページ: <a href="4_2.html">四章第二回</a>・<a href="4_3.html">四章第三回</a></p>
</nav>

<p>String#matchは<a href="4_3.html">四章第三回</a>で解説しました。このときは、matchの戻り値について、<q>グループ化した部分などは、配列から得られなくなります</q>と解説しました。</p>
<p>これは仕様ですのでどうしようもありませんから、複数マッチの場合はひとずつつループを回して対処します。</p>

<h4>普通にループで回す方法</h4>
<p>一つの方法は、1回のmatchで1つずつマッチさせて、その部分を文字列から取り除いて再びマッチさせる方法です。マッチさせる文字列が破壊されますので、コピーしてから行いましょう。</p>
<pre><code><mark class="ins">//携帯電話の番号(090-xxxx-xxxx)にマッチさせた上、前半と後半に分けるサンプル</mark>
var str="090-1234-5678 , 090-8888-8888 / 090-9876-5432 090-0000-0000";

var result;	<mark class="ins">//matchの結果を入れる変数</mark>

while(result = str.<mark>match</mark>(/^<mark>.*?</mark>090-<mark>(\d{4})</mark>-<mark>(\d{4})</mark>/)){
  <mark class="ins">//もうマッチしない場合はresultにnullが入るのでループが終わる</mark>
  console.log(result);	<mark class="ins">//何かに使用する（ここでは表示するだけ）</mark>

  str = str.<mark>slice</mark>(result[0].length);	<mark class="ins">//strから、マッチした部分を取り除く</mark>
}</code></pre>
<p>出力結果は次のような感じです。</p>
<pre><code>["090-1234-5678", "1234", "5678"]
[" , 090-8888-8888", "8888", "8888"]
[" / 090-9876-5432", "9876", "5432"]
[" 090-0000-0000", "0000", "0000"]</code></pre>
<p>ポイントは、matchの引数の最初についている<code>^.*?</code>です。^というのは文字列の一番最初からマッチせよという意味で、.は任意の文字で、*は0回以上の繰り返し、そして*についた?は<strong>最短マッチ</strong>です。最短マッチというのは、なるべく短くマッチするということですから、.が何にでもマッチするとはいえ、マッチすべき部分がその中に含まれてしまう（見逃してしまう）ことはありません。</p>
<p>そして結果の配列の1番目と2番目に欲しい情報が入っていることがわかります。</p>
<p>配列の0番目を見ると、マッチさせたい090-の部分の前にごちゃごちゃと何かが入っているのが分かります。これが.*?にマッチした部分です。ちなみに、最短マッチの?がないと以下のような結果になってしまいます。</p>
        <pre><code>["090-1234-5678 , 090-8888-8888 / 090-9876-5432 090-0000-0000", "0000", "0000"]</code></pre>
<p>.*?の部分に全部含まれてしまい（?がないと最長マッチになってなるべく長く含めようとするため）、一番最後のしか得られません。</p>
<p>そして最後の</p>
        <pre><code>str = str.<mark>slice</mark>(result[0].length);</code></pre>
<p>ですが、sliceは<a href="4_1.html">四章第一回</a>で解説しています。</p>
<p>sliceは、文字列の（第一引数）番目から（第二引数）番目まで抜き出すという意味ですが、第二引数を省略した場合は最後までです。</p>
<p>ここで,<code>result[0]</code>というのはさっき見た通り、今回マッチした部分の全体です。つまり、ここはもうマッチしたから要らないわけです。</p>
<p>さらに、今回の正規表現には最初に<code>^</code>がついていますから、<code>result[0]</code>には文字列の最初から何文字かが入っていることが保証されています。</p>
<p>ですから、<code>result[0]</code>の文字のぶんだけ文字列の最初を取り去ってしまえばいいのです。以上がこのサンプルの動作の説明です。</p>

<h4>matchの結果のindexを利用する方法</h4>
<p>上の方法は、<code>.*?</code>がなんか邪魔です。そこでこれを用いない方法も紹介します。</p>
<pre><code><mark class="ins">//携帯電話の番号(090-xxxx-xxxx)にマッチさせた上、前半と後半に分けるサンプル</mark>
var str="090-1234-5678 , 090-8888-8888 / 090-9876-5432 090-0000-0000";

var result;	<mark class="ins">//matchの結果を入れる変数</mark>

while(result = str.match(/090-(\d{4})-(\d{4})/)){
  <mark class="ins">//もうマッチしない場合はresultにnullが入るのでループが終わる</mark>
  console.log(result);	<mark class="ins">//何かに使用する（ここでは表示するだけ）</mark>

  str = str.slice(<mark>result.index</mark>+result[0].length);	<mark class="ins">//strから、マッチした部分を取り除く</mark>
}</code></pre>
<p>結果は以下のとおりです。</p>
<pre><code>["090-1234-5678", "1234", "5678"]
["090-8888-8888", "8888", "8888"]
["090-9876-5432", "9876", "5432"]
["090-0000-0000", "0000", "0000"]</code></pre>
<p>このソースがさっきと違う点は、正規表現から余計な部分が消えたという点と、sliceの引数にresult.indexを足しているという点です。</p>
<p>結果を見ても、<code>result[0]</code>も余計なものがくっついていなくて使いやすくなっています。</p>
<p>ところで、resultというのはstr.matchの戻り値ですから、配列のはずですが、実はString#matchの戻り値の配列には<dfn>index</dfn>という特別なプロパティが追加されています（実は、もう一つinputというのもありますが紹介しません）。</p>
<p>このindexというのは、文字列の最初から数えて何番目にマッチしたかということです。例えば、</p>
<pre><code>"12345abcde67890"
     <mark>~~~</mark></code></pre>
<p>という文字列で"abc"にマッチさせた場合、</p>
<pre><code>var result="12345abcde67890".match(/abc/);
console.log(result.<mark>index</mark>);	<mark class="ins">//<mark>5</mark></mark></code></pre>
<p>abcの最初の文字aがあるのは5番目ですから（最初が0番目であることに注意）、indexプロパティには5が入っています。</p>
<p>これを用いれば、ここで示されたindexより前の部分はマッチしなかったのですからもう要りません。それに、今回マッチした<code>result[0]</code>の部分の長さを足して、その部分を捨ててしまおうというのが、</p>
        <pre><code>result.index+result[0].length</code></pre>
<p>の意味です。</p>

<h4>Regexp#execとlastIndexを使う方法 <em class="rec">おすすめ</em></h4>
<p><dfn>lastIndex</dfn>とは、<strong>正規表現オブジェクト</strong>がもつプロパティです。これを用いると次のように書けます。</p>
<pre><code><mark class="ins">//携帯電話の番号(090-xxxx-xxxx)にマッチさせた上、前半と後半に分けるサンプル</mark>
var str="090-1234-5678 , 090-8888-8888 / 090-9876-5432 090-0000-0000";

var regexp= /090-(\d{4})-(\d{4})/<mark>g</mark>;
var result;	<mark class="ins">//matchの結果を入れる変数</mark>

while(result = regexp.<strong>exec</strong>(<mark>str</mark>)){
  <mark class="ins">//もうマッチしない場合はresultにnullが入るのでループが終わる</mark>
  console.log(result);	<mark class="ins">//何かに使用する（ここでは表示するだけ）</mark>
}</code></pre>
<p>この方法は、str.sliceを用いてstrを書き換える必要がなくなり、とてもすっきりしています。</p>
<p>ポイントは、<dfn>exec</dfn>というメソッドです。これはtestと同じく正規表現オブジェクトがもつメソッドで、String#matchと同じです。</p>
<p>ただし、見ての通り、String#matchとは、文字列と正規表現オブジェクトの関係が逆になっています。</p>
<p>また、正規表現にgオプションがついている場合は2つの挙動は変わります。String#matchのほうは前に紹介した通り、複数のマッチ結果を全て配列にして返します。</p>
<p>Regexp#execのほうは、gがついても挙動は<strong>それほど変わりません</strong>。ただし、gがある場合、正規表現オブジェクトの<dfn>lastIndex</dfn>プロパティが変化します。lastIndexというのは、<strong>次回のマッチを開始する位置</strong>で、最初は0です。</p>
<p>そしてこのlastIndexが、ちょうど今回マッチした部分の次の位置にセットさせるのです。</p>
<p>つまり、簡単にいうと、同じ正規表現オブジェクトで（lastIndexを保持するため）、RegExp#execを使ってマッチさせると、マッチさせるたびに次のところがマッチして、全部終わったらちゃんとnullを返してくれます。これは、毎回lastIndexが変化するからで、Regexp#matchをgオプションつきの正規表現オブジェクトで呼び出したときに特有の動作です。</p>
        <nav>
      <p>
        <a href="index.html" rel="bookmark">戻る</a>
                      </p>
    </nav>
  </article>

    </main>
  </body>
</html>
    
