<!doctype html>
<html lang="ja-jp">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <link href="/css/css.css" rel="stylesheet">
                  <link href="/css/js.css" rel="stylesheet">
                        <title>十章第二回　DOMでのXPathの利用 — JavaScript初級者から中級者になろう &#x2014; uhyohyo.net</title>
        <script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-46093038-1', 'auto');
ga('send', 'pageview');
    </script>
  </head>
  <body>
    <header>
      <h1>
        <a href="/">uhyohyo.net</a>
      </h1>
    </header>
    <main>
      
<article> 
  <h1>JavaScript初級者から中級者になろう</h1>
  <aside class="ad-javascript">
    <!-- Google Adsense -->
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:inline-block;width:180px;height:150px"
     data-ad-client="ca-pub-1080533149094679"
     data-ad-slot="7536196754"></ins>
    <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
  </aside>
        <nav>
      <p>
        <a href="index.html" rel="bookmark">戻る</a>
                            |
          <a rel="prev" href="10_1.html">十章第一回</a>
                          |
          <a rel="next" href="10_3.html">十章第三回</a>
              </p>
    </nav>
    <h2>十章第二回　DOMでのXPathの利用</h2>

<h3>Javascript DOMでXPathを使う</h3>
<p>いよいよ今回、JavaScript DOMでXPathを使う方法を紹介します。</p>
<p>ここで出てくるのが、documentの<dfn>evaluate</dfn>というメソッドです。</p>
<p>これは、5個の引数を渡してXPathを処理してもらい、結果を<dfn>XPathResult</dfn>というオブジェクトで返すものです。</p>
<p>具体的なサンプルを見てみましょう。</p>
<pre><code>var result = document.<strong>evaluate</strong>('/html', document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null);
          </code></pre>
<p>これで、<code>/html</code>という単純なXPath文ですが、これの結果を取得できていることになります。</p>
<p>それでは引数の解説ですが、第一引数はXPath文です。これはいいですね。</p>
<p>つぎに、第二引数にはdocumentが渡されています。これは、<strong>ルートノード</strong>です。すなわち、（このノードも含めて）このノードより下で探索するということです。documentということは、木構造全部ということですね。基本はdocumentで事足りるでしょう。</p>
<p>次は第三引数で、これは今nullとなっています。これは<strong>名前空間解決器</strong>です。</p>
<p>これはどういうことかというと、実はXPathはXML（やXHTML）でも使用できます。その際に、名前空間（<a href="6_2.html">六章第二回</a>）を考慮する必要が出てきます。</p>
<p>タグは<code>&lt;<mark>xhtml:</mark>html&gt;</code>
  のように名前空間接頭辞がついていることがありました。ところが、この接頭辞が名前空間の実体というわけではなく、実体は<strong>URI</strong>（http://www.w3.org/1999/xhtmlなど）なのです。</p>
<p>そこで、接頭辞を名前空間の実体に対応付ける仕組みが必要です。これが<strong>名前空間解決器</strong>なのです。名前空間があるXML文書の場合はこれが必要です。</p>
<p>それでは、この名前空間解決器が必要なときはどうやって作ればよいのでしょうか。実はそんなに難しくなく、そのためのメソッドがあります。それは、document.<dfn>createNSResolver</dfn>です。引数を1つとり、頂点ノードを渡します。すると、それ以下に出現する名前空間に対応した名前空間解決器が返り値として出てきます。すなわち、</p>
        <pre><code>document.<mark>createNSResolver</mark>(document.documentElement)</code></pre>
<p>という感じです。頂点ノードとしてdocument.documentElementを指定すると、文書中の全ての名前空間に対応できます。</p>
<p>ともかく、今回はHTMLで名前空間はないので、nullで構いません。</p>
<p>さて、第四引数は<strong>結果のタイプ</strong>です。今回は</p>
        <pre><code>XPathResult.<mark>FIRST_ORDERED_NODE_TYPE</mark></code></pre>
<p>です。これは明らかに定数で、当然他にもあるのですが、各定数の解説は後述とします。この定数は、見つかったノードが普通に取得できるというものです。</p>
<p>次に第五引数はnullとなっていますが、これは<strong>再利用器</strong>です。これは何かというと、XPathResultオブジェクトを再利用できるのです。どういうことかというと、通常document.evaluateで結果を得るときは新しいXPathResultが作られて結果として返されます。つまり、1回実行するごとに新しいXPathResultオブジェクトがどんどんできるのです。これは無駄だということで、この第五引数に使い終わったXPathResultオブジェクトを渡すと、そのオブジェクトを書き換えて新しいXPathResultオブジェクトを作らずにそれを返してくれます。特に何度もXPathを利用する場合はこれを活用するのがよいでしょう。</p>

<p>さて、結果のXPathResultからノードを得る方法ですが、これは<strong>結果タイプ</strong>によって変わってきます。詳しくは後述しますが、今回の場合は
  <code>result.<mark>singleNodeValue</mark></code>
  で該当するノードが取得できます。試してみましょう。</p>
<pre><code>&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;test&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;test&lt;/p&gt;
    &lt;script type="text/javascript"&gt;
      var result = document.<mark>evaluate</mark>('/html', document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null);

      console.log(result.singleNodeValue.tagName);
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
          </code></pre>
  <p>実行すると「HTML」というログが出ます。つまり、singleNodeValueがhtml要素になっていて、結果としてhtml要素が取得できたということです。</p>

  <h3>結果タイプ</h3>
  <p>それでは、結果タイプの解説をします。</p>
  <p>これは定数で、<strong>XPathResult</strong>のプロパティとして利用できます。</p>
  <p>まず基本的に、いくつか種類がありますが、それぞれについて<strong>ORDERED</strong>と<strong>UNORDERED</strong>があります。ORDEREDは、ノードが<strong>文書順</strong>（最初から順番に並んでいる）になっています。対してUNORDEREDの場合、並び順は適当です。</p>
  <p>ORDEREDの場合かならず文書順に探さないといけませんが、UNORDEREDの場合ブラウザが探しやすい順番で探せるので、UNORDEREDのほうが少し速い可能性があります。</p>
  <dl>
    <dt>ANY_<mark>UNORDERED</mark>_NODE_TYPE, FIRST_<mark>ORDERED</mark>_NODE_TYPE</dt>
    <dd>
    <p>これは、ノードを<strong>1つだけ</strong>取得します。というのも、前回解説したように当てはまるものが複数あった場合それら全てのノードの集まりが<strong>ノードセット</strong>としてヒットしたことになります（ちなみに、1つだけの場合でもノードが1つのノードセットということになります）。</p>
    <p>そのうち最初の1つだけを取得します。UNORDEREDの場合探す順番が不定なので、複数あった場合どれが出てくるか分かりません。ORDEREDの場合、文書順で探して最初なので、必ず最初に見つかったノードとなります。</p>
    <p>そして、結果の取得方法は、結果の<strong>singleNodeValue</strong>プロパティにノードが入っています。</p>
    </dd>
    <dt><mark>UNORDERED</mark>_NODE_SNAPSHOT_TYPE, <mark>ORDERED</mark>_NODE_SNAPSHOT_TYPE</dt>
    <dd>
    <p>複数の結果を全て扱える方法です。最初に全部集めてくる方法です。</p>
    <p>結果の<dfn>snapshotLength</dfn>に、結果のノードの個数が入っています。そして、結果のノードには0から番号がついていて、<dfn>snapshotItem</dfn>というメソッドに数値を渡すことでその番号のノードが返ってきます。</p>
    <p>すなわち、複数のノードを処理するのに次のようにできます。</p>
    <pre><code>//resultは結果のオブジェクト
  for(var i=0;i&lt;result.<mark>snapshotLength</mark>;i++){
    var node = result.<mark>snapshotItem</mark>(i);
    //得られたnodeに対して処理をする
  }
            </code></pre>
  </dd>
  <dt><mark>UNORDERED</mark>_NODE_ITERATOR_TYPE, <mark>ORDERED</mark>_NODE_ITERATOR_TYPE</dt>
  <dd>
  <p>これも複数のノードを全て扱える方法です。前述のSNAPSHOTと違うのは、document.evaluateの時点でノードを集めてこないということです。</p>
  <p>この方法では、結果の<dfn>iterateNext</dfn>メソッド（引数なし）を呼び出すことでその都度次のノードを探索して返してくれます。もう無い場合はnullになります。すなわち、次のようにして処理できます。</p>
  <pre><code>//resultは結果のオブジェクト
var node;
while(node = result.<mark>iterateNext()</mark>){
  //得られたnodeに対して処理をする
}
</code></pre>
</dd>
</dl>
<p>他にもまだありますが、それはここでは説明しません。あとで説明します。</p>
<p>さて、SNAPSHOT系とITERATOR系の違いですが、前者は最初に全部集めておいて処理し、後者は最初の時点では何もせず、必要となるたびに探して持ってくるというものでした。これには多少の違いがあります。</p>
<p>SNAPSHOT系はもう全部集めてきて結果が確定しているので、その後文書に変更があった場合も影響を受けず、新しく条件を満たすノードが追加されたとしてもそれを処理できません。</p>
<p>ではITERATOR系はできるかというと、実はそうでもありません。もっと厳しく、文書が変更されたら結果が変になるかもしれないということで、文書が変更されたらもうその結果は無効となってしまい、もともとのノードを処理することすらできなくなります。</p>

<h3>サンプル</h3>
<p>具体的なサンプルを用意してみました。単純なものですが、いろいろ自分で工夫するなどしてみましょう。</p>
<pre><code>&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;test&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p id="test"&gt;test&lt;/p&gt;
    &lt;p id="test2"&gt;test2&lt;/p&gt;
    &lt;p id="test3"&gt;test3&lt;/p&gt;
    &lt;script type="text/javascript"&gt;
      var result = document.evaluate('/descendant::p', document, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE, null);

      var node;
      while(node=result.iterateNext()){
        console.log(node.id);
      }
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>XPath文は、全てのp要素を取得するというものです。</p>
<p>そして、タイプはORERED_NODE_ITERATORなので、このようにwhile文で処理しています。今回は、得られたノードに対してとりあえずログでidを表示しています。</p>
<p>だから、「test」「test2」「test3」と表示されるはずです。</p>
        <nav>
      <p>
        <a href="index.html" rel="bookmark">戻る</a>
                            |
          <a rel="prev" href="10_1.html">十章第一回</a>
                          |
          <a rel="next" href="10_3.html">十章第三回</a>
              </p>
    </nav>
  </article>

    </main>
  </body>
</html>
    
