<!doctype html>
<html lang="ja-jp">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <link href="/css/css.css" rel="stylesheet">
                  <link href="/css/js.css" rel="stylesheet">
                        <title>十章第三回　属性の取得と型 — JavaScript初級者から中級者になろう &#x2014; uhyohyo.net</title>
        <script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-46093038-1', 'auto');
ga('send', 'pageview');
    </script>
  </head>
  <body>
    <header>
      <h1>
        <a href="/">uhyohyo.net</a>
      </h1>
    </header>
    <main>
      
<article> 
  <h1>JavaScript初級者から中級者になろう</h1>
  <aside class="ad-javascript">
    <!-- Google Adsense -->
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:inline-block;width:180px;height:150px"
     data-ad-client="ca-pub-1080533149094679"
     data-ad-slot="7536196754"></ins>
    <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
  </aside>
        <nav>
      <p>
        <a href="index.html" rel="bookmark">戻る</a>
                            |
          <a rel="prev" href="10_2.html">十章第二回</a>
                          |
          <a rel="next" href="10_4.html">十章第四回</a>
              </p>
    </nav>
    <h2>十章第三回　属性の取得と型</h2>

<h3>属性を取得する</h3>
<p>今回は、新しい軸が出てきます。</p>
<p>実は、XPathではあるノードの<b>属性</b>を調べることができます。</p>
<p>そこで使うのが<dfn>attribute軸</dfn>です。例えばこうです。</p>
        <pre><code>/html/<mark>attribute::</mark>lang</code></pre>
<p>これは、html要素のlang属性を取得していることになります。</p>
<p>さて、ここで、今までXPathでは<strong>ノードセット</strong>を取得してきました。ところが、属性というのはどうなんでしょう。属性はノードではないのではないでしょうか。</p>
<p>ということで、実験してみましょう。</p>
<pre><code>&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;test&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;test&lt;/p&gt;
    &lt;script type="text/javascript"&gt;
      var result = document.evaluate('/html/attribute::lang', document, null, XPathResult.ANY_UNORDERED_NODE_TYPE, null);

      var kekka = result.singleNodeValue;
      console.log(kekka);
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
          </code></pre>
<p>結果を見ると、得られたオブジェクトは<dfn>Attr</dfn>というオブジェクトだということが分かります。実は、</p>
<pre><code>kekka instanceof <mark>Attr</mark>
kekka instanceof <mark>Node</mark></code></pre>
<p>のどちらもtrueであり、これも<strong>ノードの一種</strong>であることが分かります。</p>

<h4>Attrノード</h4>
<p>さて、このAttrから値をどう取得するのかというと、<dfn>value</dfn>というプロパティがあり、それに文字列で値が入っています。</p>
<p>他にもできることはありますが、今回はこのAttrは本題ではないので詳しく解説しません。</p>

<p>それで、</p>
        <pre><code>console.log(kekka.<mark>value</mark>);</code></pre>
<p>とすると無事"jp"が取得できます。</p>

<h3>XPathの型</h3>
<p>さて、これが本題でないとはどういうことかというと、実際のところこのAttrオブジェクトの使用頻度は低く、もっと便利な方法があります。</p>
<p>それは、<strong>XPath上で直接文字列に変換する</strong>という方法です。今までXPathが扱ってきたのはノードだけでしたが、実は<strong>文字列も扱える</strong>のです。それどころか、JavaScriptと同様の<strong>真偽値</strong>・<strong>数値</strong>も扱えます。</p>
<p>つまり、<strong>XPathにも<strong>型</strong>がある</strong>のです。つまり、真偽値型、数値型、文字列型、そしてノードセット型の4つです。</p>
<p>それでは具体的にどうするのか見てみます。</p>
        <pre><code><mark>string(</mark> /html/attribute::lang <mark>)</mark></code></pre>
<p>というようにします。</p>
<p>ここで、<code>/html/attribute::lang</code>を<code>string()</code>で囲んでいます。これは関数のようですが、実際<strong>関数</strong>です。XPathには関数があったのです。</p>

<p>それで、このstring関数は当然引数を文字列に変換して返します。これは属性のノードの場合その属性の値に変換されます。</p>
<p>つまり、</p>
        <pre><code><mark>string(</mark> /html/attribute::lang <mark>)</mark></code></pre>
<p>の最終的な結果は<strong>文字列型</strong>であるということです。</p>
<p>ここで、最終的に結果の取得はどうすればよいのでしょう。前回紹介した結果タイプは、全てノードセット用のものでした。実はこれでは対応できません。そこで、新しい定数を紹介します。</p>
<dl>
  <dt>NUMBER_TYPE</dt>
  <dd>数値である結果を取得します。プロパティ<dfn>numberValue</dfn>で取り出せます。</dd>
  <dt>STRING_TYPE</dt>
  <dd>文字列である結果を取得します。プロパティ<dfn>stringValue</dfn>で取り出せます。</dd>
  <dt>BOOLEAN_TYPE</dt>
  <dd>真偽値である結果を取得します。プロパティ<dfn>booleanValue</dfn>で取り出せます。</dd>
  <dt>ANY_TYPE</dt>
  <dd>
  結果の型に応じて自動的に結果タイプを選びます。数値、文字列、真偽値の場合はNUMBER_TYPE,STRING_TYPE,BOOLEAN_TYPEになり、ノードセットの場合はUNORDERED_NODE_ITERATOR_TYPEとなります。
  </dd>
</dl>
<p>これは単純ですね。では、属性を文字列値で取得してみましょう。</p>
<pre><code>&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;test&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;test&lt;/p&gt;
    &lt;script type="text/javascript"&gt;
      var result = document.evaluate('<mark>string(</mark>/html/attribute::lang<mark>)</mark>', document, null, XPathResult.<mark>STRING_TYPE</mark>, null);

      var kekka = result.<mark>stringValue</mark>;
      console.log(kekka);
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
          </code></pre>
<p>result.stringValueに直接文字列値で"jp"が入っていることが分かります。</p>

<h3>attribute軸の省略</h3>
<p>ここでひとつ新しい省略記法を紹介しておきます。といっても単純なもので、attribute軸を<strong>@</strong>で省略できるというものです。すなわち、</p>
        <pre><code>/html/attribute::lang</code></pre>
<p>を</p>
        <pre><code>/html/<mark>@</mark>lang</code></pre>
<p>と書けます。これは楽ですね。</p>
        <nav>
      <p>
        <a href="index.html" rel="bookmark">戻る</a>
                            |
          <a rel="prev" href="10_2.html">十章第二回</a>
                          |
          <a rel="next" href="10_4.html">十章第四回</a>
              </p>
    </nav>
  </article>

    </main>
  </body>
</html>
    
