<!doctype html>
<html lang="ja-jp">
  <head>
    <meta charset="UTF-8">
    <link href="/css/css.css" rel="stylesheet">
                  <link href="/css/js.css" rel="stylesheet">
                        <title>十三章第二回　Server-Sent Events — JavaScript初級者から中級者になろう &#x2014; uhyohyo.net</title>
      </head>
  <body>
    <header>
      <h1>
        <a href="/">uhyohyo.net</a>
      </h1>
    </header>
    <main>
      
<article> 
  <h1>JavaScript初級者から中級者になろう</h1>
  <aside class="ad-javascript">
    <!-- Google Adsense -->
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:inline-block;width:180px;height:150px"
     data-ad-client="ca-pub-1080533149094679"
     data-ad-slot="7536196754"></ins>
    <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
  </aside>
        <nav>
      <p>
        <a href="index.html" rel="bookmark">戻る</a>
                            |
          <a rel="prev" href="13_1.html">十三章第一回</a>
                          |
          <a rel="next" href="13_3.html">十三章第三回</a>
              </p>
    </nav>
    <h2>十三章第二回　Server-Sent Events</h2>
<p>今回紹介するのは<dfn>Server-Sent Events</dfn>と呼ばれる仕組みです。これは、「サーバーから送られたイベント」という程度の意味でしょう。</p>
<p>これはどういうことかというと、<strong>push型</strong>のデータ通信が可能になります。push型というのは、「サーバーから能動的にデータを送ってくる」ということです。</p>
<p>今まではどうだったかというと、サーバーからデータをもらうには、HTTP通信でこちらから<strong>リクエスト</strong>を送り、それに応じてサーバーが<strong>レスポンス</strong>を返すろいう形でした。これは、<strong>こちらからデータをもらいに行かないとデータがもらえない</strong>ということです（JavaScriptからなら、<a href="13_1.html">前回</a>のXMLHttpRequestが使用できるでしょう）。</p>
<p>例えばJavaScriptでチャットを作りたいとしましょう。新しい発言があったかどうかを知るためには、一定時間ごとにサーバーにリクエストを送ってそれで確かめる必要があるのです。</p>
<p>それに対しpush型ならば、新しい発言があった時点でサーバー側からデータを送ってもらうということが可能です。前者の場合には一定時間ごとにしか最新の発言を得るチャンスはありませんでしたが、後者ならばリアルタイムで発言を取得することが可能です。</p>
<p>そのpush型を可能にするのがServer-Sent Eventsなのです。</p>

<h3>Server-Sent Eventsの仕組み</h3>
<p>Server-Sent Eventsにおいては、やはり<strong>HTTP通信</strong>を使用します。通常のHTTP通信においては、こちら側からサーバー側へリクエストを送り、サーバーからレスポンスが帰ってくるとそれで終了します。しかし、push型にするためには、通信が切れてしまっては困ります。そこで、Server-Sent Eventsでは、HTTP通信でサーバーから応答しても、<strong>接続を終了せずに維持します</strong>。こうすることで、その接続を利用してサーバー側からメッセージを継続的に送ることができます。これは形としては、サーバーからのレスポンスを時間をかけて送り続けているという体裁になります。</p>
<p>ちなみに、これだとサーバーから一方的に送るだけで、逆にこちらからサーバーからへは送れません。なぜなら、HTTP通信においてはあくまで「リクエスト→レスポンス→終了」という流れをとるため、一度サーバーがデータを送り始めたらもうこちら側からデータを送れなくなるからです。</p>
<p>それを克服した仕組みに<strong>WebSocket</strong>があります。これも機会があったら紹介します。これはもはやHTTPではない別のプロトコルを使うので、双方向に通信が可能なリアルタイムのやつです。これも使えると楽しいです。</p>

<p>さて、Server-Sent Eventsを使うには、サーバー側からそれに対応したデータを送ってもらう必要があります。</p>
<p>HTTP通信なのですが、サーバーは<strong>text/event-stream</strong>というMIMEタイプでレスポンスを返します。サーバーから送られてくるデータの1単位は<strong>イベント</strong>といいます。イベントは文字列です。</p>
<p>イベントは、サーバーから次のようなテキストで送られてきます。</p>
<pre><code>data: foo</code></pre>
<p>この場合「foo」という中身のイベントがサーバーから送られてきます。このように、サーバーから送られてくるイベントは行の最初に「data: 」と書かれてある必要があります。また、内容は複数行になっても可能です。この場合、すべての行の最初にdata:が必要です。</p>
<pre><code>data: foo
data: bar</code></pre>
<p>これは、「foo(改行)bar」という2行の内容からなる1つのイベントです。</p>
<p>また、複数のイベントは、<strong>空行</strong>によって区切られます。例えば、</p>
<pre><code>data: foo
data: bar

data: test</code></pre>
<p>とした場合、「foo(改行)bar」というイベントと「test」というイベントの2つが送られてきていることを意味します。</p>
<p>さて、「push型」というくらいですから、一度に全てのイベントが送られてくる必要はありません。サーバーが送りたいときに、新しいイベントを追加で送ってきてもいいのです。むしろ、それこそがServer-Sent Eventsの意味であるとも言えるでしょう。</p>
<p>具体例を見せましたが、ここで大事なことは実は、イベントは複数行にわたって送られてきてもよく、イベントを区切るには空行をはさむということです。また、送られてくるイベントデータの一行一行を<strong>フィールド</strong>といいます。</p>

<h3>イベントの中身</h3>
<p>フィールドは実は、</p>
        <pre><code><mark>フィールド名</mark>: <mark>フィールドの中身</mark></code></pre>
<p>という構成になっています。上の例は全て、フィールド名が「data」であった場合です。フィールド名がdataであった場合、そのフィールドは、イベントの内容を表します。上の例のように、dataフィールドは2つ以上あっても構いません。その場合、1つ1つがイベントの中身の1行1行を表すことになりますね。</p>
<p>それでは、フィールド名には他に何があるかというと、<strong>event</strong>というイベント名があります。つまり例えば、</p>
        <pre><code><mark>event</mark>: test</code></pre>
<p>これは何を表すかというと、<strong>イベント名</strong>です。つまり、イベントに、中身とは別に名前をつけられるのです。ちなみに、今までの例のような、eventフィールドがない場合、イベントの名前はデフォルトである「message」になります。</p>
<p>今のところ、このdataフィールドとeventフィールドを覚えておくと良いでしょう。</p>

<h3>JavaScriptからの利用</h3>
<p>では、JavaScriptからServer-Sent Eventsを利用してサーバーからデータを受信する方法を紹介します。それは、<dfn>EventSource</dfn>というオブジェクトを使います。</p>
        <pre><code>var stream= new <mark>EventSource</mark>("test.cgi");</code></pre>
<p>ここで第一引数に<strong>URL</strong>を指定しています。これは、前述のイベントを配信してくれるページのURLですね。</p>
<p>このとき、<strong>同オリジンポリシー</strong>が適用されます。これは、<a href="13_1.html">前回</a>も登場した、同じオリジンでないと通信できないということです。また、<strong>Access-Control-Allow-Originを使えば異なるオリジンでも通信可能</strong>という点も同じです。</p>
<p>こうしてEventSourceのインスタンスができましたが、これは3つのプロパティを持ちます。<dfn>url</dfn>は接続先のURLです。また、<dfn>withCredentials</dfn>を持っています。これは前回のXHRと同じ意味です。また、<dfn>readyState</dfn>も持っています。readyStateは前回のXHRよりも単純で、値は3つしかありません。また、readystatechangeイベントもありません。</p>
<dl>
  <dt>0 (CONNECTING)</dt>
  <dd>また接続が確立されていないことを表します。</dd>
  <dt>1 (OPEN)</dt>
  <dd>現在接続中で、イベントを受信する準備ができていることを表します。</dd>
  <dt>2 (CLOSED)</dt>
  <dd>接続が終了した状態です。</dd>
</dl>
<p>さて、それではイベントを受信するには、やはりXHR同様に<strong>イベント</strong>を使います。イベントを検出するには、もちろんaddEventListenerです。イベントは、上で紹介した、eventフィールドを利用して設定するイベント名がそのまま使用されます。例えば、デフォルトのmessageという名前のイベントのときはこうです。</p>
<pre><code>stream.addEventListener("<mark>message</mark>",function(e){

},false);</code></pre>
<p>ここでイベントオブジェクトeは<dfn>MessageEvent</dfn>といいます。イベントの中身は、この<dfn>data</dfn>プロパティに入っています。また<dfn>origin</dfn>には配信元のURLが入っています。</p>
<p>ここで、<a href="13_2_sample.html">サンプル</a>を見てみましょう。</p>
<p>このサンプルでは、<a href="13_2_sample.cgi">13_2_sample.cgi</a>が配信しています。これは、次のようなイベントを配信します。</p>
<pre><code>data:Hello

data:Hello2

data:foobar
</code></pre>
<p>実は、アクセスを受けてから数秒待ったあとにイベントを配信するようになっています。</p>
<p>それで、受信側のソースは簡単で、こうです。</p>
<pre><code>var stream=new EventSource("13_2_sample.cgi");
  stream.addEventListener('message',function(e){
  console.log(e.data);
});</code></pre>
<p>13_2_sample.cgiに接続して、messageという名のイベントが届いたらそのデータをコンソールに表示します。今回は4つのイベントをまとめて配信していますが、間をあけて複数回イベントを送れば、間をあけてイベントが発生するのが見られるでしょう（本当はそのようなサンプルを用意したかったのですが、サーバーの仕様等の関係でうまくいきませんでした）。</p>
<p>ここでイベント名がmessageなのは、上でeventフィールドが無いので省略されているからです。eventフィールドで別の名前を指定すれば、その名前のイベントになります。もちろん、サーバー側から複数の種類（名前）のイベントを配信しても構いません。その場合別々のイベントが発生することになり、複数種類の情報を配信するときも楽です。</p>
<p>今回の場合はただのCGIなのであまり使い道がわかりませんが、もっとちゃんとしたサーバーを用意すれば、チャットとか、実用的な用途も見つかることでしょう。ただし、上でちらりと紹介したWebSocketにそういった方面の座をとられていることも否めません。</p>

<h3>接続と切断</h3>
<p>ところで、さっきのサンプルを眺めていると、奇妙な動作をすることに気が付きましたか。</p>
<p>イベントを受信したあと、しばらくするともう一度同じイベントを受信します。これは、サーバー側から何度もループしているわけではありません。サーバーは、最後のイベントを出力した後に終了しています。</p>
<p>それではなぜこのような現象が起こるのでしょう。実は、EventSourceでは、サーバーから接続が切断された場合、<strong>再接続を試みる</strong>のです。ただし、404が返ってきたとか、サーバーに繋がらないとか、そういうときは再接続はしません。一度はつながったのに切れてしまった場合には、再接続を試みるのです。</p>
<p>これは、不慮の事態によって接続が切断されてしまった場合には便利ですが、もう配信を終了したいという場合には困ります。実は上のreadyStateの2(CLOSED)というのは、もう再接続もできず、終了してしまったという状態を指します。</p>
<p>それに対処するために、2つのイベントを紹介します。それは<dfn>open</dfn>と<dfn>error</dfn>です。openは単純であり、配信元との接続が確立して準備が完了したときに発生します。そしてerrorというのは、実は接続が切断され、再接続を試みるときに発生します。</p>
<p>ですから、errorが発生したときに、再接続を阻止してやればいいのです。しかし、DOMのときと違って、preventDefault()すればいいわけではありません。ここで使うのが、EventSourceの<dfn>close</dfn>メソッド（引数無し）です。これを呼び出すと、接続を切断して、再接続も行わなくなります。つまり、以下のようになります。</p>
<pre><code>stream.addEventListener("<mark>error</mark>",function(e){
  stream.<mark>close</mark>();
});</code></pre>
<p>これを追加した<a href="13_2_sample2.html">サンプル2</a>で確認しましょう。0まで受信した後、待ってみてもまた10から始まることはありません。配信元との接続を終了してしまったからです。</p>
<p>また、再接続に関して、再接続の待機時間（接続が切断されてから、次に再接続する間に待機する時間）を設定することができます。これは、サーバー側から設定します。</p>
<p>どのように設定するかというと、<dfn>retryフィールド</dfn>を使います。つまりこうです。</p>
<pre><code><mark>retry</mark>: 1000
data:Hello

<mark class="ins">(以下略)</mark>
        </code></pre>
<p>この1000というのはミリ秒なので、1秒という意味になります。接続が切断されたら1秒待ってから再接続しろということです。</p>
<p>ちなみに、今までdataフィールド、eventフィールド、retryフィールドを紹介しましたが、もう一種類だけあります。それが<dfn>idフィールド</dfn>です。これは、そのイベントに対して<strong>ID</strong>を付加したい場合に使用できます。例えばこんな感じです。</p>
<pre><code>data:Hello
<mark>id</mark>: abc

data:Hello2
<mark>id</mark>: foo
        </code></pre>
<p>このidはMessageEventの<dfn>lastEventId</dfn>プロパティで参照できますが、もうひとつ意味があります。</p>
<p>接続が切れて再接続したとき、一番最後に受信したイベントのIDが<dfn>Last-Event-ID</dfn>というHTTPヘッダとなってサーバーへ送られます。これにより、サーバー側をうまく作れば、接続が切れたとき次の接続で途中から再開するようなことも可能でしょう。</p>
<p>また、再接続といえば、サーバーからの配信が全部終了して切断したときは再接続したくないけれども、それ以外のときは再接続したいという場合もあるでしょう。そのときはerrorイベントでは対処できません。こういうときどうすればいいかというと、考えると単純です。サーバー側から「もう接続を終了しなさい」ということを送ってもらえばいいのです。例えばこうです。</p>
<pre><code><mark class="ins">(略)</mark>

data:foobar

<mark>event: close</mark>
        </code></pre>
<p>データを最後まで送った後、「close」という名のイベント（dataフィールドがないので中身はない）が送られてきています。これを受けて、</p>
<pre><code>stream.addEventListener("<mark>close</mark>",function(e){
  stream.close();
});</code></pre>
<p>こういう感じで、closeを受け取ったときだけ閉じてやればいいのです。</p>
<p>実は今回使用した<a href="13_2_sample.cgi">13_2_sample.cgi</a>では、最後に<code>event:close</code>としてcloseイベントを配信しています。よければ試してみましょう。</p>

<p>さて、以上でServer-Sent Eventsの説明は終了です。まとめると、HTTPでサーバー側から一方的なpush型の通信が可能だということです。あまり使い所がないかもしれませんが、もし機会があったら使うのもよいでしょう。</p>
        <nav>
      <p>
        <a href="index.html" rel="bookmark">戻る</a>
                            |
          <a rel="prev" href="13_1.html">十三章第一回</a>
                          |
          <a rel="next" href="13_3.html">十三章第三回</a>
              </p>
    </nav>
  </article>

    </main>
  </body>
</html>
    
